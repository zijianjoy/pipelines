/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.ml_metadata = (function() {

    /**
     * Namespace ml_metadata.
     * @exports ml_metadata
     * @namespace
     */
    var ml_metadata = {};

    ml_metadata.ArtifactAndType = (function() {

        /**
         * Properties of an ArtifactAndType.
         * @memberof ml_metadata
         * @interface IArtifactAndType
         * @property {ml_metadata.IArtifact|null} [artifact] ArtifactAndType artifact
         * @property {ml_metadata.IArtifactType|null} [type] ArtifactAndType type
         */

        /**
         * Constructs a new ArtifactAndType.
         * @memberof ml_metadata
         * @classdesc Represents an ArtifactAndType.
         * @implements IArtifactAndType
         * @constructor
         * @param {ml_metadata.IArtifactAndType=} [properties] Properties to set
         */
        function ArtifactAndType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtifactAndType artifact.
         * @member {ml_metadata.IArtifact|null|undefined} artifact
         * @memberof ml_metadata.ArtifactAndType
         * @instance
         */
        ArtifactAndType.prototype.artifact = null;

        /**
         * ArtifactAndType type.
         * @member {ml_metadata.IArtifactType|null|undefined} type
         * @memberof ml_metadata.ArtifactAndType
         * @instance
         */
        ArtifactAndType.prototype.type = null;

        /**
         * Creates a new ArtifactAndType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ArtifactAndType
         * @static
         * @param {ml_metadata.IArtifactAndType=} [properties] Properties to set
         * @returns {ml_metadata.ArtifactAndType} ArtifactAndType instance
         */
        ArtifactAndType.create = function create(properties) {
            return new ArtifactAndType(properties);
        };

        /**
         * Encodes the specified ArtifactAndType message. Does not implicitly {@link ml_metadata.ArtifactAndType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ArtifactAndType
         * @static
         * @param {ml_metadata.IArtifactAndType} message ArtifactAndType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactAndType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifact != null && Object.hasOwnProperty.call(message, "artifact"))
                $root.ml_metadata.Artifact.encode(message.artifact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                $root.ml_metadata.ArtifactType.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArtifactAndType message, length delimited. Does not implicitly {@link ml_metadata.ArtifactAndType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ArtifactAndType
         * @static
         * @param {ml_metadata.IArtifactAndType} message ArtifactAndType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactAndType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtifactAndType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ArtifactAndType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ArtifactAndType} ArtifactAndType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactAndType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ArtifactAndType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.artifact = $root.ml_metadata.Artifact.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = $root.ml_metadata.ArtifactType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtifactAndType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ArtifactAndType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ArtifactAndType} ArtifactAndType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactAndType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtifactAndType message.
         * @function verify
         * @memberof ml_metadata.ArtifactAndType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtifactAndType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifact != null && message.hasOwnProperty("artifact")) {
                var error = $root.ml_metadata.Artifact.verify(message.artifact);
                if (error)
                    return "artifact." + error;
            }
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.ml_metadata.ArtifactType.verify(message.type);
                if (error)
                    return "type." + error;
            }
            return null;
        };

        /**
         * Creates an ArtifactAndType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ArtifactAndType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ArtifactAndType} ArtifactAndType
         */
        ArtifactAndType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ArtifactAndType)
                return object;
            var message = new $root.ml_metadata.ArtifactAndType();
            if (object.artifact != null) {
                if (typeof object.artifact !== "object")
                    throw TypeError(".ml_metadata.ArtifactAndType.artifact: object expected");
                message.artifact = $root.ml_metadata.Artifact.fromObject(object.artifact);
            }
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".ml_metadata.ArtifactAndType.type: object expected");
                message.type = $root.ml_metadata.ArtifactType.fromObject(object.type);
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtifactAndType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ArtifactAndType
         * @static
         * @param {ml_metadata.ArtifactAndType} message ArtifactAndType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtifactAndType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.artifact = null;
                object.type = null;
            }
            if (message.artifact != null && message.hasOwnProperty("artifact"))
                object.artifact = $root.ml_metadata.Artifact.toObject(message.artifact, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.ml_metadata.ArtifactType.toObject(message.type, options);
            return object;
        };

        /**
         * Converts this ArtifactAndType to JSON.
         * @function toJSON
         * @memberof ml_metadata.ArtifactAndType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtifactAndType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtifactAndType;
    })();

    ml_metadata.ArtifactStructMap = (function() {

        /**
         * Properties of an ArtifactStructMap.
         * @memberof ml_metadata
         * @interface IArtifactStructMap
         * @property {Object.<string,ml_metadata.IArtifactStruct>|null} [properties] ArtifactStructMap properties
         */

        /**
         * Constructs a new ArtifactStructMap.
         * @memberof ml_metadata
         * @classdesc Represents an ArtifactStructMap.
         * @implements IArtifactStructMap
         * @constructor
         * @param {ml_metadata.IArtifactStructMap=} [properties] Properties to set
         */
        function ArtifactStructMap(properties) {
            this.properties = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtifactStructMap properties.
         * @member {Object.<string,ml_metadata.IArtifactStruct>} properties
         * @memberof ml_metadata.ArtifactStructMap
         * @instance
         */
        ArtifactStructMap.prototype.properties = $util.emptyObject;

        /**
         * Creates a new ArtifactStructMap instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ArtifactStructMap
         * @static
         * @param {ml_metadata.IArtifactStructMap=} [properties] Properties to set
         * @returns {ml_metadata.ArtifactStructMap} ArtifactStructMap instance
         */
        ArtifactStructMap.create = function create(properties) {
            return new ArtifactStructMap(properties);
        };

        /**
         * Encodes the specified ArtifactStructMap message. Does not implicitly {@link ml_metadata.ArtifactStructMap.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ArtifactStructMap
         * @static
         * @param {ml_metadata.IArtifactStructMap} message ArtifactStructMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactStructMap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ml_metadata.ArtifactStruct.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified ArtifactStructMap message, length delimited. Does not implicitly {@link ml_metadata.ArtifactStructMap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ArtifactStructMap
         * @static
         * @param {ml_metadata.IArtifactStructMap} message ArtifactStructMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactStructMap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtifactStructMap message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ArtifactStructMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ArtifactStructMap} ArtifactStructMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactStructMap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ArtifactStructMap(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.properties === $util.emptyObject)
                        message.properties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.ml_metadata.ArtifactStruct.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.properties[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtifactStructMap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ArtifactStructMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ArtifactStructMap} ArtifactStructMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactStructMap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtifactStructMap message.
         * @function verify
         * @memberof ml_metadata.ArtifactStructMap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtifactStructMap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!$util.isObject(message.properties))
                    return "properties: object expected";
                var key = Object.keys(message.properties);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.ml_metadata.ArtifactStruct.verify(message.properties[key[i]]);
                    if (error)
                        return "properties." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArtifactStructMap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ArtifactStructMap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ArtifactStructMap} ArtifactStructMap
         */
        ArtifactStructMap.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ArtifactStructMap)
                return object;
            var message = new $root.ml_metadata.ArtifactStructMap();
            if (object.properties) {
                if (typeof object.properties !== "object")
                    throw TypeError(".ml_metadata.ArtifactStructMap.properties: object expected");
                message.properties = {};
                for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                    if (typeof object.properties[keys[i]] !== "object")
                        throw TypeError(".ml_metadata.ArtifactStructMap.properties: object expected");
                    message.properties[keys[i]] = $root.ml_metadata.ArtifactStruct.fromObject(object.properties[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtifactStructMap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ArtifactStructMap
         * @static
         * @param {ml_metadata.ArtifactStructMap} message ArtifactStructMap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtifactStructMap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.properties = {};
            var keys2;
            if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                object.properties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.properties[keys2[j]] = $root.ml_metadata.ArtifactStruct.toObject(message.properties[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this ArtifactStructMap to JSON.
         * @function toJSON
         * @memberof ml_metadata.ArtifactStructMap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtifactStructMap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtifactStructMap;
    })();

    ml_metadata.ArtifactStructList = (function() {

        /**
         * Properties of an ArtifactStructList.
         * @memberof ml_metadata
         * @interface IArtifactStructList
         * @property {Array.<ml_metadata.IArtifactStruct>|null} [elements] ArtifactStructList elements
         */

        /**
         * Constructs a new ArtifactStructList.
         * @memberof ml_metadata
         * @classdesc Represents an ArtifactStructList.
         * @implements IArtifactStructList
         * @constructor
         * @param {ml_metadata.IArtifactStructList=} [properties] Properties to set
         */
        function ArtifactStructList(properties) {
            this.elements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtifactStructList elements.
         * @member {Array.<ml_metadata.IArtifactStruct>} elements
         * @memberof ml_metadata.ArtifactStructList
         * @instance
         */
        ArtifactStructList.prototype.elements = $util.emptyArray;

        /**
         * Creates a new ArtifactStructList instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ArtifactStructList
         * @static
         * @param {ml_metadata.IArtifactStructList=} [properties] Properties to set
         * @returns {ml_metadata.ArtifactStructList} ArtifactStructList instance
         */
        ArtifactStructList.create = function create(properties) {
            return new ArtifactStructList(properties);
        };

        /**
         * Encodes the specified ArtifactStructList message. Does not implicitly {@link ml_metadata.ArtifactStructList.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ArtifactStructList
         * @static
         * @param {ml_metadata.IArtifactStructList} message ArtifactStructList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactStructList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elements != null && message.elements.length)
                for (var i = 0; i < message.elements.length; ++i)
                    $root.ml_metadata.ArtifactStruct.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArtifactStructList message, length delimited. Does not implicitly {@link ml_metadata.ArtifactStructList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ArtifactStructList
         * @static
         * @param {ml_metadata.IArtifactStructList} message ArtifactStructList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactStructList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtifactStructList message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ArtifactStructList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ArtifactStructList} ArtifactStructList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactStructList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ArtifactStructList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.elements && message.elements.length))
                        message.elements = [];
                    message.elements.push($root.ml_metadata.ArtifactStruct.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtifactStructList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ArtifactStructList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ArtifactStructList} ArtifactStructList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactStructList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtifactStructList message.
         * @function verify
         * @memberof ml_metadata.ArtifactStructList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtifactStructList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elements != null && message.hasOwnProperty("elements")) {
                if (!Array.isArray(message.elements))
                    return "elements: array expected";
                for (var i = 0; i < message.elements.length; ++i) {
                    var error = $root.ml_metadata.ArtifactStruct.verify(message.elements[i]);
                    if (error)
                        return "elements." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArtifactStructList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ArtifactStructList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ArtifactStructList} ArtifactStructList
         */
        ArtifactStructList.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ArtifactStructList)
                return object;
            var message = new $root.ml_metadata.ArtifactStructList();
            if (object.elements) {
                if (!Array.isArray(object.elements))
                    throw TypeError(".ml_metadata.ArtifactStructList.elements: array expected");
                message.elements = [];
                for (var i = 0; i < object.elements.length; ++i) {
                    if (typeof object.elements[i] !== "object")
                        throw TypeError(".ml_metadata.ArtifactStructList.elements: object expected");
                    message.elements[i] = $root.ml_metadata.ArtifactStruct.fromObject(object.elements[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtifactStructList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ArtifactStructList
         * @static
         * @param {ml_metadata.ArtifactStructList} message ArtifactStructList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtifactStructList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.elements = [];
            if (message.elements && message.elements.length) {
                object.elements = [];
                for (var j = 0; j < message.elements.length; ++j)
                    object.elements[j] = $root.ml_metadata.ArtifactStruct.toObject(message.elements[j], options);
            }
            return object;
        };

        /**
         * Converts this ArtifactStructList to JSON.
         * @function toJSON
         * @memberof ml_metadata.ArtifactStructList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtifactStructList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtifactStructList;
    })();

    ml_metadata.ArtifactStruct = (function() {

        /**
         * Properties of an ArtifactStruct.
         * @memberof ml_metadata
         * @interface IArtifactStruct
         * @property {ml_metadata.IArtifactAndType|null} [artifact] ArtifactStruct artifact
         * @property {ml_metadata.IArtifactStructMap|null} [map] ArtifactStruct map
         * @property {ml_metadata.IArtifactStructList|null} [list] ArtifactStruct list
         */

        /**
         * Constructs a new ArtifactStruct.
         * @memberof ml_metadata
         * @classdesc Represents an ArtifactStruct.
         * @implements IArtifactStruct
         * @constructor
         * @param {ml_metadata.IArtifactStruct=} [properties] Properties to set
         */
        function ArtifactStruct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtifactStruct artifact.
         * @member {ml_metadata.IArtifactAndType|null|undefined} artifact
         * @memberof ml_metadata.ArtifactStruct
         * @instance
         */
        ArtifactStruct.prototype.artifact = null;

        /**
         * ArtifactStruct map.
         * @member {ml_metadata.IArtifactStructMap|null|undefined} map
         * @memberof ml_metadata.ArtifactStruct
         * @instance
         */
        ArtifactStruct.prototype.map = null;

        /**
         * ArtifactStruct list.
         * @member {ml_metadata.IArtifactStructList|null|undefined} list
         * @memberof ml_metadata.ArtifactStruct
         * @instance
         */
        ArtifactStruct.prototype.list = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ArtifactStruct value.
         * @member {"artifact"|"map"|"list"|undefined} value
         * @memberof ml_metadata.ArtifactStruct
         * @instance
         */
        Object.defineProperty(ArtifactStruct.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["artifact", "map", "list"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ArtifactStruct instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ArtifactStruct
         * @static
         * @param {ml_metadata.IArtifactStruct=} [properties] Properties to set
         * @returns {ml_metadata.ArtifactStruct} ArtifactStruct instance
         */
        ArtifactStruct.create = function create(properties) {
            return new ArtifactStruct(properties);
        };

        /**
         * Encodes the specified ArtifactStruct message. Does not implicitly {@link ml_metadata.ArtifactStruct.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ArtifactStruct
         * @static
         * @param {ml_metadata.IArtifactStruct} message ArtifactStruct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactStruct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifact != null && Object.hasOwnProperty.call(message, "artifact"))
                $root.ml_metadata.ArtifactAndType.encode(message.artifact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.map != null && Object.hasOwnProperty.call(message, "map"))
                $root.ml_metadata.ArtifactStructMap.encode(message.map, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.list != null && Object.hasOwnProperty.call(message, "list"))
                $root.ml_metadata.ArtifactStructList.encode(message.list, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArtifactStruct message, length delimited. Does not implicitly {@link ml_metadata.ArtifactStruct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ArtifactStruct
         * @static
         * @param {ml_metadata.IArtifactStruct} message ArtifactStruct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactStruct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtifactStruct message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ArtifactStruct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ArtifactStruct} ArtifactStruct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactStruct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ArtifactStruct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.artifact = $root.ml_metadata.ArtifactAndType.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.map = $root.ml_metadata.ArtifactStructMap.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.list = $root.ml_metadata.ArtifactStructList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtifactStruct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ArtifactStruct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ArtifactStruct} ArtifactStruct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactStruct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtifactStruct message.
         * @function verify
         * @memberof ml_metadata.ArtifactStruct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtifactStruct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.artifact != null && message.hasOwnProperty("artifact")) {
                properties.value = 1;
                {
                    var error = $root.ml_metadata.ArtifactAndType.verify(message.artifact);
                    if (error)
                        return "artifact." + error;
                }
            }
            if (message.map != null && message.hasOwnProperty("map")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.ml_metadata.ArtifactStructMap.verify(message.map);
                    if (error)
                        return "map." + error;
                }
            }
            if (message.list != null && message.hasOwnProperty("list")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.ml_metadata.ArtifactStructList.verify(message.list);
                    if (error)
                        return "list." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArtifactStruct message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ArtifactStruct
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ArtifactStruct} ArtifactStruct
         */
        ArtifactStruct.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ArtifactStruct)
                return object;
            var message = new $root.ml_metadata.ArtifactStruct();
            if (object.artifact != null) {
                if (typeof object.artifact !== "object")
                    throw TypeError(".ml_metadata.ArtifactStruct.artifact: object expected");
                message.artifact = $root.ml_metadata.ArtifactAndType.fromObject(object.artifact);
            }
            if (object.map != null) {
                if (typeof object.map !== "object")
                    throw TypeError(".ml_metadata.ArtifactStruct.map: object expected");
                message.map = $root.ml_metadata.ArtifactStructMap.fromObject(object.map);
            }
            if (object.list != null) {
                if (typeof object.list !== "object")
                    throw TypeError(".ml_metadata.ArtifactStruct.list: object expected");
                message.list = $root.ml_metadata.ArtifactStructList.fromObject(object.list);
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtifactStruct message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ArtifactStruct
         * @static
         * @param {ml_metadata.ArtifactStruct} message ArtifactStruct
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtifactStruct.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.artifact != null && message.hasOwnProperty("artifact")) {
                object.artifact = $root.ml_metadata.ArtifactAndType.toObject(message.artifact, options);
                if (options.oneofs)
                    object.value = "artifact";
            }
            if (message.map != null && message.hasOwnProperty("map")) {
                object.map = $root.ml_metadata.ArtifactStructMap.toObject(message.map, options);
                if (options.oneofs)
                    object.value = "map";
            }
            if (message.list != null && message.hasOwnProperty("list")) {
                object.list = $root.ml_metadata.ArtifactStructList.toObject(message.list, options);
                if (options.oneofs)
                    object.value = "list";
            }
            return object;
        };

        /**
         * Converts this ArtifactStruct to JSON.
         * @function toJSON
         * @memberof ml_metadata.ArtifactStruct
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtifactStruct.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtifactStruct;
    })();

    ml_metadata.PutArtifactsRequest = (function() {

        /**
         * Properties of a PutArtifactsRequest.
         * @memberof ml_metadata
         * @interface IPutArtifactsRequest
         * @property {Array.<ml_metadata.IArtifact>|null} [artifacts] PutArtifactsRequest artifacts
         * @property {ml_metadata.PutArtifactsRequest.IOptions|null} [options] PutArtifactsRequest options
         */

        /**
         * Constructs a new PutArtifactsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutArtifactsRequest.
         * @implements IPutArtifactsRequest
         * @constructor
         * @param {ml_metadata.IPutArtifactsRequest=} [properties] Properties to set
         */
        function PutArtifactsRequest(properties) {
            this.artifacts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutArtifactsRequest artifacts.
         * @member {Array.<ml_metadata.IArtifact>} artifacts
         * @memberof ml_metadata.PutArtifactsRequest
         * @instance
         */
        PutArtifactsRequest.prototype.artifacts = $util.emptyArray;

        /**
         * PutArtifactsRequest options.
         * @member {ml_metadata.PutArtifactsRequest.IOptions|null|undefined} options
         * @memberof ml_metadata.PutArtifactsRequest
         * @instance
         */
        PutArtifactsRequest.prototype.options = null;

        /**
         * Creates a new PutArtifactsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutArtifactsRequest
         * @static
         * @param {ml_metadata.IPutArtifactsRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutArtifactsRequest} PutArtifactsRequest instance
         */
        PutArtifactsRequest.create = function create(properties) {
            return new PutArtifactsRequest(properties);
        };

        /**
         * Encodes the specified PutArtifactsRequest message. Does not implicitly {@link ml_metadata.PutArtifactsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutArtifactsRequest
         * @static
         * @param {ml_metadata.IPutArtifactsRequest} message PutArtifactsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutArtifactsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifacts != null && message.artifacts.length)
                for (var i = 0; i < message.artifacts.length; ++i)
                    $root.ml_metadata.Artifact.encode(message.artifacts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.ml_metadata.PutArtifactsRequest.Options.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PutArtifactsRequest message, length delimited. Does not implicitly {@link ml_metadata.PutArtifactsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutArtifactsRequest
         * @static
         * @param {ml_metadata.IPutArtifactsRequest} message PutArtifactsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutArtifactsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutArtifactsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutArtifactsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutArtifactsRequest} PutArtifactsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutArtifactsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutArtifactsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifacts && message.artifacts.length))
                        message.artifacts = [];
                    message.artifacts.push($root.ml_metadata.Artifact.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.options = $root.ml_metadata.PutArtifactsRequest.Options.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutArtifactsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutArtifactsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutArtifactsRequest} PutArtifactsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutArtifactsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutArtifactsRequest message.
         * @function verify
         * @memberof ml_metadata.PutArtifactsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutArtifactsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifacts != null && message.hasOwnProperty("artifacts")) {
                if (!Array.isArray(message.artifacts))
                    return "artifacts: array expected";
                for (var i = 0; i < message.artifacts.length; ++i) {
                    var error = $root.ml_metadata.Artifact.verify(message.artifacts[i]);
                    if (error)
                        return "artifacts." + error;
                }
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.ml_metadata.PutArtifactsRequest.Options.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a PutArtifactsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutArtifactsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutArtifactsRequest} PutArtifactsRequest
         */
        PutArtifactsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutArtifactsRequest)
                return object;
            var message = new $root.ml_metadata.PutArtifactsRequest();
            if (object.artifacts) {
                if (!Array.isArray(object.artifacts))
                    throw TypeError(".ml_metadata.PutArtifactsRequest.artifacts: array expected");
                message.artifacts = [];
                for (var i = 0; i < object.artifacts.length; ++i) {
                    if (typeof object.artifacts[i] !== "object")
                        throw TypeError(".ml_metadata.PutArtifactsRequest.artifacts: object expected");
                    message.artifacts[i] = $root.ml_metadata.Artifact.fromObject(object.artifacts[i]);
                }
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".ml_metadata.PutArtifactsRequest.options: object expected");
                message.options = $root.ml_metadata.PutArtifactsRequest.Options.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a PutArtifactsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutArtifactsRequest
         * @static
         * @param {ml_metadata.PutArtifactsRequest} message PutArtifactsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutArtifactsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifacts = [];
            if (options.defaults)
                object.options = null;
            if (message.artifacts && message.artifacts.length) {
                object.artifacts = [];
                for (var j = 0; j < message.artifacts.length; ++j)
                    object.artifacts[j] = $root.ml_metadata.Artifact.toObject(message.artifacts[j], options);
            }
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.ml_metadata.PutArtifactsRequest.Options.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this PutArtifactsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutArtifactsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutArtifactsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        PutArtifactsRequest.Options = (function() {

            /**
             * Properties of an Options.
             * @memberof ml_metadata.PutArtifactsRequest
             * @interface IOptions
             * @property {boolean|null} [abortIfLatestUpdatedTimeChanged] Options abortIfLatestUpdatedTimeChanged
             */

            /**
             * Constructs a new Options.
             * @memberof ml_metadata.PutArtifactsRequest
             * @classdesc Represents an Options.
             * @implements IOptions
             * @constructor
             * @param {ml_metadata.PutArtifactsRequest.IOptions=} [properties] Properties to set
             */
            function Options(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Options abortIfLatestUpdatedTimeChanged.
             * @member {boolean} abortIfLatestUpdatedTimeChanged
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @instance
             */
            Options.prototype.abortIfLatestUpdatedTimeChanged = false;

            /**
             * Creates a new Options instance using the specified properties.
             * @function create
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @static
             * @param {ml_metadata.PutArtifactsRequest.IOptions=} [properties] Properties to set
             * @returns {ml_metadata.PutArtifactsRequest.Options} Options instance
             */
            Options.create = function create(properties) {
                return new Options(properties);
            };

            /**
             * Encodes the specified Options message. Does not implicitly {@link ml_metadata.PutArtifactsRequest.Options.verify|verify} messages.
             * @function encode
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @static
             * @param {ml_metadata.PutArtifactsRequest.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.abortIfLatestUpdatedTimeChanged != null && Object.hasOwnProperty.call(message, "abortIfLatestUpdatedTimeChanged"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.abortIfLatestUpdatedTimeChanged);
                return writer;
            };

            /**
             * Encodes the specified Options message, length delimited. Does not implicitly {@link ml_metadata.PutArtifactsRequest.Options.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @static
             * @param {ml_metadata.PutArtifactsRequest.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Options message from the specified reader or buffer.
             * @function decode
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ml_metadata.PutArtifactsRequest.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutArtifactsRequest.Options();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.abortIfLatestUpdatedTimeChanged = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Options message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ml_metadata.PutArtifactsRequest.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Options message.
             * @function verify
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Options.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.abortIfLatestUpdatedTimeChanged != null && message.hasOwnProperty("abortIfLatestUpdatedTimeChanged"))
                    if (typeof message.abortIfLatestUpdatedTimeChanged !== "boolean")
                        return "abortIfLatestUpdatedTimeChanged: boolean expected";
                return null;
            };

            /**
             * Creates an Options message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ml_metadata.PutArtifactsRequest.Options} Options
             */
            Options.fromObject = function fromObject(object) {
                if (object instanceof $root.ml_metadata.PutArtifactsRequest.Options)
                    return object;
                var message = new $root.ml_metadata.PutArtifactsRequest.Options();
                if (object.abortIfLatestUpdatedTimeChanged != null)
                    message.abortIfLatestUpdatedTimeChanged = Boolean(object.abortIfLatestUpdatedTimeChanged);
                return message;
            };

            /**
             * Creates a plain object from an Options message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @static
             * @param {ml_metadata.PutArtifactsRequest.Options} message Options
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Options.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.abortIfLatestUpdatedTimeChanged = false;
                if (message.abortIfLatestUpdatedTimeChanged != null && message.hasOwnProperty("abortIfLatestUpdatedTimeChanged"))
                    object.abortIfLatestUpdatedTimeChanged = message.abortIfLatestUpdatedTimeChanged;
                return object;
            };

            /**
             * Converts this Options to JSON.
             * @function toJSON
             * @memberof ml_metadata.PutArtifactsRequest.Options
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Options.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Options;
        })();

        return PutArtifactsRequest;
    })();

    ml_metadata.PutArtifactsResponse = (function() {

        /**
         * Properties of a PutArtifactsResponse.
         * @memberof ml_metadata
         * @interface IPutArtifactsResponse
         * @property {Array.<number|Long>|null} [artifactIds] PutArtifactsResponse artifactIds
         */

        /**
         * Constructs a new PutArtifactsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutArtifactsResponse.
         * @implements IPutArtifactsResponse
         * @constructor
         * @param {ml_metadata.IPutArtifactsResponse=} [properties] Properties to set
         */
        function PutArtifactsResponse(properties) {
            this.artifactIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutArtifactsResponse artifactIds.
         * @member {Array.<number|Long>} artifactIds
         * @memberof ml_metadata.PutArtifactsResponse
         * @instance
         */
        PutArtifactsResponse.prototype.artifactIds = $util.emptyArray;

        /**
         * Creates a new PutArtifactsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutArtifactsResponse
         * @static
         * @param {ml_metadata.IPutArtifactsResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutArtifactsResponse} PutArtifactsResponse instance
         */
        PutArtifactsResponse.create = function create(properties) {
            return new PutArtifactsResponse(properties);
        };

        /**
         * Encodes the specified PutArtifactsResponse message. Does not implicitly {@link ml_metadata.PutArtifactsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutArtifactsResponse
         * @static
         * @param {ml_metadata.IPutArtifactsResponse} message PutArtifactsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutArtifactsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactIds != null && message.artifactIds.length)
                for (var i = 0; i < message.artifactIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.artifactIds[i]);
            return writer;
        };

        /**
         * Encodes the specified PutArtifactsResponse message, length delimited. Does not implicitly {@link ml_metadata.PutArtifactsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutArtifactsResponse
         * @static
         * @param {ml_metadata.IPutArtifactsResponse} message PutArtifactsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutArtifactsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutArtifactsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutArtifactsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutArtifactsResponse} PutArtifactsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutArtifactsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutArtifactsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifactIds && message.artifactIds.length))
                        message.artifactIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.artifactIds.push(reader.int64());
                    } else
                        message.artifactIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutArtifactsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutArtifactsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutArtifactsResponse} PutArtifactsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutArtifactsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutArtifactsResponse message.
         * @function verify
         * @memberof ml_metadata.PutArtifactsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutArtifactsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactIds != null && message.hasOwnProperty("artifactIds")) {
                if (!Array.isArray(message.artifactIds))
                    return "artifactIds: array expected";
                for (var i = 0; i < message.artifactIds.length; ++i)
                    if (!$util.isInteger(message.artifactIds[i]) && !(message.artifactIds[i] && $util.isInteger(message.artifactIds[i].low) && $util.isInteger(message.artifactIds[i].high)))
                        return "artifactIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a PutArtifactsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutArtifactsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutArtifactsResponse} PutArtifactsResponse
         */
        PutArtifactsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutArtifactsResponse)
                return object;
            var message = new $root.ml_metadata.PutArtifactsResponse();
            if (object.artifactIds) {
                if (!Array.isArray(object.artifactIds))
                    throw TypeError(".ml_metadata.PutArtifactsResponse.artifactIds: array expected");
                message.artifactIds = [];
                for (var i = 0; i < object.artifactIds.length; ++i)
                    if ($util.Long)
                        (message.artifactIds[i] = $util.Long.fromValue(object.artifactIds[i])).unsigned = false;
                    else if (typeof object.artifactIds[i] === "string")
                        message.artifactIds[i] = parseInt(object.artifactIds[i], 10);
                    else if (typeof object.artifactIds[i] === "number")
                        message.artifactIds[i] = object.artifactIds[i];
                    else if (typeof object.artifactIds[i] === "object")
                        message.artifactIds[i] = new $util.LongBits(object.artifactIds[i].low >>> 0, object.artifactIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a PutArtifactsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutArtifactsResponse
         * @static
         * @param {ml_metadata.PutArtifactsResponse} message PutArtifactsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutArtifactsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifactIds = [];
            if (message.artifactIds && message.artifactIds.length) {
                object.artifactIds = [];
                for (var j = 0; j < message.artifactIds.length; ++j)
                    if (typeof message.artifactIds[j] === "number")
                        object.artifactIds[j] = options.longs === String ? String(message.artifactIds[j]) : message.artifactIds[j];
                    else
                        object.artifactIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.artifactIds[j]) : options.longs === Number ? new $util.LongBits(message.artifactIds[j].low >>> 0, message.artifactIds[j].high >>> 0).toNumber() : message.artifactIds[j];
            }
            return object;
        };

        /**
         * Converts this PutArtifactsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutArtifactsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutArtifactsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutArtifactsResponse;
    })();

    ml_metadata.PutArtifactTypeRequest = (function() {

        /**
         * Properties of a PutArtifactTypeRequest.
         * @memberof ml_metadata
         * @interface IPutArtifactTypeRequest
         * @property {ml_metadata.IArtifactType|null} [artifactType] PutArtifactTypeRequest artifactType
         * @property {boolean|null} [canAddFields] PutArtifactTypeRequest canAddFields
         * @property {boolean|null} [canOmitFields] PutArtifactTypeRequest canOmitFields
         * @property {boolean|null} [canDeleteFields] PutArtifactTypeRequest canDeleteFields
         * @property {boolean|null} [allFieldsMatch] PutArtifactTypeRequest allFieldsMatch
         */

        /**
         * Constructs a new PutArtifactTypeRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutArtifactTypeRequest.
         * @implements IPutArtifactTypeRequest
         * @constructor
         * @param {ml_metadata.IPutArtifactTypeRequest=} [properties] Properties to set
         */
        function PutArtifactTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutArtifactTypeRequest artifactType.
         * @member {ml_metadata.IArtifactType|null|undefined} artifactType
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @instance
         */
        PutArtifactTypeRequest.prototype.artifactType = null;

        /**
         * PutArtifactTypeRequest canAddFields.
         * @member {boolean} canAddFields
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @instance
         */
        PutArtifactTypeRequest.prototype.canAddFields = false;

        /**
         * PutArtifactTypeRequest canOmitFields.
         * @member {boolean} canOmitFields
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @instance
         */
        PutArtifactTypeRequest.prototype.canOmitFields = false;

        /**
         * PutArtifactTypeRequest canDeleteFields.
         * @member {boolean} canDeleteFields
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @instance
         */
        PutArtifactTypeRequest.prototype.canDeleteFields = false;

        /**
         * PutArtifactTypeRequest allFieldsMatch.
         * @member {boolean} allFieldsMatch
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @instance
         */
        PutArtifactTypeRequest.prototype.allFieldsMatch = true;

        /**
         * Creates a new PutArtifactTypeRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @static
         * @param {ml_metadata.IPutArtifactTypeRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutArtifactTypeRequest} PutArtifactTypeRequest instance
         */
        PutArtifactTypeRequest.create = function create(properties) {
            return new PutArtifactTypeRequest(properties);
        };

        /**
         * Encodes the specified PutArtifactTypeRequest message. Does not implicitly {@link ml_metadata.PutArtifactTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @static
         * @param {ml_metadata.IPutArtifactTypeRequest} message PutArtifactTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutArtifactTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactType != null && Object.hasOwnProperty.call(message, "artifactType"))
                $root.ml_metadata.ArtifactType.encode(message.artifactType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.canAddFields != null && Object.hasOwnProperty.call(message, "canAddFields"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.canAddFields);
            if (message.canDeleteFields != null && Object.hasOwnProperty.call(message, "canDeleteFields"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.canDeleteFields);
            if (message.allFieldsMatch != null && Object.hasOwnProperty.call(message, "allFieldsMatch"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.allFieldsMatch);
            if (message.canOmitFields != null && Object.hasOwnProperty.call(message, "canOmitFields"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.canOmitFields);
            return writer;
        };

        /**
         * Encodes the specified PutArtifactTypeRequest message, length delimited. Does not implicitly {@link ml_metadata.PutArtifactTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @static
         * @param {ml_metadata.IPutArtifactTypeRequest} message PutArtifactTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutArtifactTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutArtifactTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutArtifactTypeRequest} PutArtifactTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutArtifactTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutArtifactTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.artifactType = $root.ml_metadata.ArtifactType.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.canAddFields = reader.bool();
                    break;
                case 5:
                    message.canOmitFields = reader.bool();
                    break;
                case 3:
                    message.canDeleteFields = reader.bool();
                    break;
                case 4:
                    message.allFieldsMatch = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutArtifactTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutArtifactTypeRequest} PutArtifactTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutArtifactTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutArtifactTypeRequest message.
         * @function verify
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutArtifactTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactType != null && message.hasOwnProperty("artifactType")) {
                var error = $root.ml_metadata.ArtifactType.verify(message.artifactType);
                if (error)
                    return "artifactType." + error;
            }
            if (message.canAddFields != null && message.hasOwnProperty("canAddFields"))
                if (typeof message.canAddFields !== "boolean")
                    return "canAddFields: boolean expected";
            if (message.canOmitFields != null && message.hasOwnProperty("canOmitFields"))
                if (typeof message.canOmitFields !== "boolean")
                    return "canOmitFields: boolean expected";
            if (message.canDeleteFields != null && message.hasOwnProperty("canDeleteFields"))
                if (typeof message.canDeleteFields !== "boolean")
                    return "canDeleteFields: boolean expected";
            if (message.allFieldsMatch != null && message.hasOwnProperty("allFieldsMatch"))
                if (typeof message.allFieldsMatch !== "boolean")
                    return "allFieldsMatch: boolean expected";
            return null;
        };

        /**
         * Creates a PutArtifactTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutArtifactTypeRequest} PutArtifactTypeRequest
         */
        PutArtifactTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutArtifactTypeRequest)
                return object;
            var message = new $root.ml_metadata.PutArtifactTypeRequest();
            if (object.artifactType != null) {
                if (typeof object.artifactType !== "object")
                    throw TypeError(".ml_metadata.PutArtifactTypeRequest.artifactType: object expected");
                message.artifactType = $root.ml_metadata.ArtifactType.fromObject(object.artifactType);
            }
            if (object.canAddFields != null)
                message.canAddFields = Boolean(object.canAddFields);
            if (object.canOmitFields != null)
                message.canOmitFields = Boolean(object.canOmitFields);
            if (object.canDeleteFields != null)
                message.canDeleteFields = Boolean(object.canDeleteFields);
            if (object.allFieldsMatch != null)
                message.allFieldsMatch = Boolean(object.allFieldsMatch);
            return message;
        };

        /**
         * Creates a plain object from a PutArtifactTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @static
         * @param {ml_metadata.PutArtifactTypeRequest} message PutArtifactTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutArtifactTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.artifactType = null;
                object.canAddFields = false;
                object.canDeleteFields = false;
                object.allFieldsMatch = true;
                object.canOmitFields = false;
            }
            if (message.artifactType != null && message.hasOwnProperty("artifactType"))
                object.artifactType = $root.ml_metadata.ArtifactType.toObject(message.artifactType, options);
            if (message.canAddFields != null && message.hasOwnProperty("canAddFields"))
                object.canAddFields = message.canAddFields;
            if (message.canDeleteFields != null && message.hasOwnProperty("canDeleteFields"))
                object.canDeleteFields = message.canDeleteFields;
            if (message.allFieldsMatch != null && message.hasOwnProperty("allFieldsMatch"))
                object.allFieldsMatch = message.allFieldsMatch;
            if (message.canOmitFields != null && message.hasOwnProperty("canOmitFields"))
                object.canOmitFields = message.canOmitFields;
            return object;
        };

        /**
         * Converts this PutArtifactTypeRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutArtifactTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutArtifactTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutArtifactTypeRequest;
    })();

    ml_metadata.PutArtifactTypeResponse = (function() {

        /**
         * Properties of a PutArtifactTypeResponse.
         * @memberof ml_metadata
         * @interface IPutArtifactTypeResponse
         * @property {number|Long|null} [typeId] PutArtifactTypeResponse typeId
         */

        /**
         * Constructs a new PutArtifactTypeResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutArtifactTypeResponse.
         * @implements IPutArtifactTypeResponse
         * @constructor
         * @param {ml_metadata.IPutArtifactTypeResponse=} [properties] Properties to set
         */
        function PutArtifactTypeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutArtifactTypeResponse typeId.
         * @member {number|Long} typeId
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @instance
         */
        PutArtifactTypeResponse.prototype.typeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PutArtifactTypeResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @static
         * @param {ml_metadata.IPutArtifactTypeResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutArtifactTypeResponse} PutArtifactTypeResponse instance
         */
        PutArtifactTypeResponse.create = function create(properties) {
            return new PutArtifactTypeResponse(properties);
        };

        /**
         * Encodes the specified PutArtifactTypeResponse message. Does not implicitly {@link ml_metadata.PutArtifactTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @static
         * @param {ml_metadata.IPutArtifactTypeResponse} message PutArtifactTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutArtifactTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeId != null && Object.hasOwnProperty.call(message, "typeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.typeId);
            return writer;
        };

        /**
         * Encodes the specified PutArtifactTypeResponse message, length delimited. Does not implicitly {@link ml_metadata.PutArtifactTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @static
         * @param {ml_metadata.IPutArtifactTypeResponse} message PutArtifactTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutArtifactTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutArtifactTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutArtifactTypeResponse} PutArtifactTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutArtifactTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutArtifactTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutArtifactTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutArtifactTypeResponse} PutArtifactTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutArtifactTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutArtifactTypeResponse message.
         * @function verify
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutArtifactTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (!$util.isInteger(message.typeId) && !(message.typeId && $util.isInteger(message.typeId.low) && $util.isInteger(message.typeId.high)))
                    return "typeId: integer|Long expected";
            return null;
        };

        /**
         * Creates a PutArtifactTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutArtifactTypeResponse} PutArtifactTypeResponse
         */
        PutArtifactTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutArtifactTypeResponse)
                return object;
            var message = new $root.ml_metadata.PutArtifactTypeResponse();
            if (object.typeId != null)
                if ($util.Long)
                    (message.typeId = $util.Long.fromValue(object.typeId)).unsigned = false;
                else if (typeof object.typeId === "string")
                    message.typeId = parseInt(object.typeId, 10);
                else if (typeof object.typeId === "number")
                    message.typeId = object.typeId;
                else if (typeof object.typeId === "object")
                    message.typeId = new $util.LongBits(object.typeId.low >>> 0, object.typeId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PutArtifactTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @static
         * @param {ml_metadata.PutArtifactTypeResponse} message PutArtifactTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutArtifactTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.typeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.typeId = options.longs === String ? "0" : 0;
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (typeof message.typeId === "number")
                    object.typeId = options.longs === String ? String(message.typeId) : message.typeId;
                else
                    object.typeId = options.longs === String ? $util.Long.prototype.toString.call(message.typeId) : options.longs === Number ? new $util.LongBits(message.typeId.low >>> 0, message.typeId.high >>> 0).toNumber() : message.typeId;
            return object;
        };

        /**
         * Converts this PutArtifactTypeResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutArtifactTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutArtifactTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutArtifactTypeResponse;
    })();

    ml_metadata.PutExecutionsRequest = (function() {

        /**
         * Properties of a PutExecutionsRequest.
         * @memberof ml_metadata
         * @interface IPutExecutionsRequest
         * @property {Array.<ml_metadata.IExecution>|null} [executions] PutExecutionsRequest executions
         */

        /**
         * Constructs a new PutExecutionsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutExecutionsRequest.
         * @implements IPutExecutionsRequest
         * @constructor
         * @param {ml_metadata.IPutExecutionsRequest=} [properties] Properties to set
         */
        function PutExecutionsRequest(properties) {
            this.executions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutExecutionsRequest executions.
         * @member {Array.<ml_metadata.IExecution>} executions
         * @memberof ml_metadata.PutExecutionsRequest
         * @instance
         */
        PutExecutionsRequest.prototype.executions = $util.emptyArray;

        /**
         * Creates a new PutExecutionsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutExecutionsRequest
         * @static
         * @param {ml_metadata.IPutExecutionsRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutExecutionsRequest} PutExecutionsRequest instance
         */
        PutExecutionsRequest.create = function create(properties) {
            return new PutExecutionsRequest(properties);
        };

        /**
         * Encodes the specified PutExecutionsRequest message. Does not implicitly {@link ml_metadata.PutExecutionsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutExecutionsRequest
         * @static
         * @param {ml_metadata.IPutExecutionsRequest} message PutExecutionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executions != null && message.executions.length)
                for (var i = 0; i < message.executions.length; ++i)
                    $root.ml_metadata.Execution.encode(message.executions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PutExecutionsRequest message, length delimited. Does not implicitly {@link ml_metadata.PutExecutionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutExecutionsRequest
         * @static
         * @param {ml_metadata.IPutExecutionsRequest} message PutExecutionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutExecutionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutExecutionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutExecutionsRequest} PutExecutionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutExecutionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executions && message.executions.length))
                        message.executions = [];
                    message.executions.push($root.ml_metadata.Execution.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutExecutionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutExecutionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutExecutionsRequest} PutExecutionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutExecutionsRequest message.
         * @function verify
         * @memberof ml_metadata.PutExecutionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutExecutionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executions != null && message.hasOwnProperty("executions")) {
                if (!Array.isArray(message.executions))
                    return "executions: array expected";
                for (var i = 0; i < message.executions.length; ++i) {
                    var error = $root.ml_metadata.Execution.verify(message.executions[i]);
                    if (error)
                        return "executions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PutExecutionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutExecutionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutExecutionsRequest} PutExecutionsRequest
         */
        PutExecutionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutExecutionsRequest)
                return object;
            var message = new $root.ml_metadata.PutExecutionsRequest();
            if (object.executions) {
                if (!Array.isArray(object.executions))
                    throw TypeError(".ml_metadata.PutExecutionsRequest.executions: array expected");
                message.executions = [];
                for (var i = 0; i < object.executions.length; ++i) {
                    if (typeof object.executions[i] !== "object")
                        throw TypeError(".ml_metadata.PutExecutionsRequest.executions: object expected");
                    message.executions[i] = $root.ml_metadata.Execution.fromObject(object.executions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PutExecutionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutExecutionsRequest
         * @static
         * @param {ml_metadata.PutExecutionsRequest} message PutExecutionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutExecutionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executions = [];
            if (message.executions && message.executions.length) {
                object.executions = [];
                for (var j = 0; j < message.executions.length; ++j)
                    object.executions[j] = $root.ml_metadata.Execution.toObject(message.executions[j], options);
            }
            return object;
        };

        /**
         * Converts this PutExecutionsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutExecutionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutExecutionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutExecutionsRequest;
    })();

    ml_metadata.PutExecutionsResponse = (function() {

        /**
         * Properties of a PutExecutionsResponse.
         * @memberof ml_metadata
         * @interface IPutExecutionsResponse
         * @property {Array.<number|Long>|null} [executionIds] PutExecutionsResponse executionIds
         */

        /**
         * Constructs a new PutExecutionsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutExecutionsResponse.
         * @implements IPutExecutionsResponse
         * @constructor
         * @param {ml_metadata.IPutExecutionsResponse=} [properties] Properties to set
         */
        function PutExecutionsResponse(properties) {
            this.executionIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutExecutionsResponse executionIds.
         * @member {Array.<number|Long>} executionIds
         * @memberof ml_metadata.PutExecutionsResponse
         * @instance
         */
        PutExecutionsResponse.prototype.executionIds = $util.emptyArray;

        /**
         * Creates a new PutExecutionsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutExecutionsResponse
         * @static
         * @param {ml_metadata.IPutExecutionsResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutExecutionsResponse} PutExecutionsResponse instance
         */
        PutExecutionsResponse.create = function create(properties) {
            return new PutExecutionsResponse(properties);
        };

        /**
         * Encodes the specified PutExecutionsResponse message. Does not implicitly {@link ml_metadata.PutExecutionsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutExecutionsResponse
         * @static
         * @param {ml_metadata.IPutExecutionsResponse} message PutExecutionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionIds != null && message.executionIds.length)
                for (var i = 0; i < message.executionIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.executionIds[i]);
            return writer;
        };

        /**
         * Encodes the specified PutExecutionsResponse message, length delimited. Does not implicitly {@link ml_metadata.PutExecutionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutExecutionsResponse
         * @static
         * @param {ml_metadata.IPutExecutionsResponse} message PutExecutionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutExecutionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutExecutionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutExecutionsResponse} PutExecutionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutExecutionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executionIds && message.executionIds.length))
                        message.executionIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.executionIds.push(reader.int64());
                    } else
                        message.executionIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutExecutionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutExecutionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutExecutionsResponse} PutExecutionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutExecutionsResponse message.
         * @function verify
         * @memberof ml_metadata.PutExecutionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutExecutionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionIds != null && message.hasOwnProperty("executionIds")) {
                if (!Array.isArray(message.executionIds))
                    return "executionIds: array expected";
                for (var i = 0; i < message.executionIds.length; ++i)
                    if (!$util.isInteger(message.executionIds[i]) && !(message.executionIds[i] && $util.isInteger(message.executionIds[i].low) && $util.isInteger(message.executionIds[i].high)))
                        return "executionIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a PutExecutionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutExecutionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutExecutionsResponse} PutExecutionsResponse
         */
        PutExecutionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutExecutionsResponse)
                return object;
            var message = new $root.ml_metadata.PutExecutionsResponse();
            if (object.executionIds) {
                if (!Array.isArray(object.executionIds))
                    throw TypeError(".ml_metadata.PutExecutionsResponse.executionIds: array expected");
                message.executionIds = [];
                for (var i = 0; i < object.executionIds.length; ++i)
                    if ($util.Long)
                        (message.executionIds[i] = $util.Long.fromValue(object.executionIds[i])).unsigned = false;
                    else if (typeof object.executionIds[i] === "string")
                        message.executionIds[i] = parseInt(object.executionIds[i], 10);
                    else if (typeof object.executionIds[i] === "number")
                        message.executionIds[i] = object.executionIds[i];
                    else if (typeof object.executionIds[i] === "object")
                        message.executionIds[i] = new $util.LongBits(object.executionIds[i].low >>> 0, object.executionIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a PutExecutionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutExecutionsResponse
         * @static
         * @param {ml_metadata.PutExecutionsResponse} message PutExecutionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutExecutionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executionIds = [];
            if (message.executionIds && message.executionIds.length) {
                object.executionIds = [];
                for (var j = 0; j < message.executionIds.length; ++j)
                    if (typeof message.executionIds[j] === "number")
                        object.executionIds[j] = options.longs === String ? String(message.executionIds[j]) : message.executionIds[j];
                    else
                        object.executionIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.executionIds[j]) : options.longs === Number ? new $util.LongBits(message.executionIds[j].low >>> 0, message.executionIds[j].high >>> 0).toNumber() : message.executionIds[j];
            }
            return object;
        };

        /**
         * Converts this PutExecutionsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutExecutionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutExecutionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutExecutionsResponse;
    })();

    ml_metadata.PutExecutionTypeRequest = (function() {

        /**
         * Properties of a PutExecutionTypeRequest.
         * @memberof ml_metadata
         * @interface IPutExecutionTypeRequest
         * @property {ml_metadata.IExecutionType|null} [executionType] PutExecutionTypeRequest executionType
         * @property {boolean|null} [canAddFields] PutExecutionTypeRequest canAddFields
         * @property {boolean|null} [canOmitFields] PutExecutionTypeRequest canOmitFields
         * @property {boolean|null} [canDeleteFields] PutExecutionTypeRequest canDeleteFields
         * @property {boolean|null} [allFieldsMatch] PutExecutionTypeRequest allFieldsMatch
         */

        /**
         * Constructs a new PutExecutionTypeRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutExecutionTypeRequest.
         * @implements IPutExecutionTypeRequest
         * @constructor
         * @param {ml_metadata.IPutExecutionTypeRequest=} [properties] Properties to set
         */
        function PutExecutionTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutExecutionTypeRequest executionType.
         * @member {ml_metadata.IExecutionType|null|undefined} executionType
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @instance
         */
        PutExecutionTypeRequest.prototype.executionType = null;

        /**
         * PutExecutionTypeRequest canAddFields.
         * @member {boolean} canAddFields
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @instance
         */
        PutExecutionTypeRequest.prototype.canAddFields = false;

        /**
         * PutExecutionTypeRequest canOmitFields.
         * @member {boolean} canOmitFields
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @instance
         */
        PutExecutionTypeRequest.prototype.canOmitFields = false;

        /**
         * PutExecutionTypeRequest canDeleteFields.
         * @member {boolean} canDeleteFields
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @instance
         */
        PutExecutionTypeRequest.prototype.canDeleteFields = false;

        /**
         * PutExecutionTypeRequest allFieldsMatch.
         * @member {boolean} allFieldsMatch
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @instance
         */
        PutExecutionTypeRequest.prototype.allFieldsMatch = true;

        /**
         * Creates a new PutExecutionTypeRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @static
         * @param {ml_metadata.IPutExecutionTypeRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutExecutionTypeRequest} PutExecutionTypeRequest instance
         */
        PutExecutionTypeRequest.create = function create(properties) {
            return new PutExecutionTypeRequest(properties);
        };

        /**
         * Encodes the specified PutExecutionTypeRequest message. Does not implicitly {@link ml_metadata.PutExecutionTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @static
         * @param {ml_metadata.IPutExecutionTypeRequest} message PutExecutionTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionType != null && Object.hasOwnProperty.call(message, "executionType"))
                $root.ml_metadata.ExecutionType.encode(message.executionType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.canAddFields != null && Object.hasOwnProperty.call(message, "canAddFields"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.canAddFields);
            if (message.canDeleteFields != null && Object.hasOwnProperty.call(message, "canDeleteFields"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.canDeleteFields);
            if (message.allFieldsMatch != null && Object.hasOwnProperty.call(message, "allFieldsMatch"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.allFieldsMatch);
            if (message.canOmitFields != null && Object.hasOwnProperty.call(message, "canOmitFields"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.canOmitFields);
            return writer;
        };

        /**
         * Encodes the specified PutExecutionTypeRequest message, length delimited. Does not implicitly {@link ml_metadata.PutExecutionTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @static
         * @param {ml_metadata.IPutExecutionTypeRequest} message PutExecutionTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutExecutionTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutExecutionTypeRequest} PutExecutionTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutExecutionTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.executionType = $root.ml_metadata.ExecutionType.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.canAddFields = reader.bool();
                    break;
                case 5:
                    message.canOmitFields = reader.bool();
                    break;
                case 3:
                    message.canDeleteFields = reader.bool();
                    break;
                case 4:
                    message.allFieldsMatch = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutExecutionTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutExecutionTypeRequest} PutExecutionTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutExecutionTypeRequest message.
         * @function verify
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutExecutionTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionType != null && message.hasOwnProperty("executionType")) {
                var error = $root.ml_metadata.ExecutionType.verify(message.executionType);
                if (error)
                    return "executionType." + error;
            }
            if (message.canAddFields != null && message.hasOwnProperty("canAddFields"))
                if (typeof message.canAddFields !== "boolean")
                    return "canAddFields: boolean expected";
            if (message.canOmitFields != null && message.hasOwnProperty("canOmitFields"))
                if (typeof message.canOmitFields !== "boolean")
                    return "canOmitFields: boolean expected";
            if (message.canDeleteFields != null && message.hasOwnProperty("canDeleteFields"))
                if (typeof message.canDeleteFields !== "boolean")
                    return "canDeleteFields: boolean expected";
            if (message.allFieldsMatch != null && message.hasOwnProperty("allFieldsMatch"))
                if (typeof message.allFieldsMatch !== "boolean")
                    return "allFieldsMatch: boolean expected";
            return null;
        };

        /**
         * Creates a PutExecutionTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutExecutionTypeRequest} PutExecutionTypeRequest
         */
        PutExecutionTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutExecutionTypeRequest)
                return object;
            var message = new $root.ml_metadata.PutExecutionTypeRequest();
            if (object.executionType != null) {
                if (typeof object.executionType !== "object")
                    throw TypeError(".ml_metadata.PutExecutionTypeRequest.executionType: object expected");
                message.executionType = $root.ml_metadata.ExecutionType.fromObject(object.executionType);
            }
            if (object.canAddFields != null)
                message.canAddFields = Boolean(object.canAddFields);
            if (object.canOmitFields != null)
                message.canOmitFields = Boolean(object.canOmitFields);
            if (object.canDeleteFields != null)
                message.canDeleteFields = Boolean(object.canDeleteFields);
            if (object.allFieldsMatch != null)
                message.allFieldsMatch = Boolean(object.allFieldsMatch);
            return message;
        };

        /**
         * Creates a plain object from a PutExecutionTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @static
         * @param {ml_metadata.PutExecutionTypeRequest} message PutExecutionTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutExecutionTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.executionType = null;
                object.canAddFields = false;
                object.canDeleteFields = false;
                object.allFieldsMatch = true;
                object.canOmitFields = false;
            }
            if (message.executionType != null && message.hasOwnProperty("executionType"))
                object.executionType = $root.ml_metadata.ExecutionType.toObject(message.executionType, options);
            if (message.canAddFields != null && message.hasOwnProperty("canAddFields"))
                object.canAddFields = message.canAddFields;
            if (message.canDeleteFields != null && message.hasOwnProperty("canDeleteFields"))
                object.canDeleteFields = message.canDeleteFields;
            if (message.allFieldsMatch != null && message.hasOwnProperty("allFieldsMatch"))
                object.allFieldsMatch = message.allFieldsMatch;
            if (message.canOmitFields != null && message.hasOwnProperty("canOmitFields"))
                object.canOmitFields = message.canOmitFields;
            return object;
        };

        /**
         * Converts this PutExecutionTypeRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutExecutionTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutExecutionTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutExecutionTypeRequest;
    })();

    ml_metadata.PutExecutionTypeResponse = (function() {

        /**
         * Properties of a PutExecutionTypeResponse.
         * @memberof ml_metadata
         * @interface IPutExecutionTypeResponse
         * @property {number|Long|null} [typeId] PutExecutionTypeResponse typeId
         */

        /**
         * Constructs a new PutExecutionTypeResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutExecutionTypeResponse.
         * @implements IPutExecutionTypeResponse
         * @constructor
         * @param {ml_metadata.IPutExecutionTypeResponse=} [properties] Properties to set
         */
        function PutExecutionTypeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutExecutionTypeResponse typeId.
         * @member {number|Long} typeId
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @instance
         */
        PutExecutionTypeResponse.prototype.typeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PutExecutionTypeResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @static
         * @param {ml_metadata.IPutExecutionTypeResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutExecutionTypeResponse} PutExecutionTypeResponse instance
         */
        PutExecutionTypeResponse.create = function create(properties) {
            return new PutExecutionTypeResponse(properties);
        };

        /**
         * Encodes the specified PutExecutionTypeResponse message. Does not implicitly {@link ml_metadata.PutExecutionTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @static
         * @param {ml_metadata.IPutExecutionTypeResponse} message PutExecutionTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeId != null && Object.hasOwnProperty.call(message, "typeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.typeId);
            return writer;
        };

        /**
         * Encodes the specified PutExecutionTypeResponse message, length delimited. Does not implicitly {@link ml_metadata.PutExecutionTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @static
         * @param {ml_metadata.IPutExecutionTypeResponse} message PutExecutionTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutExecutionTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutExecutionTypeResponse} PutExecutionTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutExecutionTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutExecutionTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutExecutionTypeResponse} PutExecutionTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutExecutionTypeResponse message.
         * @function verify
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutExecutionTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (!$util.isInteger(message.typeId) && !(message.typeId && $util.isInteger(message.typeId.low) && $util.isInteger(message.typeId.high)))
                    return "typeId: integer|Long expected";
            return null;
        };

        /**
         * Creates a PutExecutionTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutExecutionTypeResponse} PutExecutionTypeResponse
         */
        PutExecutionTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutExecutionTypeResponse)
                return object;
            var message = new $root.ml_metadata.PutExecutionTypeResponse();
            if (object.typeId != null)
                if ($util.Long)
                    (message.typeId = $util.Long.fromValue(object.typeId)).unsigned = false;
                else if (typeof object.typeId === "string")
                    message.typeId = parseInt(object.typeId, 10);
                else if (typeof object.typeId === "number")
                    message.typeId = object.typeId;
                else if (typeof object.typeId === "object")
                    message.typeId = new $util.LongBits(object.typeId.low >>> 0, object.typeId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PutExecutionTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @static
         * @param {ml_metadata.PutExecutionTypeResponse} message PutExecutionTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutExecutionTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.typeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.typeId = options.longs === String ? "0" : 0;
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (typeof message.typeId === "number")
                    object.typeId = options.longs === String ? String(message.typeId) : message.typeId;
                else
                    object.typeId = options.longs === String ? $util.Long.prototype.toString.call(message.typeId) : options.longs === Number ? new $util.LongBits(message.typeId.low >>> 0, message.typeId.high >>> 0).toNumber() : message.typeId;
            return object;
        };

        /**
         * Converts this PutExecutionTypeResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutExecutionTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutExecutionTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutExecutionTypeResponse;
    })();

    ml_metadata.PutEventsRequest = (function() {

        /**
         * Properties of a PutEventsRequest.
         * @memberof ml_metadata
         * @interface IPutEventsRequest
         * @property {Array.<ml_metadata.IEvent>|null} [events] PutEventsRequest events
         */

        /**
         * Constructs a new PutEventsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutEventsRequest.
         * @implements IPutEventsRequest
         * @constructor
         * @param {ml_metadata.IPutEventsRequest=} [properties] Properties to set
         */
        function PutEventsRequest(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutEventsRequest events.
         * @member {Array.<ml_metadata.IEvent>} events
         * @memberof ml_metadata.PutEventsRequest
         * @instance
         */
        PutEventsRequest.prototype.events = $util.emptyArray;

        /**
         * Creates a new PutEventsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutEventsRequest
         * @static
         * @param {ml_metadata.IPutEventsRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutEventsRequest} PutEventsRequest instance
         */
        PutEventsRequest.create = function create(properties) {
            return new PutEventsRequest(properties);
        };

        /**
         * Encodes the specified PutEventsRequest message. Does not implicitly {@link ml_metadata.PutEventsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutEventsRequest
         * @static
         * @param {ml_metadata.IPutEventsRequest} message PutEventsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutEventsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.ml_metadata.Event.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PutEventsRequest message, length delimited. Does not implicitly {@link ml_metadata.PutEventsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutEventsRequest
         * @static
         * @param {ml_metadata.IPutEventsRequest} message PutEventsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutEventsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutEventsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutEventsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutEventsRequest} PutEventsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutEventsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutEventsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.ml_metadata.Event.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutEventsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutEventsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutEventsRequest} PutEventsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutEventsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutEventsRequest message.
         * @function verify
         * @memberof ml_metadata.PutEventsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutEventsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.ml_metadata.Event.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PutEventsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutEventsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutEventsRequest} PutEventsRequest
         */
        PutEventsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutEventsRequest)
                return object;
            var message = new $root.ml_metadata.PutEventsRequest();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".ml_metadata.PutEventsRequest.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".ml_metadata.PutEventsRequest.events: object expected");
                    message.events[i] = $root.ml_metadata.Event.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PutEventsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutEventsRequest
         * @static
         * @param {ml_metadata.PutEventsRequest} message PutEventsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutEventsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.ml_metadata.Event.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this PutEventsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutEventsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutEventsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutEventsRequest;
    })();

    ml_metadata.PutEventsResponse = (function() {

        /**
         * Properties of a PutEventsResponse.
         * @memberof ml_metadata
         * @interface IPutEventsResponse
         */

        /**
         * Constructs a new PutEventsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutEventsResponse.
         * @implements IPutEventsResponse
         * @constructor
         * @param {ml_metadata.IPutEventsResponse=} [properties] Properties to set
         */
        function PutEventsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PutEventsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutEventsResponse
         * @static
         * @param {ml_metadata.IPutEventsResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutEventsResponse} PutEventsResponse instance
         */
        PutEventsResponse.create = function create(properties) {
            return new PutEventsResponse(properties);
        };

        /**
         * Encodes the specified PutEventsResponse message. Does not implicitly {@link ml_metadata.PutEventsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutEventsResponse
         * @static
         * @param {ml_metadata.IPutEventsResponse} message PutEventsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutEventsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PutEventsResponse message, length delimited. Does not implicitly {@link ml_metadata.PutEventsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutEventsResponse
         * @static
         * @param {ml_metadata.IPutEventsResponse} message PutEventsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutEventsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutEventsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutEventsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutEventsResponse} PutEventsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutEventsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutEventsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutEventsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutEventsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutEventsResponse} PutEventsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutEventsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutEventsResponse message.
         * @function verify
         * @memberof ml_metadata.PutEventsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutEventsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PutEventsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutEventsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutEventsResponse} PutEventsResponse
         */
        PutEventsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutEventsResponse)
                return object;
            return new $root.ml_metadata.PutEventsResponse();
        };

        /**
         * Creates a plain object from a PutEventsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutEventsResponse
         * @static
         * @param {ml_metadata.PutEventsResponse} message PutEventsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutEventsResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PutEventsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutEventsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutEventsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutEventsResponse;
    })();

    ml_metadata.PutExecutionRequest = (function() {

        /**
         * Properties of a PutExecutionRequest.
         * @memberof ml_metadata
         * @interface IPutExecutionRequest
         * @property {ml_metadata.IExecution|null} [execution] PutExecutionRequest execution
         * @property {Array.<ml_metadata.PutExecutionRequest.IArtifactAndEvent>|null} [artifactEventPairs] PutExecutionRequest artifactEventPairs
         * @property {Array.<ml_metadata.IContext>|null} [contexts] PutExecutionRequest contexts
         * @property {ml_metadata.PutExecutionRequest.IOptions|null} [options] PutExecutionRequest options
         */

        /**
         * Constructs a new PutExecutionRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutExecutionRequest.
         * @implements IPutExecutionRequest
         * @constructor
         * @param {ml_metadata.IPutExecutionRequest=} [properties] Properties to set
         */
        function PutExecutionRequest(properties) {
            this.artifactEventPairs = [];
            this.contexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutExecutionRequest execution.
         * @member {ml_metadata.IExecution|null|undefined} execution
         * @memberof ml_metadata.PutExecutionRequest
         * @instance
         */
        PutExecutionRequest.prototype.execution = null;

        /**
         * PutExecutionRequest artifactEventPairs.
         * @member {Array.<ml_metadata.PutExecutionRequest.IArtifactAndEvent>} artifactEventPairs
         * @memberof ml_metadata.PutExecutionRequest
         * @instance
         */
        PutExecutionRequest.prototype.artifactEventPairs = $util.emptyArray;

        /**
         * PutExecutionRequest contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.PutExecutionRequest
         * @instance
         */
        PutExecutionRequest.prototype.contexts = $util.emptyArray;

        /**
         * PutExecutionRequest options.
         * @member {ml_metadata.PutExecutionRequest.IOptions|null|undefined} options
         * @memberof ml_metadata.PutExecutionRequest
         * @instance
         */
        PutExecutionRequest.prototype.options = null;

        /**
         * Creates a new PutExecutionRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutExecutionRequest
         * @static
         * @param {ml_metadata.IPutExecutionRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutExecutionRequest} PutExecutionRequest instance
         */
        PutExecutionRequest.create = function create(properties) {
            return new PutExecutionRequest(properties);
        };

        /**
         * Encodes the specified PutExecutionRequest message. Does not implicitly {@link ml_metadata.PutExecutionRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutExecutionRequest
         * @static
         * @param {ml_metadata.IPutExecutionRequest} message PutExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.execution != null && Object.hasOwnProperty.call(message, "execution"))
                $root.ml_metadata.Execution.encode(message.execution, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.artifactEventPairs != null && message.artifactEventPairs.length)
                for (var i = 0; i < message.artifactEventPairs.length; ++i)
                    $root.ml_metadata.PutExecutionRequest.ArtifactAndEvent.encode(message.artifactEventPairs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.ml_metadata.PutExecutionRequest.Options.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PutExecutionRequest message, length delimited. Does not implicitly {@link ml_metadata.PutExecutionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutExecutionRequest
         * @static
         * @param {ml_metadata.IPutExecutionRequest} message PutExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutExecutionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutExecutionRequest} PutExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutExecutionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.execution = $root.ml_metadata.Execution.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.artifactEventPairs && message.artifactEventPairs.length))
                        message.artifactEventPairs = [];
                    message.artifactEventPairs.push($root.ml_metadata.PutExecutionRequest.ArtifactAndEvent.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.options = $root.ml_metadata.PutExecutionRequest.Options.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutExecutionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutExecutionRequest} PutExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutExecutionRequest message.
         * @function verify
         * @memberof ml_metadata.PutExecutionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutExecutionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.execution != null && message.hasOwnProperty("execution")) {
                var error = $root.ml_metadata.Execution.verify(message.execution);
                if (error)
                    return "execution." + error;
            }
            if (message.artifactEventPairs != null && message.hasOwnProperty("artifactEventPairs")) {
                if (!Array.isArray(message.artifactEventPairs))
                    return "artifactEventPairs: array expected";
                for (var i = 0; i < message.artifactEventPairs.length; ++i) {
                    var error = $root.ml_metadata.PutExecutionRequest.ArtifactAndEvent.verify(message.artifactEventPairs[i]);
                    if (error)
                        return "artifactEventPairs." + error;
                }
            }
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.ml_metadata.PutExecutionRequest.Options.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a PutExecutionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutExecutionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutExecutionRequest} PutExecutionRequest
         */
        PutExecutionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutExecutionRequest)
                return object;
            var message = new $root.ml_metadata.PutExecutionRequest();
            if (object.execution != null) {
                if (typeof object.execution !== "object")
                    throw TypeError(".ml_metadata.PutExecutionRequest.execution: object expected");
                message.execution = $root.ml_metadata.Execution.fromObject(object.execution);
            }
            if (object.artifactEventPairs) {
                if (!Array.isArray(object.artifactEventPairs))
                    throw TypeError(".ml_metadata.PutExecutionRequest.artifactEventPairs: array expected");
                message.artifactEventPairs = [];
                for (var i = 0; i < object.artifactEventPairs.length; ++i) {
                    if (typeof object.artifactEventPairs[i] !== "object")
                        throw TypeError(".ml_metadata.PutExecutionRequest.artifactEventPairs: object expected");
                    message.artifactEventPairs[i] = $root.ml_metadata.PutExecutionRequest.ArtifactAndEvent.fromObject(object.artifactEventPairs[i]);
                }
            }
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.PutExecutionRequest.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.PutExecutionRequest.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".ml_metadata.PutExecutionRequest.options: object expected");
                message.options = $root.ml_metadata.PutExecutionRequest.Options.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a PutExecutionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutExecutionRequest
         * @static
         * @param {ml_metadata.PutExecutionRequest} message PutExecutionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutExecutionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.artifactEventPairs = [];
                object.contexts = [];
            }
            if (options.defaults) {
                object.execution = null;
                object.options = null;
            }
            if (message.execution != null && message.hasOwnProperty("execution"))
                object.execution = $root.ml_metadata.Execution.toObject(message.execution, options);
            if (message.artifactEventPairs && message.artifactEventPairs.length) {
                object.artifactEventPairs = [];
                for (var j = 0; j < message.artifactEventPairs.length; ++j)
                    object.artifactEventPairs[j] = $root.ml_metadata.PutExecutionRequest.ArtifactAndEvent.toObject(message.artifactEventPairs[j], options);
            }
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.ml_metadata.PutExecutionRequest.Options.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this PutExecutionRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutExecutionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutExecutionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        PutExecutionRequest.ArtifactAndEvent = (function() {

            /**
             * Properties of an ArtifactAndEvent.
             * @memberof ml_metadata.PutExecutionRequest
             * @interface IArtifactAndEvent
             * @property {ml_metadata.IArtifact|null} [artifact] ArtifactAndEvent artifact
             * @property {ml_metadata.IEvent|null} [event] ArtifactAndEvent event
             */

            /**
             * Constructs a new ArtifactAndEvent.
             * @memberof ml_metadata.PutExecutionRequest
             * @classdesc Represents an ArtifactAndEvent.
             * @implements IArtifactAndEvent
             * @constructor
             * @param {ml_metadata.PutExecutionRequest.IArtifactAndEvent=} [properties] Properties to set
             */
            function ArtifactAndEvent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ArtifactAndEvent artifact.
             * @member {ml_metadata.IArtifact|null|undefined} artifact
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @instance
             */
            ArtifactAndEvent.prototype.artifact = null;

            /**
             * ArtifactAndEvent event.
             * @member {ml_metadata.IEvent|null|undefined} event
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @instance
             */
            ArtifactAndEvent.prototype.event = null;

            /**
             * Creates a new ArtifactAndEvent instance using the specified properties.
             * @function create
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @static
             * @param {ml_metadata.PutExecutionRequest.IArtifactAndEvent=} [properties] Properties to set
             * @returns {ml_metadata.PutExecutionRequest.ArtifactAndEvent} ArtifactAndEvent instance
             */
            ArtifactAndEvent.create = function create(properties) {
                return new ArtifactAndEvent(properties);
            };

            /**
             * Encodes the specified ArtifactAndEvent message. Does not implicitly {@link ml_metadata.PutExecutionRequest.ArtifactAndEvent.verify|verify} messages.
             * @function encode
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @static
             * @param {ml_metadata.PutExecutionRequest.IArtifactAndEvent} message ArtifactAndEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArtifactAndEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.artifact != null && Object.hasOwnProperty.call(message, "artifact"))
                    $root.ml_metadata.Artifact.encode(message.artifact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    $root.ml_metadata.Event.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ArtifactAndEvent message, length delimited. Does not implicitly {@link ml_metadata.PutExecutionRequest.ArtifactAndEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @static
             * @param {ml_metadata.PutExecutionRequest.IArtifactAndEvent} message ArtifactAndEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArtifactAndEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ArtifactAndEvent message from the specified reader or buffer.
             * @function decode
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ml_metadata.PutExecutionRequest.ArtifactAndEvent} ArtifactAndEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArtifactAndEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutExecutionRequest.ArtifactAndEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.artifact = $root.ml_metadata.Artifact.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.event = $root.ml_metadata.Event.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ArtifactAndEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ml_metadata.PutExecutionRequest.ArtifactAndEvent} ArtifactAndEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArtifactAndEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ArtifactAndEvent message.
             * @function verify
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ArtifactAndEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.artifact != null && message.hasOwnProperty("artifact")) {
                    var error = $root.ml_metadata.Artifact.verify(message.artifact);
                    if (error)
                        return "artifact." + error;
                }
                if (message.event != null && message.hasOwnProperty("event")) {
                    var error = $root.ml_metadata.Event.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };

            /**
             * Creates an ArtifactAndEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ml_metadata.PutExecutionRequest.ArtifactAndEvent} ArtifactAndEvent
             */
            ArtifactAndEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.ml_metadata.PutExecutionRequest.ArtifactAndEvent)
                    return object;
                var message = new $root.ml_metadata.PutExecutionRequest.ArtifactAndEvent();
                if (object.artifact != null) {
                    if (typeof object.artifact !== "object")
                        throw TypeError(".ml_metadata.PutExecutionRequest.ArtifactAndEvent.artifact: object expected");
                    message.artifact = $root.ml_metadata.Artifact.fromObject(object.artifact);
                }
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".ml_metadata.PutExecutionRequest.ArtifactAndEvent.event: object expected");
                    message.event = $root.ml_metadata.Event.fromObject(object.event);
                }
                return message;
            };

            /**
             * Creates a plain object from an ArtifactAndEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @static
             * @param {ml_metadata.PutExecutionRequest.ArtifactAndEvent} message ArtifactAndEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ArtifactAndEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.artifact = null;
                    object.event = null;
                }
                if (message.artifact != null && message.hasOwnProperty("artifact"))
                    object.artifact = $root.ml_metadata.Artifact.toObject(message.artifact, options);
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = $root.ml_metadata.Event.toObject(message.event, options);
                return object;
            };

            /**
             * Converts this ArtifactAndEvent to JSON.
             * @function toJSON
             * @memberof ml_metadata.PutExecutionRequest.ArtifactAndEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ArtifactAndEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ArtifactAndEvent;
        })();

        PutExecutionRequest.Options = (function() {

            /**
             * Properties of an Options.
             * @memberof ml_metadata.PutExecutionRequest
             * @interface IOptions
             * @property {boolean|null} [reuseContextIfAlreadyExist] Options reuseContextIfAlreadyExist
             */

            /**
             * Constructs a new Options.
             * @memberof ml_metadata.PutExecutionRequest
             * @classdesc Represents an Options.
             * @implements IOptions
             * @constructor
             * @param {ml_metadata.PutExecutionRequest.IOptions=} [properties] Properties to set
             */
            function Options(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Options reuseContextIfAlreadyExist.
             * @member {boolean} reuseContextIfAlreadyExist
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @instance
             */
            Options.prototype.reuseContextIfAlreadyExist = false;

            /**
             * Creates a new Options instance using the specified properties.
             * @function create
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @static
             * @param {ml_metadata.PutExecutionRequest.IOptions=} [properties] Properties to set
             * @returns {ml_metadata.PutExecutionRequest.Options} Options instance
             */
            Options.create = function create(properties) {
                return new Options(properties);
            };

            /**
             * Encodes the specified Options message. Does not implicitly {@link ml_metadata.PutExecutionRequest.Options.verify|verify} messages.
             * @function encode
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @static
             * @param {ml_metadata.PutExecutionRequest.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.reuseContextIfAlreadyExist != null && Object.hasOwnProperty.call(message, "reuseContextIfAlreadyExist"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.reuseContextIfAlreadyExist);
                return writer;
            };

            /**
             * Encodes the specified Options message, length delimited. Does not implicitly {@link ml_metadata.PutExecutionRequest.Options.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @static
             * @param {ml_metadata.PutExecutionRequest.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Options message from the specified reader or buffer.
             * @function decode
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ml_metadata.PutExecutionRequest.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutExecutionRequest.Options();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.reuseContextIfAlreadyExist = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Options message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ml_metadata.PutExecutionRequest.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Options message.
             * @function verify
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Options.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.reuseContextIfAlreadyExist != null && message.hasOwnProperty("reuseContextIfAlreadyExist"))
                    if (typeof message.reuseContextIfAlreadyExist !== "boolean")
                        return "reuseContextIfAlreadyExist: boolean expected";
                return null;
            };

            /**
             * Creates an Options message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ml_metadata.PutExecutionRequest.Options} Options
             */
            Options.fromObject = function fromObject(object) {
                if (object instanceof $root.ml_metadata.PutExecutionRequest.Options)
                    return object;
                var message = new $root.ml_metadata.PutExecutionRequest.Options();
                if (object.reuseContextIfAlreadyExist != null)
                    message.reuseContextIfAlreadyExist = Boolean(object.reuseContextIfAlreadyExist);
                return message;
            };

            /**
             * Creates a plain object from an Options message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @static
             * @param {ml_metadata.PutExecutionRequest.Options} message Options
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Options.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.reuseContextIfAlreadyExist = false;
                if (message.reuseContextIfAlreadyExist != null && message.hasOwnProperty("reuseContextIfAlreadyExist"))
                    object.reuseContextIfAlreadyExist = message.reuseContextIfAlreadyExist;
                return object;
            };

            /**
             * Converts this Options to JSON.
             * @function toJSON
             * @memberof ml_metadata.PutExecutionRequest.Options
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Options.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Options;
        })();

        return PutExecutionRequest;
    })();

    ml_metadata.PutExecutionResponse = (function() {

        /**
         * Properties of a PutExecutionResponse.
         * @memberof ml_metadata
         * @interface IPutExecutionResponse
         * @property {number|Long|null} [executionId] PutExecutionResponse executionId
         * @property {Array.<number|Long>|null} [artifactIds] PutExecutionResponse artifactIds
         * @property {Array.<number|Long>|null} [contextIds] PutExecutionResponse contextIds
         */

        /**
         * Constructs a new PutExecutionResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutExecutionResponse.
         * @implements IPutExecutionResponse
         * @constructor
         * @param {ml_metadata.IPutExecutionResponse=} [properties] Properties to set
         */
        function PutExecutionResponse(properties) {
            this.artifactIds = [];
            this.contextIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutExecutionResponse executionId.
         * @member {number|Long} executionId
         * @memberof ml_metadata.PutExecutionResponse
         * @instance
         */
        PutExecutionResponse.prototype.executionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PutExecutionResponse artifactIds.
         * @member {Array.<number|Long>} artifactIds
         * @memberof ml_metadata.PutExecutionResponse
         * @instance
         */
        PutExecutionResponse.prototype.artifactIds = $util.emptyArray;

        /**
         * PutExecutionResponse contextIds.
         * @member {Array.<number|Long>} contextIds
         * @memberof ml_metadata.PutExecutionResponse
         * @instance
         */
        PutExecutionResponse.prototype.contextIds = $util.emptyArray;

        /**
         * Creates a new PutExecutionResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutExecutionResponse
         * @static
         * @param {ml_metadata.IPutExecutionResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutExecutionResponse} PutExecutionResponse instance
         */
        PutExecutionResponse.create = function create(properties) {
            return new PutExecutionResponse(properties);
        };

        /**
         * Encodes the specified PutExecutionResponse message. Does not implicitly {@link ml_metadata.PutExecutionResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutExecutionResponse
         * @static
         * @param {ml_metadata.IPutExecutionResponse} message PutExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionId != null && Object.hasOwnProperty.call(message, "executionId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.executionId);
            if (message.artifactIds != null && message.artifactIds.length)
                for (var i = 0; i < message.artifactIds.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.artifactIds[i]);
            if (message.contextIds != null && message.contextIds.length)
                for (var i = 0; i < message.contextIds.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.contextIds[i]);
            return writer;
        };

        /**
         * Encodes the specified PutExecutionResponse message, length delimited. Does not implicitly {@link ml_metadata.PutExecutionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutExecutionResponse
         * @static
         * @param {ml_metadata.IPutExecutionResponse} message PutExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutExecutionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutExecutionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutExecutionResponse} PutExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutExecutionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.executionId = reader.int64();
                    break;
                case 2:
                    if (!(message.artifactIds && message.artifactIds.length))
                        message.artifactIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.artifactIds.push(reader.int64());
                    } else
                        message.artifactIds.push(reader.int64());
                    break;
                case 3:
                    if (!(message.contextIds && message.contextIds.length))
                        message.contextIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.contextIds.push(reader.int64());
                    } else
                        message.contextIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutExecutionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutExecutionResponse} PutExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutExecutionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutExecutionResponse message.
         * @function verify
         * @memberof ml_metadata.PutExecutionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutExecutionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionId != null && message.hasOwnProperty("executionId"))
                if (!$util.isInteger(message.executionId) && !(message.executionId && $util.isInteger(message.executionId.low) && $util.isInteger(message.executionId.high)))
                    return "executionId: integer|Long expected";
            if (message.artifactIds != null && message.hasOwnProperty("artifactIds")) {
                if (!Array.isArray(message.artifactIds))
                    return "artifactIds: array expected";
                for (var i = 0; i < message.artifactIds.length; ++i)
                    if (!$util.isInteger(message.artifactIds[i]) && !(message.artifactIds[i] && $util.isInteger(message.artifactIds[i].low) && $util.isInteger(message.artifactIds[i].high)))
                        return "artifactIds: integer|Long[] expected";
            }
            if (message.contextIds != null && message.hasOwnProperty("contextIds")) {
                if (!Array.isArray(message.contextIds))
                    return "contextIds: array expected";
                for (var i = 0; i < message.contextIds.length; ++i)
                    if (!$util.isInteger(message.contextIds[i]) && !(message.contextIds[i] && $util.isInteger(message.contextIds[i].low) && $util.isInteger(message.contextIds[i].high)))
                        return "contextIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a PutExecutionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutExecutionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutExecutionResponse} PutExecutionResponse
         */
        PutExecutionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutExecutionResponse)
                return object;
            var message = new $root.ml_metadata.PutExecutionResponse();
            if (object.executionId != null)
                if ($util.Long)
                    (message.executionId = $util.Long.fromValue(object.executionId)).unsigned = false;
                else if (typeof object.executionId === "string")
                    message.executionId = parseInt(object.executionId, 10);
                else if (typeof object.executionId === "number")
                    message.executionId = object.executionId;
                else if (typeof object.executionId === "object")
                    message.executionId = new $util.LongBits(object.executionId.low >>> 0, object.executionId.high >>> 0).toNumber();
            if (object.artifactIds) {
                if (!Array.isArray(object.artifactIds))
                    throw TypeError(".ml_metadata.PutExecutionResponse.artifactIds: array expected");
                message.artifactIds = [];
                for (var i = 0; i < object.artifactIds.length; ++i)
                    if ($util.Long)
                        (message.artifactIds[i] = $util.Long.fromValue(object.artifactIds[i])).unsigned = false;
                    else if (typeof object.artifactIds[i] === "string")
                        message.artifactIds[i] = parseInt(object.artifactIds[i], 10);
                    else if (typeof object.artifactIds[i] === "number")
                        message.artifactIds[i] = object.artifactIds[i];
                    else if (typeof object.artifactIds[i] === "object")
                        message.artifactIds[i] = new $util.LongBits(object.artifactIds[i].low >>> 0, object.artifactIds[i].high >>> 0).toNumber();
            }
            if (object.contextIds) {
                if (!Array.isArray(object.contextIds))
                    throw TypeError(".ml_metadata.PutExecutionResponse.contextIds: array expected");
                message.contextIds = [];
                for (var i = 0; i < object.contextIds.length; ++i)
                    if ($util.Long)
                        (message.contextIds[i] = $util.Long.fromValue(object.contextIds[i])).unsigned = false;
                    else if (typeof object.contextIds[i] === "string")
                        message.contextIds[i] = parseInt(object.contextIds[i], 10);
                    else if (typeof object.contextIds[i] === "number")
                        message.contextIds[i] = object.contextIds[i];
                    else if (typeof object.contextIds[i] === "object")
                        message.contextIds[i] = new $util.LongBits(object.contextIds[i].low >>> 0, object.contextIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a PutExecutionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutExecutionResponse
         * @static
         * @param {ml_metadata.PutExecutionResponse} message PutExecutionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutExecutionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.artifactIds = [];
                object.contextIds = [];
            }
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.executionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.executionId = options.longs === String ? "0" : 0;
            if (message.executionId != null && message.hasOwnProperty("executionId"))
                if (typeof message.executionId === "number")
                    object.executionId = options.longs === String ? String(message.executionId) : message.executionId;
                else
                    object.executionId = options.longs === String ? $util.Long.prototype.toString.call(message.executionId) : options.longs === Number ? new $util.LongBits(message.executionId.low >>> 0, message.executionId.high >>> 0).toNumber() : message.executionId;
            if (message.artifactIds && message.artifactIds.length) {
                object.artifactIds = [];
                for (var j = 0; j < message.artifactIds.length; ++j)
                    if (typeof message.artifactIds[j] === "number")
                        object.artifactIds[j] = options.longs === String ? String(message.artifactIds[j]) : message.artifactIds[j];
                    else
                        object.artifactIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.artifactIds[j]) : options.longs === Number ? new $util.LongBits(message.artifactIds[j].low >>> 0, message.artifactIds[j].high >>> 0).toNumber() : message.artifactIds[j];
            }
            if (message.contextIds && message.contextIds.length) {
                object.contextIds = [];
                for (var j = 0; j < message.contextIds.length; ++j)
                    if (typeof message.contextIds[j] === "number")
                        object.contextIds[j] = options.longs === String ? String(message.contextIds[j]) : message.contextIds[j];
                    else
                        object.contextIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.contextIds[j]) : options.longs === Number ? new $util.LongBits(message.contextIds[j].low >>> 0, message.contextIds[j].high >>> 0).toNumber() : message.contextIds[j];
            }
            return object;
        };

        /**
         * Converts this PutExecutionResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutExecutionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutExecutionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutExecutionResponse;
    })();

    ml_metadata.PutTypesRequest = (function() {

        /**
         * Properties of a PutTypesRequest.
         * @memberof ml_metadata
         * @interface IPutTypesRequest
         * @property {Array.<ml_metadata.IArtifactType>|null} [artifactTypes] PutTypesRequest artifactTypes
         * @property {Array.<ml_metadata.IExecutionType>|null} [executionTypes] PutTypesRequest executionTypes
         * @property {Array.<ml_metadata.IContextType>|null} [contextTypes] PutTypesRequest contextTypes
         * @property {boolean|null} [canAddFields] PutTypesRequest canAddFields
         * @property {boolean|null} [canOmitFields] PutTypesRequest canOmitFields
         * @property {boolean|null} [canDeleteFields] PutTypesRequest canDeleteFields
         * @property {boolean|null} [allFieldsMatch] PutTypesRequest allFieldsMatch
         */

        /**
         * Constructs a new PutTypesRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutTypesRequest.
         * @implements IPutTypesRequest
         * @constructor
         * @param {ml_metadata.IPutTypesRequest=} [properties] Properties to set
         */
        function PutTypesRequest(properties) {
            this.artifactTypes = [];
            this.executionTypes = [];
            this.contextTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutTypesRequest artifactTypes.
         * @member {Array.<ml_metadata.IArtifactType>} artifactTypes
         * @memberof ml_metadata.PutTypesRequest
         * @instance
         */
        PutTypesRequest.prototype.artifactTypes = $util.emptyArray;

        /**
         * PutTypesRequest executionTypes.
         * @member {Array.<ml_metadata.IExecutionType>} executionTypes
         * @memberof ml_metadata.PutTypesRequest
         * @instance
         */
        PutTypesRequest.prototype.executionTypes = $util.emptyArray;

        /**
         * PutTypesRequest contextTypes.
         * @member {Array.<ml_metadata.IContextType>} contextTypes
         * @memberof ml_metadata.PutTypesRequest
         * @instance
         */
        PutTypesRequest.prototype.contextTypes = $util.emptyArray;

        /**
         * PutTypesRequest canAddFields.
         * @member {boolean} canAddFields
         * @memberof ml_metadata.PutTypesRequest
         * @instance
         */
        PutTypesRequest.prototype.canAddFields = false;

        /**
         * PutTypesRequest canOmitFields.
         * @member {boolean} canOmitFields
         * @memberof ml_metadata.PutTypesRequest
         * @instance
         */
        PutTypesRequest.prototype.canOmitFields = false;

        /**
         * PutTypesRequest canDeleteFields.
         * @member {boolean} canDeleteFields
         * @memberof ml_metadata.PutTypesRequest
         * @instance
         */
        PutTypesRequest.prototype.canDeleteFields = false;

        /**
         * PutTypesRequest allFieldsMatch.
         * @member {boolean} allFieldsMatch
         * @memberof ml_metadata.PutTypesRequest
         * @instance
         */
        PutTypesRequest.prototype.allFieldsMatch = true;

        /**
         * Creates a new PutTypesRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutTypesRequest
         * @static
         * @param {ml_metadata.IPutTypesRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutTypesRequest} PutTypesRequest instance
         */
        PutTypesRequest.create = function create(properties) {
            return new PutTypesRequest(properties);
        };

        /**
         * Encodes the specified PutTypesRequest message. Does not implicitly {@link ml_metadata.PutTypesRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutTypesRequest
         * @static
         * @param {ml_metadata.IPutTypesRequest} message PutTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutTypesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactTypes != null && message.artifactTypes.length)
                for (var i = 0; i < message.artifactTypes.length; ++i)
                    $root.ml_metadata.ArtifactType.encode(message.artifactTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.executionTypes != null && message.executionTypes.length)
                for (var i = 0; i < message.executionTypes.length; ++i)
                    $root.ml_metadata.ExecutionType.encode(message.executionTypes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.contextTypes != null && message.contextTypes.length)
                for (var i = 0; i < message.contextTypes.length; ++i)
                    $root.ml_metadata.ContextType.encode(message.contextTypes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.canAddFields != null && Object.hasOwnProperty.call(message, "canAddFields"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.canAddFields);
            if (message.canDeleteFields != null && Object.hasOwnProperty.call(message, "canDeleteFields"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.canDeleteFields);
            if (message.allFieldsMatch != null && Object.hasOwnProperty.call(message, "allFieldsMatch"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.allFieldsMatch);
            if (message.canOmitFields != null && Object.hasOwnProperty.call(message, "canOmitFields"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.canOmitFields);
            return writer;
        };

        /**
         * Encodes the specified PutTypesRequest message, length delimited. Does not implicitly {@link ml_metadata.PutTypesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutTypesRequest
         * @static
         * @param {ml_metadata.IPutTypesRequest} message PutTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutTypesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutTypesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutTypesRequest} PutTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutTypesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutTypesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifactTypes && message.artifactTypes.length))
                        message.artifactTypes = [];
                    message.artifactTypes.push($root.ml_metadata.ArtifactType.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.executionTypes && message.executionTypes.length))
                        message.executionTypes = [];
                    message.executionTypes.push($root.ml_metadata.ExecutionType.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.contextTypes && message.contextTypes.length))
                        message.contextTypes = [];
                    message.contextTypes.push($root.ml_metadata.ContextType.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.canAddFields = reader.bool();
                    break;
                case 7:
                    message.canOmitFields = reader.bool();
                    break;
                case 5:
                    message.canDeleteFields = reader.bool();
                    break;
                case 6:
                    message.allFieldsMatch = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutTypesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutTypesRequest} PutTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutTypesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutTypesRequest message.
         * @function verify
         * @memberof ml_metadata.PutTypesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutTypesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactTypes != null && message.hasOwnProperty("artifactTypes")) {
                if (!Array.isArray(message.artifactTypes))
                    return "artifactTypes: array expected";
                for (var i = 0; i < message.artifactTypes.length; ++i) {
                    var error = $root.ml_metadata.ArtifactType.verify(message.artifactTypes[i]);
                    if (error)
                        return "artifactTypes." + error;
                }
            }
            if (message.executionTypes != null && message.hasOwnProperty("executionTypes")) {
                if (!Array.isArray(message.executionTypes))
                    return "executionTypes: array expected";
                for (var i = 0; i < message.executionTypes.length; ++i) {
                    var error = $root.ml_metadata.ExecutionType.verify(message.executionTypes[i]);
                    if (error)
                        return "executionTypes." + error;
                }
            }
            if (message.contextTypes != null && message.hasOwnProperty("contextTypes")) {
                if (!Array.isArray(message.contextTypes))
                    return "contextTypes: array expected";
                for (var i = 0; i < message.contextTypes.length; ++i) {
                    var error = $root.ml_metadata.ContextType.verify(message.contextTypes[i]);
                    if (error)
                        return "contextTypes." + error;
                }
            }
            if (message.canAddFields != null && message.hasOwnProperty("canAddFields"))
                if (typeof message.canAddFields !== "boolean")
                    return "canAddFields: boolean expected";
            if (message.canOmitFields != null && message.hasOwnProperty("canOmitFields"))
                if (typeof message.canOmitFields !== "boolean")
                    return "canOmitFields: boolean expected";
            if (message.canDeleteFields != null && message.hasOwnProperty("canDeleteFields"))
                if (typeof message.canDeleteFields !== "boolean")
                    return "canDeleteFields: boolean expected";
            if (message.allFieldsMatch != null && message.hasOwnProperty("allFieldsMatch"))
                if (typeof message.allFieldsMatch !== "boolean")
                    return "allFieldsMatch: boolean expected";
            return null;
        };

        /**
         * Creates a PutTypesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutTypesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutTypesRequest} PutTypesRequest
         */
        PutTypesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutTypesRequest)
                return object;
            var message = new $root.ml_metadata.PutTypesRequest();
            if (object.artifactTypes) {
                if (!Array.isArray(object.artifactTypes))
                    throw TypeError(".ml_metadata.PutTypesRequest.artifactTypes: array expected");
                message.artifactTypes = [];
                for (var i = 0; i < object.artifactTypes.length; ++i) {
                    if (typeof object.artifactTypes[i] !== "object")
                        throw TypeError(".ml_metadata.PutTypesRequest.artifactTypes: object expected");
                    message.artifactTypes[i] = $root.ml_metadata.ArtifactType.fromObject(object.artifactTypes[i]);
                }
            }
            if (object.executionTypes) {
                if (!Array.isArray(object.executionTypes))
                    throw TypeError(".ml_metadata.PutTypesRequest.executionTypes: array expected");
                message.executionTypes = [];
                for (var i = 0; i < object.executionTypes.length; ++i) {
                    if (typeof object.executionTypes[i] !== "object")
                        throw TypeError(".ml_metadata.PutTypesRequest.executionTypes: object expected");
                    message.executionTypes[i] = $root.ml_metadata.ExecutionType.fromObject(object.executionTypes[i]);
                }
            }
            if (object.contextTypes) {
                if (!Array.isArray(object.contextTypes))
                    throw TypeError(".ml_metadata.PutTypesRequest.contextTypes: array expected");
                message.contextTypes = [];
                for (var i = 0; i < object.contextTypes.length; ++i) {
                    if (typeof object.contextTypes[i] !== "object")
                        throw TypeError(".ml_metadata.PutTypesRequest.contextTypes: object expected");
                    message.contextTypes[i] = $root.ml_metadata.ContextType.fromObject(object.contextTypes[i]);
                }
            }
            if (object.canAddFields != null)
                message.canAddFields = Boolean(object.canAddFields);
            if (object.canOmitFields != null)
                message.canOmitFields = Boolean(object.canOmitFields);
            if (object.canDeleteFields != null)
                message.canDeleteFields = Boolean(object.canDeleteFields);
            if (object.allFieldsMatch != null)
                message.allFieldsMatch = Boolean(object.allFieldsMatch);
            return message;
        };

        /**
         * Creates a plain object from a PutTypesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutTypesRequest
         * @static
         * @param {ml_metadata.PutTypesRequest} message PutTypesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutTypesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.artifactTypes = [];
                object.executionTypes = [];
                object.contextTypes = [];
            }
            if (options.defaults) {
                object.canAddFields = false;
                object.canDeleteFields = false;
                object.allFieldsMatch = true;
                object.canOmitFields = false;
            }
            if (message.artifactTypes && message.artifactTypes.length) {
                object.artifactTypes = [];
                for (var j = 0; j < message.artifactTypes.length; ++j)
                    object.artifactTypes[j] = $root.ml_metadata.ArtifactType.toObject(message.artifactTypes[j], options);
            }
            if (message.executionTypes && message.executionTypes.length) {
                object.executionTypes = [];
                for (var j = 0; j < message.executionTypes.length; ++j)
                    object.executionTypes[j] = $root.ml_metadata.ExecutionType.toObject(message.executionTypes[j], options);
            }
            if (message.contextTypes && message.contextTypes.length) {
                object.contextTypes = [];
                for (var j = 0; j < message.contextTypes.length; ++j)
                    object.contextTypes[j] = $root.ml_metadata.ContextType.toObject(message.contextTypes[j], options);
            }
            if (message.canAddFields != null && message.hasOwnProperty("canAddFields"))
                object.canAddFields = message.canAddFields;
            if (message.canDeleteFields != null && message.hasOwnProperty("canDeleteFields"))
                object.canDeleteFields = message.canDeleteFields;
            if (message.allFieldsMatch != null && message.hasOwnProperty("allFieldsMatch"))
                object.allFieldsMatch = message.allFieldsMatch;
            if (message.canOmitFields != null && message.hasOwnProperty("canOmitFields"))
                object.canOmitFields = message.canOmitFields;
            return object;
        };

        /**
         * Converts this PutTypesRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutTypesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutTypesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutTypesRequest;
    })();

    ml_metadata.PutTypesResponse = (function() {

        /**
         * Properties of a PutTypesResponse.
         * @memberof ml_metadata
         * @interface IPutTypesResponse
         * @property {Array.<number|Long>|null} [artifactTypeIds] PutTypesResponse artifactTypeIds
         * @property {Array.<number|Long>|null} [executionTypeIds] PutTypesResponse executionTypeIds
         * @property {Array.<number|Long>|null} [contextTypeIds] PutTypesResponse contextTypeIds
         */

        /**
         * Constructs a new PutTypesResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutTypesResponse.
         * @implements IPutTypesResponse
         * @constructor
         * @param {ml_metadata.IPutTypesResponse=} [properties] Properties to set
         */
        function PutTypesResponse(properties) {
            this.artifactTypeIds = [];
            this.executionTypeIds = [];
            this.contextTypeIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutTypesResponse artifactTypeIds.
         * @member {Array.<number|Long>} artifactTypeIds
         * @memberof ml_metadata.PutTypesResponse
         * @instance
         */
        PutTypesResponse.prototype.artifactTypeIds = $util.emptyArray;

        /**
         * PutTypesResponse executionTypeIds.
         * @member {Array.<number|Long>} executionTypeIds
         * @memberof ml_metadata.PutTypesResponse
         * @instance
         */
        PutTypesResponse.prototype.executionTypeIds = $util.emptyArray;

        /**
         * PutTypesResponse contextTypeIds.
         * @member {Array.<number|Long>} contextTypeIds
         * @memberof ml_metadata.PutTypesResponse
         * @instance
         */
        PutTypesResponse.prototype.contextTypeIds = $util.emptyArray;

        /**
         * Creates a new PutTypesResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutTypesResponse
         * @static
         * @param {ml_metadata.IPutTypesResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutTypesResponse} PutTypesResponse instance
         */
        PutTypesResponse.create = function create(properties) {
            return new PutTypesResponse(properties);
        };

        /**
         * Encodes the specified PutTypesResponse message. Does not implicitly {@link ml_metadata.PutTypesResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutTypesResponse
         * @static
         * @param {ml_metadata.IPutTypesResponse} message PutTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutTypesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactTypeIds != null && message.artifactTypeIds.length)
                for (var i = 0; i < message.artifactTypeIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.artifactTypeIds[i]);
            if (message.executionTypeIds != null && message.executionTypeIds.length)
                for (var i = 0; i < message.executionTypeIds.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.executionTypeIds[i]);
            if (message.contextTypeIds != null && message.contextTypeIds.length)
                for (var i = 0; i < message.contextTypeIds.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.contextTypeIds[i]);
            return writer;
        };

        /**
         * Encodes the specified PutTypesResponse message, length delimited. Does not implicitly {@link ml_metadata.PutTypesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutTypesResponse
         * @static
         * @param {ml_metadata.IPutTypesResponse} message PutTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutTypesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutTypesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutTypesResponse} PutTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutTypesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutTypesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifactTypeIds && message.artifactTypeIds.length))
                        message.artifactTypeIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.artifactTypeIds.push(reader.int64());
                    } else
                        message.artifactTypeIds.push(reader.int64());
                    break;
                case 2:
                    if (!(message.executionTypeIds && message.executionTypeIds.length))
                        message.executionTypeIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.executionTypeIds.push(reader.int64());
                    } else
                        message.executionTypeIds.push(reader.int64());
                    break;
                case 3:
                    if (!(message.contextTypeIds && message.contextTypeIds.length))
                        message.contextTypeIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.contextTypeIds.push(reader.int64());
                    } else
                        message.contextTypeIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutTypesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutTypesResponse} PutTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutTypesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutTypesResponse message.
         * @function verify
         * @memberof ml_metadata.PutTypesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutTypesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactTypeIds != null && message.hasOwnProperty("artifactTypeIds")) {
                if (!Array.isArray(message.artifactTypeIds))
                    return "artifactTypeIds: array expected";
                for (var i = 0; i < message.artifactTypeIds.length; ++i)
                    if (!$util.isInteger(message.artifactTypeIds[i]) && !(message.artifactTypeIds[i] && $util.isInteger(message.artifactTypeIds[i].low) && $util.isInteger(message.artifactTypeIds[i].high)))
                        return "artifactTypeIds: integer|Long[] expected";
            }
            if (message.executionTypeIds != null && message.hasOwnProperty("executionTypeIds")) {
                if (!Array.isArray(message.executionTypeIds))
                    return "executionTypeIds: array expected";
                for (var i = 0; i < message.executionTypeIds.length; ++i)
                    if (!$util.isInteger(message.executionTypeIds[i]) && !(message.executionTypeIds[i] && $util.isInteger(message.executionTypeIds[i].low) && $util.isInteger(message.executionTypeIds[i].high)))
                        return "executionTypeIds: integer|Long[] expected";
            }
            if (message.contextTypeIds != null && message.hasOwnProperty("contextTypeIds")) {
                if (!Array.isArray(message.contextTypeIds))
                    return "contextTypeIds: array expected";
                for (var i = 0; i < message.contextTypeIds.length; ++i)
                    if (!$util.isInteger(message.contextTypeIds[i]) && !(message.contextTypeIds[i] && $util.isInteger(message.contextTypeIds[i].low) && $util.isInteger(message.contextTypeIds[i].high)))
                        return "contextTypeIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a PutTypesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutTypesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutTypesResponse} PutTypesResponse
         */
        PutTypesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutTypesResponse)
                return object;
            var message = new $root.ml_metadata.PutTypesResponse();
            if (object.artifactTypeIds) {
                if (!Array.isArray(object.artifactTypeIds))
                    throw TypeError(".ml_metadata.PutTypesResponse.artifactTypeIds: array expected");
                message.artifactTypeIds = [];
                for (var i = 0; i < object.artifactTypeIds.length; ++i)
                    if ($util.Long)
                        (message.artifactTypeIds[i] = $util.Long.fromValue(object.artifactTypeIds[i])).unsigned = false;
                    else if (typeof object.artifactTypeIds[i] === "string")
                        message.artifactTypeIds[i] = parseInt(object.artifactTypeIds[i], 10);
                    else if (typeof object.artifactTypeIds[i] === "number")
                        message.artifactTypeIds[i] = object.artifactTypeIds[i];
                    else if (typeof object.artifactTypeIds[i] === "object")
                        message.artifactTypeIds[i] = new $util.LongBits(object.artifactTypeIds[i].low >>> 0, object.artifactTypeIds[i].high >>> 0).toNumber();
            }
            if (object.executionTypeIds) {
                if (!Array.isArray(object.executionTypeIds))
                    throw TypeError(".ml_metadata.PutTypesResponse.executionTypeIds: array expected");
                message.executionTypeIds = [];
                for (var i = 0; i < object.executionTypeIds.length; ++i)
                    if ($util.Long)
                        (message.executionTypeIds[i] = $util.Long.fromValue(object.executionTypeIds[i])).unsigned = false;
                    else if (typeof object.executionTypeIds[i] === "string")
                        message.executionTypeIds[i] = parseInt(object.executionTypeIds[i], 10);
                    else if (typeof object.executionTypeIds[i] === "number")
                        message.executionTypeIds[i] = object.executionTypeIds[i];
                    else if (typeof object.executionTypeIds[i] === "object")
                        message.executionTypeIds[i] = new $util.LongBits(object.executionTypeIds[i].low >>> 0, object.executionTypeIds[i].high >>> 0).toNumber();
            }
            if (object.contextTypeIds) {
                if (!Array.isArray(object.contextTypeIds))
                    throw TypeError(".ml_metadata.PutTypesResponse.contextTypeIds: array expected");
                message.contextTypeIds = [];
                for (var i = 0; i < object.contextTypeIds.length; ++i)
                    if ($util.Long)
                        (message.contextTypeIds[i] = $util.Long.fromValue(object.contextTypeIds[i])).unsigned = false;
                    else if (typeof object.contextTypeIds[i] === "string")
                        message.contextTypeIds[i] = parseInt(object.contextTypeIds[i], 10);
                    else if (typeof object.contextTypeIds[i] === "number")
                        message.contextTypeIds[i] = object.contextTypeIds[i];
                    else if (typeof object.contextTypeIds[i] === "object")
                        message.contextTypeIds[i] = new $util.LongBits(object.contextTypeIds[i].low >>> 0, object.contextTypeIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a PutTypesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutTypesResponse
         * @static
         * @param {ml_metadata.PutTypesResponse} message PutTypesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutTypesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.artifactTypeIds = [];
                object.executionTypeIds = [];
                object.contextTypeIds = [];
            }
            if (message.artifactTypeIds && message.artifactTypeIds.length) {
                object.artifactTypeIds = [];
                for (var j = 0; j < message.artifactTypeIds.length; ++j)
                    if (typeof message.artifactTypeIds[j] === "number")
                        object.artifactTypeIds[j] = options.longs === String ? String(message.artifactTypeIds[j]) : message.artifactTypeIds[j];
                    else
                        object.artifactTypeIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.artifactTypeIds[j]) : options.longs === Number ? new $util.LongBits(message.artifactTypeIds[j].low >>> 0, message.artifactTypeIds[j].high >>> 0).toNumber() : message.artifactTypeIds[j];
            }
            if (message.executionTypeIds && message.executionTypeIds.length) {
                object.executionTypeIds = [];
                for (var j = 0; j < message.executionTypeIds.length; ++j)
                    if (typeof message.executionTypeIds[j] === "number")
                        object.executionTypeIds[j] = options.longs === String ? String(message.executionTypeIds[j]) : message.executionTypeIds[j];
                    else
                        object.executionTypeIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.executionTypeIds[j]) : options.longs === Number ? new $util.LongBits(message.executionTypeIds[j].low >>> 0, message.executionTypeIds[j].high >>> 0).toNumber() : message.executionTypeIds[j];
            }
            if (message.contextTypeIds && message.contextTypeIds.length) {
                object.contextTypeIds = [];
                for (var j = 0; j < message.contextTypeIds.length; ++j)
                    if (typeof message.contextTypeIds[j] === "number")
                        object.contextTypeIds[j] = options.longs === String ? String(message.contextTypeIds[j]) : message.contextTypeIds[j];
                    else
                        object.contextTypeIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.contextTypeIds[j]) : options.longs === Number ? new $util.LongBits(message.contextTypeIds[j].low >>> 0, message.contextTypeIds[j].high >>> 0).toNumber() : message.contextTypeIds[j];
            }
            return object;
        };

        /**
         * Converts this PutTypesResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutTypesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutTypesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutTypesResponse;
    })();

    ml_metadata.PutContextTypeRequest = (function() {

        /**
         * Properties of a PutContextTypeRequest.
         * @memberof ml_metadata
         * @interface IPutContextTypeRequest
         * @property {ml_metadata.IContextType|null} [contextType] PutContextTypeRequest contextType
         * @property {boolean|null} [canAddFields] PutContextTypeRequest canAddFields
         * @property {boolean|null} [canOmitFields] PutContextTypeRequest canOmitFields
         * @property {boolean|null} [canDeleteFields] PutContextTypeRequest canDeleteFields
         * @property {boolean|null} [allFieldsMatch] PutContextTypeRequest allFieldsMatch
         */

        /**
         * Constructs a new PutContextTypeRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutContextTypeRequest.
         * @implements IPutContextTypeRequest
         * @constructor
         * @param {ml_metadata.IPutContextTypeRequest=} [properties] Properties to set
         */
        function PutContextTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutContextTypeRequest contextType.
         * @member {ml_metadata.IContextType|null|undefined} contextType
         * @memberof ml_metadata.PutContextTypeRequest
         * @instance
         */
        PutContextTypeRequest.prototype.contextType = null;

        /**
         * PutContextTypeRequest canAddFields.
         * @member {boolean} canAddFields
         * @memberof ml_metadata.PutContextTypeRequest
         * @instance
         */
        PutContextTypeRequest.prototype.canAddFields = false;

        /**
         * PutContextTypeRequest canOmitFields.
         * @member {boolean} canOmitFields
         * @memberof ml_metadata.PutContextTypeRequest
         * @instance
         */
        PutContextTypeRequest.prototype.canOmitFields = false;

        /**
         * PutContextTypeRequest canDeleteFields.
         * @member {boolean} canDeleteFields
         * @memberof ml_metadata.PutContextTypeRequest
         * @instance
         */
        PutContextTypeRequest.prototype.canDeleteFields = false;

        /**
         * PutContextTypeRequest allFieldsMatch.
         * @member {boolean} allFieldsMatch
         * @memberof ml_metadata.PutContextTypeRequest
         * @instance
         */
        PutContextTypeRequest.prototype.allFieldsMatch = true;

        /**
         * Creates a new PutContextTypeRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutContextTypeRequest
         * @static
         * @param {ml_metadata.IPutContextTypeRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutContextTypeRequest} PutContextTypeRequest instance
         */
        PutContextTypeRequest.create = function create(properties) {
            return new PutContextTypeRequest(properties);
        };

        /**
         * Encodes the specified PutContextTypeRequest message. Does not implicitly {@link ml_metadata.PutContextTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutContextTypeRequest
         * @static
         * @param {ml_metadata.IPutContextTypeRequest} message PutContextTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutContextTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextType != null && Object.hasOwnProperty.call(message, "contextType"))
                $root.ml_metadata.ContextType.encode(message.contextType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.canAddFields != null && Object.hasOwnProperty.call(message, "canAddFields"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.canAddFields);
            if (message.canDeleteFields != null && Object.hasOwnProperty.call(message, "canDeleteFields"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.canDeleteFields);
            if (message.allFieldsMatch != null && Object.hasOwnProperty.call(message, "allFieldsMatch"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.allFieldsMatch);
            if (message.canOmitFields != null && Object.hasOwnProperty.call(message, "canOmitFields"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.canOmitFields);
            return writer;
        };

        /**
         * Encodes the specified PutContextTypeRequest message, length delimited. Does not implicitly {@link ml_metadata.PutContextTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutContextTypeRequest
         * @static
         * @param {ml_metadata.IPutContextTypeRequest} message PutContextTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutContextTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutContextTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutContextTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutContextTypeRequest} PutContextTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutContextTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutContextTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contextType = $root.ml_metadata.ContextType.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.canAddFields = reader.bool();
                    break;
                case 5:
                    message.canOmitFields = reader.bool();
                    break;
                case 3:
                    message.canDeleteFields = reader.bool();
                    break;
                case 4:
                    message.allFieldsMatch = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutContextTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutContextTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutContextTypeRequest} PutContextTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutContextTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutContextTypeRequest message.
         * @function verify
         * @memberof ml_metadata.PutContextTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutContextTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextType != null && message.hasOwnProperty("contextType")) {
                var error = $root.ml_metadata.ContextType.verify(message.contextType);
                if (error)
                    return "contextType." + error;
            }
            if (message.canAddFields != null && message.hasOwnProperty("canAddFields"))
                if (typeof message.canAddFields !== "boolean")
                    return "canAddFields: boolean expected";
            if (message.canOmitFields != null && message.hasOwnProperty("canOmitFields"))
                if (typeof message.canOmitFields !== "boolean")
                    return "canOmitFields: boolean expected";
            if (message.canDeleteFields != null && message.hasOwnProperty("canDeleteFields"))
                if (typeof message.canDeleteFields !== "boolean")
                    return "canDeleteFields: boolean expected";
            if (message.allFieldsMatch != null && message.hasOwnProperty("allFieldsMatch"))
                if (typeof message.allFieldsMatch !== "boolean")
                    return "allFieldsMatch: boolean expected";
            return null;
        };

        /**
         * Creates a PutContextTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutContextTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutContextTypeRequest} PutContextTypeRequest
         */
        PutContextTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutContextTypeRequest)
                return object;
            var message = new $root.ml_metadata.PutContextTypeRequest();
            if (object.contextType != null) {
                if (typeof object.contextType !== "object")
                    throw TypeError(".ml_metadata.PutContextTypeRequest.contextType: object expected");
                message.contextType = $root.ml_metadata.ContextType.fromObject(object.contextType);
            }
            if (object.canAddFields != null)
                message.canAddFields = Boolean(object.canAddFields);
            if (object.canOmitFields != null)
                message.canOmitFields = Boolean(object.canOmitFields);
            if (object.canDeleteFields != null)
                message.canDeleteFields = Boolean(object.canDeleteFields);
            if (object.allFieldsMatch != null)
                message.allFieldsMatch = Boolean(object.allFieldsMatch);
            return message;
        };

        /**
         * Creates a plain object from a PutContextTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutContextTypeRequest
         * @static
         * @param {ml_metadata.PutContextTypeRequest} message PutContextTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutContextTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.contextType = null;
                object.canAddFields = false;
                object.canDeleteFields = false;
                object.allFieldsMatch = true;
                object.canOmitFields = false;
            }
            if (message.contextType != null && message.hasOwnProperty("contextType"))
                object.contextType = $root.ml_metadata.ContextType.toObject(message.contextType, options);
            if (message.canAddFields != null && message.hasOwnProperty("canAddFields"))
                object.canAddFields = message.canAddFields;
            if (message.canDeleteFields != null && message.hasOwnProperty("canDeleteFields"))
                object.canDeleteFields = message.canDeleteFields;
            if (message.allFieldsMatch != null && message.hasOwnProperty("allFieldsMatch"))
                object.allFieldsMatch = message.allFieldsMatch;
            if (message.canOmitFields != null && message.hasOwnProperty("canOmitFields"))
                object.canOmitFields = message.canOmitFields;
            return object;
        };

        /**
         * Converts this PutContextTypeRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutContextTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutContextTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutContextTypeRequest;
    })();

    ml_metadata.PutContextTypeResponse = (function() {

        /**
         * Properties of a PutContextTypeResponse.
         * @memberof ml_metadata
         * @interface IPutContextTypeResponse
         * @property {number|Long|null} [typeId] PutContextTypeResponse typeId
         */

        /**
         * Constructs a new PutContextTypeResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutContextTypeResponse.
         * @implements IPutContextTypeResponse
         * @constructor
         * @param {ml_metadata.IPutContextTypeResponse=} [properties] Properties to set
         */
        function PutContextTypeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutContextTypeResponse typeId.
         * @member {number|Long} typeId
         * @memberof ml_metadata.PutContextTypeResponse
         * @instance
         */
        PutContextTypeResponse.prototype.typeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PutContextTypeResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutContextTypeResponse
         * @static
         * @param {ml_metadata.IPutContextTypeResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutContextTypeResponse} PutContextTypeResponse instance
         */
        PutContextTypeResponse.create = function create(properties) {
            return new PutContextTypeResponse(properties);
        };

        /**
         * Encodes the specified PutContextTypeResponse message. Does not implicitly {@link ml_metadata.PutContextTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutContextTypeResponse
         * @static
         * @param {ml_metadata.IPutContextTypeResponse} message PutContextTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutContextTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeId != null && Object.hasOwnProperty.call(message, "typeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.typeId);
            return writer;
        };

        /**
         * Encodes the specified PutContextTypeResponse message, length delimited. Does not implicitly {@link ml_metadata.PutContextTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutContextTypeResponse
         * @static
         * @param {ml_metadata.IPutContextTypeResponse} message PutContextTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutContextTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutContextTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutContextTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutContextTypeResponse} PutContextTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutContextTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutContextTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutContextTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutContextTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutContextTypeResponse} PutContextTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutContextTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutContextTypeResponse message.
         * @function verify
         * @memberof ml_metadata.PutContextTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutContextTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (!$util.isInteger(message.typeId) && !(message.typeId && $util.isInteger(message.typeId.low) && $util.isInteger(message.typeId.high)))
                    return "typeId: integer|Long expected";
            return null;
        };

        /**
         * Creates a PutContextTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutContextTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutContextTypeResponse} PutContextTypeResponse
         */
        PutContextTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutContextTypeResponse)
                return object;
            var message = new $root.ml_metadata.PutContextTypeResponse();
            if (object.typeId != null)
                if ($util.Long)
                    (message.typeId = $util.Long.fromValue(object.typeId)).unsigned = false;
                else if (typeof object.typeId === "string")
                    message.typeId = parseInt(object.typeId, 10);
                else if (typeof object.typeId === "number")
                    message.typeId = object.typeId;
                else if (typeof object.typeId === "object")
                    message.typeId = new $util.LongBits(object.typeId.low >>> 0, object.typeId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PutContextTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutContextTypeResponse
         * @static
         * @param {ml_metadata.PutContextTypeResponse} message PutContextTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutContextTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.typeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.typeId = options.longs === String ? "0" : 0;
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (typeof message.typeId === "number")
                    object.typeId = options.longs === String ? String(message.typeId) : message.typeId;
                else
                    object.typeId = options.longs === String ? $util.Long.prototype.toString.call(message.typeId) : options.longs === Number ? new $util.LongBits(message.typeId.low >>> 0, message.typeId.high >>> 0).toNumber() : message.typeId;
            return object;
        };

        /**
         * Converts this PutContextTypeResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutContextTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutContextTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutContextTypeResponse;
    })();

    ml_metadata.PutContextsRequest = (function() {

        /**
         * Properties of a PutContextsRequest.
         * @memberof ml_metadata
         * @interface IPutContextsRequest
         * @property {Array.<ml_metadata.IContext>|null} [contexts] PutContextsRequest contexts
         */

        /**
         * Constructs a new PutContextsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutContextsRequest.
         * @implements IPutContextsRequest
         * @constructor
         * @param {ml_metadata.IPutContextsRequest=} [properties] Properties to set
         */
        function PutContextsRequest(properties) {
            this.contexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutContextsRequest contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.PutContextsRequest
         * @instance
         */
        PutContextsRequest.prototype.contexts = $util.emptyArray;

        /**
         * Creates a new PutContextsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutContextsRequest
         * @static
         * @param {ml_metadata.IPutContextsRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutContextsRequest} PutContextsRequest instance
         */
        PutContextsRequest.create = function create(properties) {
            return new PutContextsRequest(properties);
        };

        /**
         * Encodes the specified PutContextsRequest message. Does not implicitly {@link ml_metadata.PutContextsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutContextsRequest
         * @static
         * @param {ml_metadata.IPutContextsRequest} message PutContextsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutContextsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PutContextsRequest message, length delimited. Does not implicitly {@link ml_metadata.PutContextsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutContextsRequest
         * @static
         * @param {ml_metadata.IPutContextsRequest} message PutContextsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutContextsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutContextsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutContextsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutContextsRequest} PutContextsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutContextsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutContextsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutContextsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutContextsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutContextsRequest} PutContextsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutContextsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutContextsRequest message.
         * @function verify
         * @memberof ml_metadata.PutContextsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutContextsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PutContextsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutContextsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutContextsRequest} PutContextsRequest
         */
        PutContextsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutContextsRequest)
                return object;
            var message = new $root.ml_metadata.PutContextsRequest();
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.PutContextsRequest.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.PutContextsRequest.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PutContextsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutContextsRequest
         * @static
         * @param {ml_metadata.PutContextsRequest} message PutContextsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutContextsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contexts = [];
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            return object;
        };

        /**
         * Converts this PutContextsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutContextsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutContextsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutContextsRequest;
    })();

    ml_metadata.PutContextsResponse = (function() {

        /**
         * Properties of a PutContextsResponse.
         * @memberof ml_metadata
         * @interface IPutContextsResponse
         * @property {Array.<number|Long>|null} [contextIds] PutContextsResponse contextIds
         */

        /**
         * Constructs a new PutContextsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutContextsResponse.
         * @implements IPutContextsResponse
         * @constructor
         * @param {ml_metadata.IPutContextsResponse=} [properties] Properties to set
         */
        function PutContextsResponse(properties) {
            this.contextIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutContextsResponse contextIds.
         * @member {Array.<number|Long>} contextIds
         * @memberof ml_metadata.PutContextsResponse
         * @instance
         */
        PutContextsResponse.prototype.contextIds = $util.emptyArray;

        /**
         * Creates a new PutContextsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutContextsResponse
         * @static
         * @param {ml_metadata.IPutContextsResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutContextsResponse} PutContextsResponse instance
         */
        PutContextsResponse.create = function create(properties) {
            return new PutContextsResponse(properties);
        };

        /**
         * Encodes the specified PutContextsResponse message. Does not implicitly {@link ml_metadata.PutContextsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutContextsResponse
         * @static
         * @param {ml_metadata.IPutContextsResponse} message PutContextsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutContextsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextIds != null && message.contextIds.length)
                for (var i = 0; i < message.contextIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.contextIds[i]);
            return writer;
        };

        /**
         * Encodes the specified PutContextsResponse message, length delimited. Does not implicitly {@link ml_metadata.PutContextsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutContextsResponse
         * @static
         * @param {ml_metadata.IPutContextsResponse} message PutContextsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutContextsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutContextsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutContextsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutContextsResponse} PutContextsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutContextsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutContextsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contextIds && message.contextIds.length))
                        message.contextIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.contextIds.push(reader.int64());
                    } else
                        message.contextIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutContextsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutContextsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutContextsResponse} PutContextsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutContextsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutContextsResponse message.
         * @function verify
         * @memberof ml_metadata.PutContextsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutContextsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextIds != null && message.hasOwnProperty("contextIds")) {
                if (!Array.isArray(message.contextIds))
                    return "contextIds: array expected";
                for (var i = 0; i < message.contextIds.length; ++i)
                    if (!$util.isInteger(message.contextIds[i]) && !(message.contextIds[i] && $util.isInteger(message.contextIds[i].low) && $util.isInteger(message.contextIds[i].high)))
                        return "contextIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a PutContextsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutContextsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutContextsResponse} PutContextsResponse
         */
        PutContextsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutContextsResponse)
                return object;
            var message = new $root.ml_metadata.PutContextsResponse();
            if (object.contextIds) {
                if (!Array.isArray(object.contextIds))
                    throw TypeError(".ml_metadata.PutContextsResponse.contextIds: array expected");
                message.contextIds = [];
                for (var i = 0; i < object.contextIds.length; ++i)
                    if ($util.Long)
                        (message.contextIds[i] = $util.Long.fromValue(object.contextIds[i])).unsigned = false;
                    else if (typeof object.contextIds[i] === "string")
                        message.contextIds[i] = parseInt(object.contextIds[i], 10);
                    else if (typeof object.contextIds[i] === "number")
                        message.contextIds[i] = object.contextIds[i];
                    else if (typeof object.contextIds[i] === "object")
                        message.contextIds[i] = new $util.LongBits(object.contextIds[i].low >>> 0, object.contextIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a PutContextsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutContextsResponse
         * @static
         * @param {ml_metadata.PutContextsResponse} message PutContextsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutContextsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contextIds = [];
            if (message.contextIds && message.contextIds.length) {
                object.contextIds = [];
                for (var j = 0; j < message.contextIds.length; ++j)
                    if (typeof message.contextIds[j] === "number")
                        object.contextIds[j] = options.longs === String ? String(message.contextIds[j]) : message.contextIds[j];
                    else
                        object.contextIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.contextIds[j]) : options.longs === Number ? new $util.LongBits(message.contextIds[j].low >>> 0, message.contextIds[j].high >>> 0).toNumber() : message.contextIds[j];
            }
            return object;
        };

        /**
         * Converts this PutContextsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutContextsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutContextsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutContextsResponse;
    })();

    ml_metadata.PutAttributionsAndAssociationsRequest = (function() {

        /**
         * Properties of a PutAttributionsAndAssociationsRequest.
         * @memberof ml_metadata
         * @interface IPutAttributionsAndAssociationsRequest
         * @property {Array.<ml_metadata.IAttribution>|null} [attributions] PutAttributionsAndAssociationsRequest attributions
         * @property {Array.<ml_metadata.IAssociation>|null} [associations] PutAttributionsAndAssociationsRequest associations
         */

        /**
         * Constructs a new PutAttributionsAndAssociationsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutAttributionsAndAssociationsRequest.
         * @implements IPutAttributionsAndAssociationsRequest
         * @constructor
         * @param {ml_metadata.IPutAttributionsAndAssociationsRequest=} [properties] Properties to set
         */
        function PutAttributionsAndAssociationsRequest(properties) {
            this.attributions = [];
            this.associations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutAttributionsAndAssociationsRequest attributions.
         * @member {Array.<ml_metadata.IAttribution>} attributions
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @instance
         */
        PutAttributionsAndAssociationsRequest.prototype.attributions = $util.emptyArray;

        /**
         * PutAttributionsAndAssociationsRequest associations.
         * @member {Array.<ml_metadata.IAssociation>} associations
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @instance
         */
        PutAttributionsAndAssociationsRequest.prototype.associations = $util.emptyArray;

        /**
         * Creates a new PutAttributionsAndAssociationsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @static
         * @param {ml_metadata.IPutAttributionsAndAssociationsRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutAttributionsAndAssociationsRequest} PutAttributionsAndAssociationsRequest instance
         */
        PutAttributionsAndAssociationsRequest.create = function create(properties) {
            return new PutAttributionsAndAssociationsRequest(properties);
        };

        /**
         * Encodes the specified PutAttributionsAndAssociationsRequest message. Does not implicitly {@link ml_metadata.PutAttributionsAndAssociationsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @static
         * @param {ml_metadata.IPutAttributionsAndAssociationsRequest} message PutAttributionsAndAssociationsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutAttributionsAndAssociationsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.attributions != null && message.attributions.length)
                for (var i = 0; i < message.attributions.length; ++i)
                    $root.ml_metadata.Attribution.encode(message.attributions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.associations != null && message.associations.length)
                for (var i = 0; i < message.associations.length; ++i)
                    $root.ml_metadata.Association.encode(message.associations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PutAttributionsAndAssociationsRequest message, length delimited. Does not implicitly {@link ml_metadata.PutAttributionsAndAssociationsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @static
         * @param {ml_metadata.IPutAttributionsAndAssociationsRequest} message PutAttributionsAndAssociationsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutAttributionsAndAssociationsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutAttributionsAndAssociationsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutAttributionsAndAssociationsRequest} PutAttributionsAndAssociationsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutAttributionsAndAssociationsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutAttributionsAndAssociationsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.attributions && message.attributions.length))
                        message.attributions = [];
                    message.attributions.push($root.ml_metadata.Attribution.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.associations && message.associations.length))
                        message.associations = [];
                    message.associations.push($root.ml_metadata.Association.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutAttributionsAndAssociationsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutAttributionsAndAssociationsRequest} PutAttributionsAndAssociationsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutAttributionsAndAssociationsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutAttributionsAndAssociationsRequest message.
         * @function verify
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutAttributionsAndAssociationsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.attributions != null && message.hasOwnProperty("attributions")) {
                if (!Array.isArray(message.attributions))
                    return "attributions: array expected";
                for (var i = 0; i < message.attributions.length; ++i) {
                    var error = $root.ml_metadata.Attribution.verify(message.attributions[i]);
                    if (error)
                        return "attributions." + error;
                }
            }
            if (message.associations != null && message.hasOwnProperty("associations")) {
                if (!Array.isArray(message.associations))
                    return "associations: array expected";
                for (var i = 0; i < message.associations.length; ++i) {
                    var error = $root.ml_metadata.Association.verify(message.associations[i]);
                    if (error)
                        return "associations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PutAttributionsAndAssociationsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutAttributionsAndAssociationsRequest} PutAttributionsAndAssociationsRequest
         */
        PutAttributionsAndAssociationsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutAttributionsAndAssociationsRequest)
                return object;
            var message = new $root.ml_metadata.PutAttributionsAndAssociationsRequest();
            if (object.attributions) {
                if (!Array.isArray(object.attributions))
                    throw TypeError(".ml_metadata.PutAttributionsAndAssociationsRequest.attributions: array expected");
                message.attributions = [];
                for (var i = 0; i < object.attributions.length; ++i) {
                    if (typeof object.attributions[i] !== "object")
                        throw TypeError(".ml_metadata.PutAttributionsAndAssociationsRequest.attributions: object expected");
                    message.attributions[i] = $root.ml_metadata.Attribution.fromObject(object.attributions[i]);
                }
            }
            if (object.associations) {
                if (!Array.isArray(object.associations))
                    throw TypeError(".ml_metadata.PutAttributionsAndAssociationsRequest.associations: array expected");
                message.associations = [];
                for (var i = 0; i < object.associations.length; ++i) {
                    if (typeof object.associations[i] !== "object")
                        throw TypeError(".ml_metadata.PutAttributionsAndAssociationsRequest.associations: object expected");
                    message.associations[i] = $root.ml_metadata.Association.fromObject(object.associations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PutAttributionsAndAssociationsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @static
         * @param {ml_metadata.PutAttributionsAndAssociationsRequest} message PutAttributionsAndAssociationsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutAttributionsAndAssociationsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.attributions = [];
                object.associations = [];
            }
            if (message.attributions && message.attributions.length) {
                object.attributions = [];
                for (var j = 0; j < message.attributions.length; ++j)
                    object.attributions[j] = $root.ml_metadata.Attribution.toObject(message.attributions[j], options);
            }
            if (message.associations && message.associations.length) {
                object.associations = [];
                for (var j = 0; j < message.associations.length; ++j)
                    object.associations[j] = $root.ml_metadata.Association.toObject(message.associations[j], options);
            }
            return object;
        };

        /**
         * Converts this PutAttributionsAndAssociationsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutAttributionsAndAssociationsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutAttributionsAndAssociationsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutAttributionsAndAssociationsRequest;
    })();

    ml_metadata.PutAttributionsAndAssociationsResponse = (function() {

        /**
         * Properties of a PutAttributionsAndAssociationsResponse.
         * @memberof ml_metadata
         * @interface IPutAttributionsAndAssociationsResponse
         */

        /**
         * Constructs a new PutAttributionsAndAssociationsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutAttributionsAndAssociationsResponse.
         * @implements IPutAttributionsAndAssociationsResponse
         * @constructor
         * @param {ml_metadata.IPutAttributionsAndAssociationsResponse=} [properties] Properties to set
         */
        function PutAttributionsAndAssociationsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PutAttributionsAndAssociationsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutAttributionsAndAssociationsResponse
         * @static
         * @param {ml_metadata.IPutAttributionsAndAssociationsResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutAttributionsAndAssociationsResponse} PutAttributionsAndAssociationsResponse instance
         */
        PutAttributionsAndAssociationsResponse.create = function create(properties) {
            return new PutAttributionsAndAssociationsResponse(properties);
        };

        /**
         * Encodes the specified PutAttributionsAndAssociationsResponse message. Does not implicitly {@link ml_metadata.PutAttributionsAndAssociationsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutAttributionsAndAssociationsResponse
         * @static
         * @param {ml_metadata.IPutAttributionsAndAssociationsResponse} message PutAttributionsAndAssociationsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutAttributionsAndAssociationsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PutAttributionsAndAssociationsResponse message, length delimited. Does not implicitly {@link ml_metadata.PutAttributionsAndAssociationsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutAttributionsAndAssociationsResponse
         * @static
         * @param {ml_metadata.IPutAttributionsAndAssociationsResponse} message PutAttributionsAndAssociationsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutAttributionsAndAssociationsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutAttributionsAndAssociationsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutAttributionsAndAssociationsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutAttributionsAndAssociationsResponse} PutAttributionsAndAssociationsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutAttributionsAndAssociationsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutAttributionsAndAssociationsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutAttributionsAndAssociationsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutAttributionsAndAssociationsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutAttributionsAndAssociationsResponse} PutAttributionsAndAssociationsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutAttributionsAndAssociationsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutAttributionsAndAssociationsResponse message.
         * @function verify
         * @memberof ml_metadata.PutAttributionsAndAssociationsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutAttributionsAndAssociationsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PutAttributionsAndAssociationsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutAttributionsAndAssociationsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutAttributionsAndAssociationsResponse} PutAttributionsAndAssociationsResponse
         */
        PutAttributionsAndAssociationsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutAttributionsAndAssociationsResponse)
                return object;
            return new $root.ml_metadata.PutAttributionsAndAssociationsResponse();
        };

        /**
         * Creates a plain object from a PutAttributionsAndAssociationsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutAttributionsAndAssociationsResponse
         * @static
         * @param {ml_metadata.PutAttributionsAndAssociationsResponse} message PutAttributionsAndAssociationsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutAttributionsAndAssociationsResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PutAttributionsAndAssociationsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutAttributionsAndAssociationsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutAttributionsAndAssociationsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutAttributionsAndAssociationsResponse;
    })();

    ml_metadata.PutParentContextsRequest = (function() {

        /**
         * Properties of a PutParentContextsRequest.
         * @memberof ml_metadata
         * @interface IPutParentContextsRequest
         * @property {Array.<ml_metadata.IParentContext>|null} [parentContexts] PutParentContextsRequest parentContexts
         */

        /**
         * Constructs a new PutParentContextsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a PutParentContextsRequest.
         * @implements IPutParentContextsRequest
         * @constructor
         * @param {ml_metadata.IPutParentContextsRequest=} [properties] Properties to set
         */
        function PutParentContextsRequest(properties) {
            this.parentContexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PutParentContextsRequest parentContexts.
         * @member {Array.<ml_metadata.IParentContext>} parentContexts
         * @memberof ml_metadata.PutParentContextsRequest
         * @instance
         */
        PutParentContextsRequest.prototype.parentContexts = $util.emptyArray;

        /**
         * Creates a new PutParentContextsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutParentContextsRequest
         * @static
         * @param {ml_metadata.IPutParentContextsRequest=} [properties] Properties to set
         * @returns {ml_metadata.PutParentContextsRequest} PutParentContextsRequest instance
         */
        PutParentContextsRequest.create = function create(properties) {
            return new PutParentContextsRequest(properties);
        };

        /**
         * Encodes the specified PutParentContextsRequest message. Does not implicitly {@link ml_metadata.PutParentContextsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutParentContextsRequest
         * @static
         * @param {ml_metadata.IPutParentContextsRequest} message PutParentContextsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutParentContextsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.parentContexts != null && message.parentContexts.length)
                for (var i = 0; i < message.parentContexts.length; ++i)
                    $root.ml_metadata.ParentContext.encode(message.parentContexts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PutParentContextsRequest message, length delimited. Does not implicitly {@link ml_metadata.PutParentContextsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutParentContextsRequest
         * @static
         * @param {ml_metadata.IPutParentContextsRequest} message PutParentContextsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutParentContextsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutParentContextsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutParentContextsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutParentContextsRequest} PutParentContextsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutParentContextsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutParentContextsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.parentContexts && message.parentContexts.length))
                        message.parentContexts = [];
                    message.parentContexts.push($root.ml_metadata.ParentContext.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutParentContextsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutParentContextsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutParentContextsRequest} PutParentContextsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutParentContextsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutParentContextsRequest message.
         * @function verify
         * @memberof ml_metadata.PutParentContextsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutParentContextsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.parentContexts != null && message.hasOwnProperty("parentContexts")) {
                if (!Array.isArray(message.parentContexts))
                    return "parentContexts: array expected";
                for (var i = 0; i < message.parentContexts.length; ++i) {
                    var error = $root.ml_metadata.ParentContext.verify(message.parentContexts[i]);
                    if (error)
                        return "parentContexts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PutParentContextsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutParentContextsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutParentContextsRequest} PutParentContextsRequest
         */
        PutParentContextsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutParentContextsRequest)
                return object;
            var message = new $root.ml_metadata.PutParentContextsRequest();
            if (object.parentContexts) {
                if (!Array.isArray(object.parentContexts))
                    throw TypeError(".ml_metadata.PutParentContextsRequest.parentContexts: array expected");
                message.parentContexts = [];
                for (var i = 0; i < object.parentContexts.length; ++i) {
                    if (typeof object.parentContexts[i] !== "object")
                        throw TypeError(".ml_metadata.PutParentContextsRequest.parentContexts: object expected");
                    message.parentContexts[i] = $root.ml_metadata.ParentContext.fromObject(object.parentContexts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PutParentContextsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutParentContextsRequest
         * @static
         * @param {ml_metadata.PutParentContextsRequest} message PutParentContextsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutParentContextsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.parentContexts = [];
            if (message.parentContexts && message.parentContexts.length) {
                object.parentContexts = [];
                for (var j = 0; j < message.parentContexts.length; ++j)
                    object.parentContexts[j] = $root.ml_metadata.ParentContext.toObject(message.parentContexts[j], options);
            }
            return object;
        };

        /**
         * Converts this PutParentContextsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutParentContextsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutParentContextsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutParentContextsRequest;
    })();

    ml_metadata.PutParentContextsResponse = (function() {

        /**
         * Properties of a PutParentContextsResponse.
         * @memberof ml_metadata
         * @interface IPutParentContextsResponse
         */

        /**
         * Constructs a new PutParentContextsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a PutParentContextsResponse.
         * @implements IPutParentContextsResponse
         * @constructor
         * @param {ml_metadata.IPutParentContextsResponse=} [properties] Properties to set
         */
        function PutParentContextsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PutParentContextsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.PutParentContextsResponse
         * @static
         * @param {ml_metadata.IPutParentContextsResponse=} [properties] Properties to set
         * @returns {ml_metadata.PutParentContextsResponse} PutParentContextsResponse instance
         */
        PutParentContextsResponse.create = function create(properties) {
            return new PutParentContextsResponse(properties);
        };

        /**
         * Encodes the specified PutParentContextsResponse message. Does not implicitly {@link ml_metadata.PutParentContextsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.PutParentContextsResponse
         * @static
         * @param {ml_metadata.IPutParentContextsResponse} message PutParentContextsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutParentContextsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PutParentContextsResponse message, length delimited. Does not implicitly {@link ml_metadata.PutParentContextsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.PutParentContextsResponse
         * @static
         * @param {ml_metadata.IPutParentContextsResponse} message PutParentContextsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PutParentContextsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PutParentContextsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.PutParentContextsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.PutParentContextsResponse} PutParentContextsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutParentContextsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.PutParentContextsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PutParentContextsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.PutParentContextsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.PutParentContextsResponse} PutParentContextsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PutParentContextsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PutParentContextsResponse message.
         * @function verify
         * @memberof ml_metadata.PutParentContextsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PutParentContextsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PutParentContextsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.PutParentContextsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.PutParentContextsResponse} PutParentContextsResponse
         */
        PutParentContextsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.PutParentContextsResponse)
                return object;
            return new $root.ml_metadata.PutParentContextsResponse();
        };

        /**
         * Creates a plain object from a PutParentContextsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.PutParentContextsResponse
         * @static
         * @param {ml_metadata.PutParentContextsResponse} message PutParentContextsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PutParentContextsResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PutParentContextsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.PutParentContextsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PutParentContextsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PutParentContextsResponse;
    })();

    ml_metadata.GetArtifactsByTypeRequest = (function() {

        /**
         * Properties of a GetArtifactsByTypeRequest.
         * @memberof ml_metadata
         * @interface IGetArtifactsByTypeRequest
         * @property {string|null} [typeName] GetArtifactsByTypeRequest typeName
         * @property {string|null} [typeVersion] GetArtifactsByTypeRequest typeVersion
         */

        /**
         * Constructs a new GetArtifactsByTypeRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsByTypeRequest.
         * @implements IGetArtifactsByTypeRequest
         * @constructor
         * @param {ml_metadata.IGetArtifactsByTypeRequest=} [properties] Properties to set
         */
        function GetArtifactsByTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsByTypeRequest typeName.
         * @member {string} typeName
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @instance
         */
        GetArtifactsByTypeRequest.prototype.typeName = "";

        /**
         * GetArtifactsByTypeRequest typeVersion.
         * @member {string} typeVersion
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @instance
         */
        GetArtifactsByTypeRequest.prototype.typeVersion = "";

        /**
         * Creates a new GetArtifactsByTypeRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByTypeRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsByTypeRequest} GetArtifactsByTypeRequest instance
         */
        GetArtifactsByTypeRequest.create = function create(properties) {
            return new GetArtifactsByTypeRequest(properties);
        };

        /**
         * Encodes the specified GetArtifactsByTypeRequest message. Does not implicitly {@link ml_metadata.GetArtifactsByTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByTypeRequest} message GetArtifactsByTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeName);
            if (message.typeVersion != null && Object.hasOwnProperty.call(message, "typeVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.typeVersion);
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsByTypeRequest message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsByTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByTypeRequest} message GetArtifactsByTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsByTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsByTypeRequest} GetArtifactsByTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsByTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 2:
                    message.typeVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsByTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsByTypeRequest} GetArtifactsByTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsByTypeRequest message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsByTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                if (!$util.isString(message.typeVersion))
                    return "typeVersion: string expected";
            return null;
        };

        /**
         * Creates a GetArtifactsByTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsByTypeRequest} GetArtifactsByTypeRequest
         */
        GetArtifactsByTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsByTypeRequest)
                return object;
            var message = new $root.ml_metadata.GetArtifactsByTypeRequest();
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            if (object.typeVersion != null)
                message.typeVersion = String(object.typeVersion);
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsByTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @static
         * @param {ml_metadata.GetArtifactsByTypeRequest} message GetArtifactsByTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsByTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeName = "";
                object.typeVersion = "";
            }
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                object.typeVersion = message.typeVersion;
            return object;
        };

        /**
         * Converts this GetArtifactsByTypeRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsByTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsByTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsByTypeRequest;
    })();

    ml_metadata.GetArtifactsByTypeResponse = (function() {

        /**
         * Properties of a GetArtifactsByTypeResponse.
         * @memberof ml_metadata
         * @interface IGetArtifactsByTypeResponse
         * @property {Array.<ml_metadata.IArtifact>|null} [artifacts] GetArtifactsByTypeResponse artifacts
         */

        /**
         * Constructs a new GetArtifactsByTypeResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsByTypeResponse.
         * @implements IGetArtifactsByTypeResponse
         * @constructor
         * @param {ml_metadata.IGetArtifactsByTypeResponse=} [properties] Properties to set
         */
        function GetArtifactsByTypeResponse(properties) {
            this.artifacts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsByTypeResponse artifacts.
         * @member {Array.<ml_metadata.IArtifact>} artifacts
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @instance
         */
        GetArtifactsByTypeResponse.prototype.artifacts = $util.emptyArray;

        /**
         * Creates a new GetArtifactsByTypeResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByTypeResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsByTypeResponse} GetArtifactsByTypeResponse instance
         */
        GetArtifactsByTypeResponse.create = function create(properties) {
            return new GetArtifactsByTypeResponse(properties);
        };

        /**
         * Encodes the specified GetArtifactsByTypeResponse message. Does not implicitly {@link ml_metadata.GetArtifactsByTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByTypeResponse} message GetArtifactsByTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifacts != null && message.artifacts.length)
                for (var i = 0; i < message.artifacts.length; ++i)
                    $root.ml_metadata.Artifact.encode(message.artifacts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsByTypeResponse message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsByTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByTypeResponse} message GetArtifactsByTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsByTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsByTypeResponse} GetArtifactsByTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsByTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifacts && message.artifacts.length))
                        message.artifacts = [];
                    message.artifacts.push($root.ml_metadata.Artifact.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsByTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsByTypeResponse} GetArtifactsByTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsByTypeResponse message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsByTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifacts != null && message.hasOwnProperty("artifacts")) {
                if (!Array.isArray(message.artifacts))
                    return "artifacts: array expected";
                for (var i = 0; i < message.artifacts.length; ++i) {
                    var error = $root.ml_metadata.Artifact.verify(message.artifacts[i]);
                    if (error)
                        return "artifacts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetArtifactsByTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsByTypeResponse} GetArtifactsByTypeResponse
         */
        GetArtifactsByTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsByTypeResponse)
                return object;
            var message = new $root.ml_metadata.GetArtifactsByTypeResponse();
            if (object.artifacts) {
                if (!Array.isArray(object.artifacts))
                    throw TypeError(".ml_metadata.GetArtifactsByTypeResponse.artifacts: array expected");
                message.artifacts = [];
                for (var i = 0; i < object.artifacts.length; ++i) {
                    if (typeof object.artifacts[i] !== "object")
                        throw TypeError(".ml_metadata.GetArtifactsByTypeResponse.artifacts: object expected");
                    message.artifacts[i] = $root.ml_metadata.Artifact.fromObject(object.artifacts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsByTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @static
         * @param {ml_metadata.GetArtifactsByTypeResponse} message GetArtifactsByTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsByTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifacts = [];
            if (message.artifacts && message.artifacts.length) {
                object.artifacts = [];
                for (var j = 0; j < message.artifacts.length; ++j)
                    object.artifacts[j] = $root.ml_metadata.Artifact.toObject(message.artifacts[j], options);
            }
            return object;
        };

        /**
         * Converts this GetArtifactsByTypeResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsByTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsByTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsByTypeResponse;
    })();

    ml_metadata.GetArtifactByTypeAndNameRequest = (function() {

        /**
         * Properties of a GetArtifactByTypeAndNameRequest.
         * @memberof ml_metadata
         * @interface IGetArtifactByTypeAndNameRequest
         * @property {string|null} [typeName] GetArtifactByTypeAndNameRequest typeName
         * @property {string|null} [typeVersion] GetArtifactByTypeAndNameRequest typeVersion
         * @property {string|null} [artifactName] GetArtifactByTypeAndNameRequest artifactName
         */

        /**
         * Constructs a new GetArtifactByTypeAndNameRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactByTypeAndNameRequest.
         * @implements IGetArtifactByTypeAndNameRequest
         * @constructor
         * @param {ml_metadata.IGetArtifactByTypeAndNameRequest=} [properties] Properties to set
         */
        function GetArtifactByTypeAndNameRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactByTypeAndNameRequest typeName.
         * @member {string} typeName
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @instance
         */
        GetArtifactByTypeAndNameRequest.prototype.typeName = "";

        /**
         * GetArtifactByTypeAndNameRequest typeVersion.
         * @member {string} typeVersion
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @instance
         */
        GetArtifactByTypeAndNameRequest.prototype.typeVersion = "";

        /**
         * GetArtifactByTypeAndNameRequest artifactName.
         * @member {string} artifactName
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @instance
         */
        GetArtifactByTypeAndNameRequest.prototype.artifactName = "";

        /**
         * Creates a new GetArtifactByTypeAndNameRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @static
         * @param {ml_metadata.IGetArtifactByTypeAndNameRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactByTypeAndNameRequest} GetArtifactByTypeAndNameRequest instance
         */
        GetArtifactByTypeAndNameRequest.create = function create(properties) {
            return new GetArtifactByTypeAndNameRequest(properties);
        };

        /**
         * Encodes the specified GetArtifactByTypeAndNameRequest message. Does not implicitly {@link ml_metadata.GetArtifactByTypeAndNameRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @static
         * @param {ml_metadata.IGetArtifactByTypeAndNameRequest} message GetArtifactByTypeAndNameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactByTypeAndNameRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeName);
            if (message.artifactName != null && Object.hasOwnProperty.call(message, "artifactName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.artifactName);
            if (message.typeVersion != null && Object.hasOwnProperty.call(message, "typeVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.typeVersion);
            return writer;
        };

        /**
         * Encodes the specified GetArtifactByTypeAndNameRequest message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactByTypeAndNameRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @static
         * @param {ml_metadata.IGetArtifactByTypeAndNameRequest} message GetArtifactByTypeAndNameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactByTypeAndNameRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactByTypeAndNameRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactByTypeAndNameRequest} GetArtifactByTypeAndNameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactByTypeAndNameRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactByTypeAndNameRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 3:
                    message.typeVersion = reader.string();
                    break;
                case 2:
                    message.artifactName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactByTypeAndNameRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactByTypeAndNameRequest} GetArtifactByTypeAndNameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactByTypeAndNameRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactByTypeAndNameRequest message.
         * @function verify
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactByTypeAndNameRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                if (!$util.isString(message.typeVersion))
                    return "typeVersion: string expected";
            if (message.artifactName != null && message.hasOwnProperty("artifactName"))
                if (!$util.isString(message.artifactName))
                    return "artifactName: string expected";
            return null;
        };

        /**
         * Creates a GetArtifactByTypeAndNameRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactByTypeAndNameRequest} GetArtifactByTypeAndNameRequest
         */
        GetArtifactByTypeAndNameRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactByTypeAndNameRequest)
                return object;
            var message = new $root.ml_metadata.GetArtifactByTypeAndNameRequest();
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            if (object.typeVersion != null)
                message.typeVersion = String(object.typeVersion);
            if (object.artifactName != null)
                message.artifactName = String(object.artifactName);
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactByTypeAndNameRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @static
         * @param {ml_metadata.GetArtifactByTypeAndNameRequest} message GetArtifactByTypeAndNameRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactByTypeAndNameRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeName = "";
                object.artifactName = "";
                object.typeVersion = "";
            }
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            if (message.artifactName != null && message.hasOwnProperty("artifactName"))
                object.artifactName = message.artifactName;
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                object.typeVersion = message.typeVersion;
            return object;
        };

        /**
         * Converts this GetArtifactByTypeAndNameRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactByTypeAndNameRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactByTypeAndNameRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactByTypeAndNameRequest;
    })();

    ml_metadata.GetArtifactByTypeAndNameResponse = (function() {

        /**
         * Properties of a GetArtifactByTypeAndNameResponse.
         * @memberof ml_metadata
         * @interface IGetArtifactByTypeAndNameResponse
         * @property {ml_metadata.IArtifact|null} [artifact] GetArtifactByTypeAndNameResponse artifact
         */

        /**
         * Constructs a new GetArtifactByTypeAndNameResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactByTypeAndNameResponse.
         * @implements IGetArtifactByTypeAndNameResponse
         * @constructor
         * @param {ml_metadata.IGetArtifactByTypeAndNameResponse=} [properties] Properties to set
         */
        function GetArtifactByTypeAndNameResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactByTypeAndNameResponse artifact.
         * @member {ml_metadata.IArtifact|null|undefined} artifact
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @instance
         */
        GetArtifactByTypeAndNameResponse.prototype.artifact = null;

        /**
         * Creates a new GetArtifactByTypeAndNameResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @static
         * @param {ml_metadata.IGetArtifactByTypeAndNameResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactByTypeAndNameResponse} GetArtifactByTypeAndNameResponse instance
         */
        GetArtifactByTypeAndNameResponse.create = function create(properties) {
            return new GetArtifactByTypeAndNameResponse(properties);
        };

        /**
         * Encodes the specified GetArtifactByTypeAndNameResponse message. Does not implicitly {@link ml_metadata.GetArtifactByTypeAndNameResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @static
         * @param {ml_metadata.IGetArtifactByTypeAndNameResponse} message GetArtifactByTypeAndNameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactByTypeAndNameResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifact != null && Object.hasOwnProperty.call(message, "artifact"))
                $root.ml_metadata.Artifact.encode(message.artifact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactByTypeAndNameResponse message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactByTypeAndNameResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @static
         * @param {ml_metadata.IGetArtifactByTypeAndNameResponse} message GetArtifactByTypeAndNameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactByTypeAndNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactByTypeAndNameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactByTypeAndNameResponse} GetArtifactByTypeAndNameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactByTypeAndNameResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactByTypeAndNameResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.artifact = $root.ml_metadata.Artifact.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactByTypeAndNameResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactByTypeAndNameResponse} GetArtifactByTypeAndNameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactByTypeAndNameResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactByTypeAndNameResponse message.
         * @function verify
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactByTypeAndNameResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifact != null && message.hasOwnProperty("artifact")) {
                var error = $root.ml_metadata.Artifact.verify(message.artifact);
                if (error)
                    return "artifact." + error;
            }
            return null;
        };

        /**
         * Creates a GetArtifactByTypeAndNameResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactByTypeAndNameResponse} GetArtifactByTypeAndNameResponse
         */
        GetArtifactByTypeAndNameResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactByTypeAndNameResponse)
                return object;
            var message = new $root.ml_metadata.GetArtifactByTypeAndNameResponse();
            if (object.artifact != null) {
                if (typeof object.artifact !== "object")
                    throw TypeError(".ml_metadata.GetArtifactByTypeAndNameResponse.artifact: object expected");
                message.artifact = $root.ml_metadata.Artifact.fromObject(object.artifact);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactByTypeAndNameResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @static
         * @param {ml_metadata.GetArtifactByTypeAndNameResponse} message GetArtifactByTypeAndNameResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactByTypeAndNameResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.artifact = null;
            if (message.artifact != null && message.hasOwnProperty("artifact"))
                object.artifact = $root.ml_metadata.Artifact.toObject(message.artifact, options);
            return object;
        };

        /**
         * Converts this GetArtifactByTypeAndNameResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactByTypeAndNameResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactByTypeAndNameResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactByTypeAndNameResponse;
    })();

    ml_metadata.GetArtifactsByIDRequest = (function() {

        /**
         * Properties of a GetArtifactsByIDRequest.
         * @memberof ml_metadata
         * @interface IGetArtifactsByIDRequest
         * @property {Array.<number|Long>|null} [artifactIds] GetArtifactsByIDRequest artifactIds
         */

        /**
         * Constructs a new GetArtifactsByIDRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsByIDRequest.
         * @implements IGetArtifactsByIDRequest
         * @constructor
         * @param {ml_metadata.IGetArtifactsByIDRequest=} [properties] Properties to set
         */
        function GetArtifactsByIDRequest(properties) {
            this.artifactIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsByIDRequest artifactIds.
         * @member {Array.<number|Long>} artifactIds
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @instance
         */
        GetArtifactsByIDRequest.prototype.artifactIds = $util.emptyArray;

        /**
         * Creates a new GetArtifactsByIDRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByIDRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsByIDRequest} GetArtifactsByIDRequest instance
         */
        GetArtifactsByIDRequest.create = function create(properties) {
            return new GetArtifactsByIDRequest(properties);
        };

        /**
         * Encodes the specified GetArtifactsByIDRequest message. Does not implicitly {@link ml_metadata.GetArtifactsByIDRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByIDRequest} message GetArtifactsByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByIDRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactIds != null && message.artifactIds.length)
                for (var i = 0; i < message.artifactIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.artifactIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsByIDRequest message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsByIDRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByIDRequest} message GetArtifactsByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsByIDRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsByIDRequest} GetArtifactsByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByIDRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsByIDRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifactIds && message.artifactIds.length))
                        message.artifactIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.artifactIds.push(reader.int64());
                    } else
                        message.artifactIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsByIDRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsByIDRequest} GetArtifactsByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByIDRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsByIDRequest message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsByIDRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactIds != null && message.hasOwnProperty("artifactIds")) {
                if (!Array.isArray(message.artifactIds))
                    return "artifactIds: array expected";
                for (var i = 0; i < message.artifactIds.length; ++i)
                    if (!$util.isInteger(message.artifactIds[i]) && !(message.artifactIds[i] && $util.isInteger(message.artifactIds[i].low) && $util.isInteger(message.artifactIds[i].high)))
                        return "artifactIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a GetArtifactsByIDRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsByIDRequest} GetArtifactsByIDRequest
         */
        GetArtifactsByIDRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsByIDRequest)
                return object;
            var message = new $root.ml_metadata.GetArtifactsByIDRequest();
            if (object.artifactIds) {
                if (!Array.isArray(object.artifactIds))
                    throw TypeError(".ml_metadata.GetArtifactsByIDRequest.artifactIds: array expected");
                message.artifactIds = [];
                for (var i = 0; i < object.artifactIds.length; ++i)
                    if ($util.Long)
                        (message.artifactIds[i] = $util.Long.fromValue(object.artifactIds[i])).unsigned = false;
                    else if (typeof object.artifactIds[i] === "string")
                        message.artifactIds[i] = parseInt(object.artifactIds[i], 10);
                    else if (typeof object.artifactIds[i] === "number")
                        message.artifactIds[i] = object.artifactIds[i];
                    else if (typeof object.artifactIds[i] === "object")
                        message.artifactIds[i] = new $util.LongBits(object.artifactIds[i].low >>> 0, object.artifactIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsByIDRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @static
         * @param {ml_metadata.GetArtifactsByIDRequest} message GetArtifactsByIDRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsByIDRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifactIds = [];
            if (message.artifactIds && message.artifactIds.length) {
                object.artifactIds = [];
                for (var j = 0; j < message.artifactIds.length; ++j)
                    if (typeof message.artifactIds[j] === "number")
                        object.artifactIds[j] = options.longs === String ? String(message.artifactIds[j]) : message.artifactIds[j];
                    else
                        object.artifactIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.artifactIds[j]) : options.longs === Number ? new $util.LongBits(message.artifactIds[j].low >>> 0, message.artifactIds[j].high >>> 0).toNumber() : message.artifactIds[j];
            }
            return object;
        };

        /**
         * Converts this GetArtifactsByIDRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsByIDRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsByIDRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsByIDRequest;
    })();

    ml_metadata.GetArtifactsByIDResponse = (function() {

        /**
         * Properties of a GetArtifactsByIDResponse.
         * @memberof ml_metadata
         * @interface IGetArtifactsByIDResponse
         * @property {Array.<ml_metadata.IArtifact>|null} [artifacts] GetArtifactsByIDResponse artifacts
         */

        /**
         * Constructs a new GetArtifactsByIDResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsByIDResponse.
         * @implements IGetArtifactsByIDResponse
         * @constructor
         * @param {ml_metadata.IGetArtifactsByIDResponse=} [properties] Properties to set
         */
        function GetArtifactsByIDResponse(properties) {
            this.artifacts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsByIDResponse artifacts.
         * @member {Array.<ml_metadata.IArtifact>} artifacts
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @instance
         */
        GetArtifactsByIDResponse.prototype.artifacts = $util.emptyArray;

        /**
         * Creates a new GetArtifactsByIDResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByIDResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsByIDResponse} GetArtifactsByIDResponse instance
         */
        GetArtifactsByIDResponse.create = function create(properties) {
            return new GetArtifactsByIDResponse(properties);
        };

        /**
         * Encodes the specified GetArtifactsByIDResponse message. Does not implicitly {@link ml_metadata.GetArtifactsByIDResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByIDResponse} message GetArtifactsByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByIDResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifacts != null && message.artifacts.length)
                for (var i = 0; i < message.artifacts.length; ++i)
                    $root.ml_metadata.Artifact.encode(message.artifacts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsByIDResponse message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsByIDResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByIDResponse} message GetArtifactsByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsByIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsByIDResponse} GetArtifactsByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByIDResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsByIDResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifacts && message.artifacts.length))
                        message.artifacts = [];
                    message.artifacts.push($root.ml_metadata.Artifact.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsByIDResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsByIDResponse} GetArtifactsByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByIDResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsByIDResponse message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsByIDResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifacts != null && message.hasOwnProperty("artifacts")) {
                if (!Array.isArray(message.artifacts))
                    return "artifacts: array expected";
                for (var i = 0; i < message.artifacts.length; ++i) {
                    var error = $root.ml_metadata.Artifact.verify(message.artifacts[i]);
                    if (error)
                        return "artifacts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetArtifactsByIDResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsByIDResponse} GetArtifactsByIDResponse
         */
        GetArtifactsByIDResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsByIDResponse)
                return object;
            var message = new $root.ml_metadata.GetArtifactsByIDResponse();
            if (object.artifacts) {
                if (!Array.isArray(object.artifacts))
                    throw TypeError(".ml_metadata.GetArtifactsByIDResponse.artifacts: array expected");
                message.artifacts = [];
                for (var i = 0; i < object.artifacts.length; ++i) {
                    if (typeof object.artifacts[i] !== "object")
                        throw TypeError(".ml_metadata.GetArtifactsByIDResponse.artifacts: object expected");
                    message.artifacts[i] = $root.ml_metadata.Artifact.fromObject(object.artifacts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsByIDResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @static
         * @param {ml_metadata.GetArtifactsByIDResponse} message GetArtifactsByIDResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsByIDResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifacts = [];
            if (message.artifacts && message.artifacts.length) {
                object.artifacts = [];
                for (var j = 0; j < message.artifacts.length; ++j)
                    object.artifacts[j] = $root.ml_metadata.Artifact.toObject(message.artifacts[j], options);
            }
            return object;
        };

        /**
         * Converts this GetArtifactsByIDResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsByIDResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsByIDResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsByIDResponse;
    })();

    ml_metadata.GetArtifactsRequest = (function() {

        /**
         * Properties of a GetArtifactsRequest.
         * @memberof ml_metadata
         * @interface IGetArtifactsRequest
         * @property {ml_metadata.IListOperationOptions|null} [options] GetArtifactsRequest options
         */

        /**
         * Constructs a new GetArtifactsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsRequest.
         * @implements IGetArtifactsRequest
         * @constructor
         * @param {ml_metadata.IGetArtifactsRequest=} [properties] Properties to set
         */
        function GetArtifactsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsRequest options.
         * @member {ml_metadata.IListOperationOptions|null|undefined} options
         * @memberof ml_metadata.GetArtifactsRequest
         * @instance
         */
        GetArtifactsRequest.prototype.options = null;

        /**
         * Creates a new GetArtifactsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsRequest
         * @static
         * @param {ml_metadata.IGetArtifactsRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsRequest} GetArtifactsRequest instance
         */
        GetArtifactsRequest.create = function create(properties) {
            return new GetArtifactsRequest(properties);
        };

        /**
         * Encodes the specified GetArtifactsRequest message. Does not implicitly {@link ml_metadata.GetArtifactsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsRequest
         * @static
         * @param {ml_metadata.IGetArtifactsRequest} message GetArtifactsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.ml_metadata.ListOperationOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsRequest message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsRequest
         * @static
         * @param {ml_metadata.IGetArtifactsRequest} message GetArtifactsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsRequest} GetArtifactsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.options = $root.ml_metadata.ListOperationOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsRequest} GetArtifactsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsRequest message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.ml_metadata.ListOperationOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a GetArtifactsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsRequest} GetArtifactsRequest
         */
        GetArtifactsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsRequest)
                return object;
            var message = new $root.ml_metadata.GetArtifactsRequest();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".ml_metadata.GetArtifactsRequest.options: object expected");
                message.options = $root.ml_metadata.ListOperationOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsRequest
         * @static
         * @param {ml_metadata.GetArtifactsRequest} message GetArtifactsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.options = null;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.ml_metadata.ListOperationOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this GetArtifactsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsRequest;
    })();

    ml_metadata.GetArtifactsResponse = (function() {

        /**
         * Properties of a GetArtifactsResponse.
         * @memberof ml_metadata
         * @interface IGetArtifactsResponse
         * @property {Array.<ml_metadata.IArtifact>|null} [artifacts] GetArtifactsResponse artifacts
         * @property {string|null} [nextPageToken] GetArtifactsResponse nextPageToken
         */

        /**
         * Constructs a new GetArtifactsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsResponse.
         * @implements IGetArtifactsResponse
         * @constructor
         * @param {ml_metadata.IGetArtifactsResponse=} [properties] Properties to set
         */
        function GetArtifactsResponse(properties) {
            this.artifacts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsResponse artifacts.
         * @member {Array.<ml_metadata.IArtifact>} artifacts
         * @memberof ml_metadata.GetArtifactsResponse
         * @instance
         */
        GetArtifactsResponse.prototype.artifacts = $util.emptyArray;

        /**
         * GetArtifactsResponse nextPageToken.
         * @member {string} nextPageToken
         * @memberof ml_metadata.GetArtifactsResponse
         * @instance
         */
        GetArtifactsResponse.prototype.nextPageToken = "";

        /**
         * Creates a new GetArtifactsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsResponse
         * @static
         * @param {ml_metadata.IGetArtifactsResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsResponse} GetArtifactsResponse instance
         */
        GetArtifactsResponse.create = function create(properties) {
            return new GetArtifactsResponse(properties);
        };

        /**
         * Encodes the specified GetArtifactsResponse message. Does not implicitly {@link ml_metadata.GetArtifactsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsResponse
         * @static
         * @param {ml_metadata.IGetArtifactsResponse} message GetArtifactsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifacts != null && message.artifacts.length)
                for (var i = 0; i < message.artifacts.length; ++i)
                    $root.ml_metadata.Artifact.encode(message.artifacts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageToken);
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsResponse message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsResponse
         * @static
         * @param {ml_metadata.IGetArtifactsResponse} message GetArtifactsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsResponse} GetArtifactsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifacts && message.artifacts.length))
                        message.artifacts = [];
                    message.artifacts.push($root.ml_metadata.Artifact.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsResponse} GetArtifactsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsResponse message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifacts != null && message.hasOwnProperty("artifacts")) {
                if (!Array.isArray(message.artifacts))
                    return "artifacts: array expected";
                for (var i = 0; i < message.artifacts.length; ++i) {
                    var error = $root.ml_metadata.Artifact.verify(message.artifacts[i]);
                    if (error)
                        return "artifacts." + error;
                }
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                if (!$util.isString(message.nextPageToken))
                    return "nextPageToken: string expected";
            return null;
        };

        /**
         * Creates a GetArtifactsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsResponse} GetArtifactsResponse
         */
        GetArtifactsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsResponse)
                return object;
            var message = new $root.ml_metadata.GetArtifactsResponse();
            if (object.artifacts) {
                if (!Array.isArray(object.artifacts))
                    throw TypeError(".ml_metadata.GetArtifactsResponse.artifacts: array expected");
                message.artifacts = [];
                for (var i = 0; i < object.artifacts.length; ++i) {
                    if (typeof object.artifacts[i] !== "object")
                        throw TypeError(".ml_metadata.GetArtifactsResponse.artifacts: object expected");
                    message.artifacts[i] = $root.ml_metadata.Artifact.fromObject(object.artifacts[i]);
                }
            }
            if (object.nextPageToken != null)
                message.nextPageToken = String(object.nextPageToken);
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsResponse
         * @static
         * @param {ml_metadata.GetArtifactsResponse} message GetArtifactsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifacts = [];
            if (options.defaults)
                object.nextPageToken = "";
            if (message.artifacts && message.artifacts.length) {
                object.artifacts = [];
                for (var j = 0; j < message.artifacts.length; ++j)
                    object.artifacts[j] = $root.ml_metadata.Artifact.toObject(message.artifacts[j], options);
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                object.nextPageToken = message.nextPageToken;
            return object;
        };

        /**
         * Converts this GetArtifactsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsResponse;
    })();

    ml_metadata.GetArtifactsByURIRequest = (function() {

        /**
         * Properties of a GetArtifactsByURIRequest.
         * @memberof ml_metadata
         * @interface IGetArtifactsByURIRequest
         * @property {Array.<string>|null} [uris] GetArtifactsByURIRequest uris
         */

        /**
         * Constructs a new GetArtifactsByURIRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsByURIRequest.
         * @implements IGetArtifactsByURIRequest
         * @constructor
         * @param {ml_metadata.IGetArtifactsByURIRequest=} [properties] Properties to set
         */
        function GetArtifactsByURIRequest(properties) {
            this.uris = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsByURIRequest uris.
         * @member {Array.<string>} uris
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @instance
         */
        GetArtifactsByURIRequest.prototype.uris = $util.emptyArray;

        /**
         * Creates a new GetArtifactsByURIRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByURIRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsByURIRequest} GetArtifactsByURIRequest instance
         */
        GetArtifactsByURIRequest.create = function create(properties) {
            return new GetArtifactsByURIRequest(properties);
        };

        /**
         * Encodes the specified GetArtifactsByURIRequest message. Does not implicitly {@link ml_metadata.GetArtifactsByURIRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByURIRequest} message GetArtifactsByURIRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByURIRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uris != null && message.uris.length)
                for (var i = 0; i < message.uris.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uris[i]);
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsByURIRequest message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsByURIRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByURIRequest} message GetArtifactsByURIRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByURIRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsByURIRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsByURIRequest} GetArtifactsByURIRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByURIRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsByURIRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.uris && message.uris.length))
                        message.uris = [];
                    message.uris.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsByURIRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsByURIRequest} GetArtifactsByURIRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByURIRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsByURIRequest message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsByURIRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uris != null && message.hasOwnProperty("uris")) {
                if (!Array.isArray(message.uris))
                    return "uris: array expected";
                for (var i = 0; i < message.uris.length; ++i)
                    if (!$util.isString(message.uris[i]))
                        return "uris: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetArtifactsByURIRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsByURIRequest} GetArtifactsByURIRequest
         */
        GetArtifactsByURIRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsByURIRequest)
                return object;
            var message = new $root.ml_metadata.GetArtifactsByURIRequest();
            if (object.uris) {
                if (!Array.isArray(object.uris))
                    throw TypeError(".ml_metadata.GetArtifactsByURIRequest.uris: array expected");
                message.uris = [];
                for (var i = 0; i < object.uris.length; ++i)
                    message.uris[i] = String(object.uris[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsByURIRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @static
         * @param {ml_metadata.GetArtifactsByURIRequest} message GetArtifactsByURIRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsByURIRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.uris = [];
            if (message.uris && message.uris.length) {
                object.uris = [];
                for (var j = 0; j < message.uris.length; ++j)
                    object.uris[j] = message.uris[j];
            }
            return object;
        };

        /**
         * Converts this GetArtifactsByURIRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsByURIRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsByURIRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsByURIRequest;
    })();

    ml_metadata.GetArtifactsByURIResponse = (function() {

        /**
         * Properties of a GetArtifactsByURIResponse.
         * @memberof ml_metadata
         * @interface IGetArtifactsByURIResponse
         * @property {Array.<ml_metadata.IArtifact>|null} [artifacts] GetArtifactsByURIResponse artifacts
         */

        /**
         * Constructs a new GetArtifactsByURIResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsByURIResponse.
         * @implements IGetArtifactsByURIResponse
         * @constructor
         * @param {ml_metadata.IGetArtifactsByURIResponse=} [properties] Properties to set
         */
        function GetArtifactsByURIResponse(properties) {
            this.artifacts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsByURIResponse artifacts.
         * @member {Array.<ml_metadata.IArtifact>} artifacts
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @instance
         */
        GetArtifactsByURIResponse.prototype.artifacts = $util.emptyArray;

        /**
         * Creates a new GetArtifactsByURIResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByURIResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsByURIResponse} GetArtifactsByURIResponse instance
         */
        GetArtifactsByURIResponse.create = function create(properties) {
            return new GetArtifactsByURIResponse(properties);
        };

        /**
         * Encodes the specified GetArtifactsByURIResponse message. Does not implicitly {@link ml_metadata.GetArtifactsByURIResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByURIResponse} message GetArtifactsByURIResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByURIResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifacts != null && message.artifacts.length)
                for (var i = 0; i < message.artifacts.length; ++i)
                    $root.ml_metadata.Artifact.encode(message.artifacts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsByURIResponse message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsByURIResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByURIResponse} message GetArtifactsByURIResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByURIResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsByURIResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsByURIResponse} GetArtifactsByURIResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByURIResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsByURIResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifacts && message.artifacts.length))
                        message.artifacts = [];
                    message.artifacts.push($root.ml_metadata.Artifact.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsByURIResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsByURIResponse} GetArtifactsByURIResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByURIResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsByURIResponse message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsByURIResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifacts != null && message.hasOwnProperty("artifacts")) {
                if (!Array.isArray(message.artifacts))
                    return "artifacts: array expected";
                for (var i = 0; i < message.artifacts.length; ++i) {
                    var error = $root.ml_metadata.Artifact.verify(message.artifacts[i]);
                    if (error)
                        return "artifacts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetArtifactsByURIResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsByURIResponse} GetArtifactsByURIResponse
         */
        GetArtifactsByURIResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsByURIResponse)
                return object;
            var message = new $root.ml_metadata.GetArtifactsByURIResponse();
            if (object.artifacts) {
                if (!Array.isArray(object.artifacts))
                    throw TypeError(".ml_metadata.GetArtifactsByURIResponse.artifacts: array expected");
                message.artifacts = [];
                for (var i = 0; i < object.artifacts.length; ++i) {
                    if (typeof object.artifacts[i] !== "object")
                        throw TypeError(".ml_metadata.GetArtifactsByURIResponse.artifacts: object expected");
                    message.artifacts[i] = $root.ml_metadata.Artifact.fromObject(object.artifacts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsByURIResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @static
         * @param {ml_metadata.GetArtifactsByURIResponse} message GetArtifactsByURIResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsByURIResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifacts = [];
            if (message.artifacts && message.artifacts.length) {
                object.artifacts = [];
                for (var j = 0; j < message.artifacts.length; ++j)
                    object.artifacts[j] = $root.ml_metadata.Artifact.toObject(message.artifacts[j], options);
            }
            return object;
        };

        /**
         * Converts this GetArtifactsByURIResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsByURIResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsByURIResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsByURIResponse;
    })();

    ml_metadata.GetExecutionsRequest = (function() {

        /**
         * Properties of a GetExecutionsRequest.
         * @memberof ml_metadata
         * @interface IGetExecutionsRequest
         * @property {ml_metadata.IListOperationOptions|null} [options] GetExecutionsRequest options
         */

        /**
         * Constructs a new GetExecutionsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionsRequest.
         * @implements IGetExecutionsRequest
         * @constructor
         * @param {ml_metadata.IGetExecutionsRequest=} [properties] Properties to set
         */
        function GetExecutionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionsRequest options.
         * @member {ml_metadata.IListOperationOptions|null|undefined} options
         * @memberof ml_metadata.GetExecutionsRequest
         * @instance
         */
        GetExecutionsRequest.prototype.options = null;

        /**
         * Creates a new GetExecutionsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionsRequest
         * @static
         * @param {ml_metadata.IGetExecutionsRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionsRequest} GetExecutionsRequest instance
         */
        GetExecutionsRequest.create = function create(properties) {
            return new GetExecutionsRequest(properties);
        };

        /**
         * Encodes the specified GetExecutionsRequest message. Does not implicitly {@link ml_metadata.GetExecutionsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionsRequest
         * @static
         * @param {ml_metadata.IGetExecutionsRequest} message GetExecutionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.ml_metadata.ListOperationOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetExecutionsRequest message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionsRequest
         * @static
         * @param {ml_metadata.IGetExecutionsRequest} message GetExecutionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionsRequest} GetExecutionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.options = $root.ml_metadata.ListOperationOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionsRequest} GetExecutionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionsRequest message.
         * @function verify
         * @memberof ml_metadata.GetExecutionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.ml_metadata.ListOperationOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a GetExecutionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionsRequest} GetExecutionsRequest
         */
        GetExecutionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionsRequest)
                return object;
            var message = new $root.ml_metadata.GetExecutionsRequest();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".ml_metadata.GetExecutionsRequest.options: object expected");
                message.options = $root.ml_metadata.ListOperationOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionsRequest
         * @static
         * @param {ml_metadata.GetExecutionsRequest} message GetExecutionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.options = null;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.ml_metadata.ListOperationOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this GetExecutionsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionsRequest;
    })();

    ml_metadata.GetExecutionsResponse = (function() {

        /**
         * Properties of a GetExecutionsResponse.
         * @memberof ml_metadata
         * @interface IGetExecutionsResponse
         * @property {Array.<ml_metadata.IExecution>|null} [executions] GetExecutionsResponse executions
         * @property {string|null} [nextPageToken] GetExecutionsResponse nextPageToken
         */

        /**
         * Constructs a new GetExecutionsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionsResponse.
         * @implements IGetExecutionsResponse
         * @constructor
         * @param {ml_metadata.IGetExecutionsResponse=} [properties] Properties to set
         */
        function GetExecutionsResponse(properties) {
            this.executions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionsResponse executions.
         * @member {Array.<ml_metadata.IExecution>} executions
         * @memberof ml_metadata.GetExecutionsResponse
         * @instance
         */
        GetExecutionsResponse.prototype.executions = $util.emptyArray;

        /**
         * GetExecutionsResponse nextPageToken.
         * @member {string} nextPageToken
         * @memberof ml_metadata.GetExecutionsResponse
         * @instance
         */
        GetExecutionsResponse.prototype.nextPageToken = "";

        /**
         * Creates a new GetExecutionsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionsResponse
         * @static
         * @param {ml_metadata.IGetExecutionsResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionsResponse} GetExecutionsResponse instance
         */
        GetExecutionsResponse.create = function create(properties) {
            return new GetExecutionsResponse(properties);
        };

        /**
         * Encodes the specified GetExecutionsResponse message. Does not implicitly {@link ml_metadata.GetExecutionsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionsResponse
         * @static
         * @param {ml_metadata.IGetExecutionsResponse} message GetExecutionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executions != null && message.executions.length)
                for (var i = 0; i < message.executions.length; ++i)
                    $root.ml_metadata.Execution.encode(message.executions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageToken);
            return writer;
        };

        /**
         * Encodes the specified GetExecutionsResponse message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionsResponse
         * @static
         * @param {ml_metadata.IGetExecutionsResponse} message GetExecutionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionsResponse} GetExecutionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executions && message.executions.length))
                        message.executions = [];
                    message.executions.push($root.ml_metadata.Execution.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionsResponse} GetExecutionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionsResponse message.
         * @function verify
         * @memberof ml_metadata.GetExecutionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executions != null && message.hasOwnProperty("executions")) {
                if (!Array.isArray(message.executions))
                    return "executions: array expected";
                for (var i = 0; i < message.executions.length; ++i) {
                    var error = $root.ml_metadata.Execution.verify(message.executions[i]);
                    if (error)
                        return "executions." + error;
                }
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                if (!$util.isString(message.nextPageToken))
                    return "nextPageToken: string expected";
            return null;
        };

        /**
         * Creates a GetExecutionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionsResponse} GetExecutionsResponse
         */
        GetExecutionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionsResponse)
                return object;
            var message = new $root.ml_metadata.GetExecutionsResponse();
            if (object.executions) {
                if (!Array.isArray(object.executions))
                    throw TypeError(".ml_metadata.GetExecutionsResponse.executions: array expected");
                message.executions = [];
                for (var i = 0; i < object.executions.length; ++i) {
                    if (typeof object.executions[i] !== "object")
                        throw TypeError(".ml_metadata.GetExecutionsResponse.executions: object expected");
                    message.executions[i] = $root.ml_metadata.Execution.fromObject(object.executions[i]);
                }
            }
            if (object.nextPageToken != null)
                message.nextPageToken = String(object.nextPageToken);
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionsResponse
         * @static
         * @param {ml_metadata.GetExecutionsResponse} message GetExecutionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executions = [];
            if (options.defaults)
                object.nextPageToken = "";
            if (message.executions && message.executions.length) {
                object.executions = [];
                for (var j = 0; j < message.executions.length; ++j)
                    object.executions[j] = $root.ml_metadata.Execution.toObject(message.executions[j], options);
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                object.nextPageToken = message.nextPageToken;
            return object;
        };

        /**
         * Converts this GetExecutionsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionsResponse;
    })();

    ml_metadata.GetArtifactTypeRequest = (function() {

        /**
         * Properties of a GetArtifactTypeRequest.
         * @memberof ml_metadata
         * @interface IGetArtifactTypeRequest
         * @property {string|null} [typeName] GetArtifactTypeRequest typeName
         * @property {string|null} [typeVersion] GetArtifactTypeRequest typeVersion
         */

        /**
         * Constructs a new GetArtifactTypeRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactTypeRequest.
         * @implements IGetArtifactTypeRequest
         * @constructor
         * @param {ml_metadata.IGetArtifactTypeRequest=} [properties] Properties to set
         */
        function GetArtifactTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactTypeRequest typeName.
         * @member {string} typeName
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @instance
         */
        GetArtifactTypeRequest.prototype.typeName = "";

        /**
         * GetArtifactTypeRequest typeVersion.
         * @member {string} typeVersion
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @instance
         */
        GetArtifactTypeRequest.prototype.typeVersion = "";

        /**
         * Creates a new GetArtifactTypeRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @static
         * @param {ml_metadata.IGetArtifactTypeRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactTypeRequest} GetArtifactTypeRequest instance
         */
        GetArtifactTypeRequest.create = function create(properties) {
            return new GetArtifactTypeRequest(properties);
        };

        /**
         * Encodes the specified GetArtifactTypeRequest message. Does not implicitly {@link ml_metadata.GetArtifactTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @static
         * @param {ml_metadata.IGetArtifactTypeRequest} message GetArtifactTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeName);
            if (message.typeVersion != null && Object.hasOwnProperty.call(message, "typeVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.typeVersion);
            return writer;
        };

        /**
         * Encodes the specified GetArtifactTypeRequest message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @static
         * @param {ml_metadata.IGetArtifactTypeRequest} message GetArtifactTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactTypeRequest} GetArtifactTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 2:
                    message.typeVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactTypeRequest} GetArtifactTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactTypeRequest message.
         * @function verify
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                if (!$util.isString(message.typeVersion))
                    return "typeVersion: string expected";
            return null;
        };

        /**
         * Creates a GetArtifactTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactTypeRequest} GetArtifactTypeRequest
         */
        GetArtifactTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactTypeRequest)
                return object;
            var message = new $root.ml_metadata.GetArtifactTypeRequest();
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            if (object.typeVersion != null)
                message.typeVersion = String(object.typeVersion);
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @static
         * @param {ml_metadata.GetArtifactTypeRequest} message GetArtifactTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeName = "";
                object.typeVersion = "";
            }
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                object.typeVersion = message.typeVersion;
            return object;
        };

        /**
         * Converts this GetArtifactTypeRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactTypeRequest;
    })();

    ml_metadata.GetArtifactTypeResponse = (function() {

        /**
         * Properties of a GetArtifactTypeResponse.
         * @memberof ml_metadata
         * @interface IGetArtifactTypeResponse
         * @property {ml_metadata.IArtifactType|null} [artifactType] GetArtifactTypeResponse artifactType
         */

        /**
         * Constructs a new GetArtifactTypeResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactTypeResponse.
         * @implements IGetArtifactTypeResponse
         * @constructor
         * @param {ml_metadata.IGetArtifactTypeResponse=} [properties] Properties to set
         */
        function GetArtifactTypeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactTypeResponse artifactType.
         * @member {ml_metadata.IArtifactType|null|undefined} artifactType
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @instance
         */
        GetArtifactTypeResponse.prototype.artifactType = null;

        /**
         * Creates a new GetArtifactTypeResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @static
         * @param {ml_metadata.IGetArtifactTypeResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactTypeResponse} GetArtifactTypeResponse instance
         */
        GetArtifactTypeResponse.create = function create(properties) {
            return new GetArtifactTypeResponse(properties);
        };

        /**
         * Encodes the specified GetArtifactTypeResponse message. Does not implicitly {@link ml_metadata.GetArtifactTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @static
         * @param {ml_metadata.IGetArtifactTypeResponse} message GetArtifactTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactType != null && Object.hasOwnProperty.call(message, "artifactType"))
                $root.ml_metadata.ArtifactType.encode(message.artifactType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactTypeResponse message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @static
         * @param {ml_metadata.IGetArtifactTypeResponse} message GetArtifactTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactTypeResponse} GetArtifactTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.artifactType = $root.ml_metadata.ArtifactType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactTypeResponse} GetArtifactTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactTypeResponse message.
         * @function verify
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactType != null && message.hasOwnProperty("artifactType")) {
                var error = $root.ml_metadata.ArtifactType.verify(message.artifactType);
                if (error)
                    return "artifactType." + error;
            }
            return null;
        };

        /**
         * Creates a GetArtifactTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactTypeResponse} GetArtifactTypeResponse
         */
        GetArtifactTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactTypeResponse)
                return object;
            var message = new $root.ml_metadata.GetArtifactTypeResponse();
            if (object.artifactType != null) {
                if (typeof object.artifactType !== "object")
                    throw TypeError(".ml_metadata.GetArtifactTypeResponse.artifactType: object expected");
                message.artifactType = $root.ml_metadata.ArtifactType.fromObject(object.artifactType);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @static
         * @param {ml_metadata.GetArtifactTypeResponse} message GetArtifactTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.artifactType = null;
            if (message.artifactType != null && message.hasOwnProperty("artifactType"))
                object.artifactType = $root.ml_metadata.ArtifactType.toObject(message.artifactType, options);
            return object;
        };

        /**
         * Converts this GetArtifactTypeResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactTypeResponse;
    })();

    ml_metadata.GetArtifactTypesRequest = (function() {

        /**
         * Properties of a GetArtifactTypesRequest.
         * @memberof ml_metadata
         * @interface IGetArtifactTypesRequest
         */

        /**
         * Constructs a new GetArtifactTypesRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactTypesRequest.
         * @implements IGetArtifactTypesRequest
         * @constructor
         * @param {ml_metadata.IGetArtifactTypesRequest=} [properties] Properties to set
         */
        function GetArtifactTypesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetArtifactTypesRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactTypesRequest
         * @static
         * @param {ml_metadata.IGetArtifactTypesRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactTypesRequest} GetArtifactTypesRequest instance
         */
        GetArtifactTypesRequest.create = function create(properties) {
            return new GetArtifactTypesRequest(properties);
        };

        /**
         * Encodes the specified GetArtifactTypesRequest message. Does not implicitly {@link ml_metadata.GetArtifactTypesRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactTypesRequest
         * @static
         * @param {ml_metadata.IGetArtifactTypesRequest} message GetArtifactTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactTypesRequest message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactTypesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactTypesRequest
         * @static
         * @param {ml_metadata.IGetArtifactTypesRequest} message GetArtifactTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactTypesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactTypesRequest} GetArtifactTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactTypesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactTypesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactTypesRequest} GetArtifactTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactTypesRequest message.
         * @function verify
         * @memberof ml_metadata.GetArtifactTypesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactTypesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetArtifactTypesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactTypesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactTypesRequest} GetArtifactTypesRequest
         */
        GetArtifactTypesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactTypesRequest)
                return object;
            return new $root.ml_metadata.GetArtifactTypesRequest();
        };

        /**
         * Creates a plain object from a GetArtifactTypesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactTypesRequest
         * @static
         * @param {ml_metadata.GetArtifactTypesRequest} message GetArtifactTypesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactTypesRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetArtifactTypesRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactTypesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactTypesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactTypesRequest;
    })();

    ml_metadata.GetArtifactTypesResponse = (function() {

        /**
         * Properties of a GetArtifactTypesResponse.
         * @memberof ml_metadata
         * @interface IGetArtifactTypesResponse
         * @property {Array.<ml_metadata.IArtifactType>|null} [artifactTypes] GetArtifactTypesResponse artifactTypes
         */

        /**
         * Constructs a new GetArtifactTypesResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactTypesResponse.
         * @implements IGetArtifactTypesResponse
         * @constructor
         * @param {ml_metadata.IGetArtifactTypesResponse=} [properties] Properties to set
         */
        function GetArtifactTypesResponse(properties) {
            this.artifactTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactTypesResponse artifactTypes.
         * @member {Array.<ml_metadata.IArtifactType>} artifactTypes
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @instance
         */
        GetArtifactTypesResponse.prototype.artifactTypes = $util.emptyArray;

        /**
         * Creates a new GetArtifactTypesResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @static
         * @param {ml_metadata.IGetArtifactTypesResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactTypesResponse} GetArtifactTypesResponse instance
         */
        GetArtifactTypesResponse.create = function create(properties) {
            return new GetArtifactTypesResponse(properties);
        };

        /**
         * Encodes the specified GetArtifactTypesResponse message. Does not implicitly {@link ml_metadata.GetArtifactTypesResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @static
         * @param {ml_metadata.IGetArtifactTypesResponse} message GetArtifactTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactTypes != null && message.artifactTypes.length)
                for (var i = 0; i < message.artifactTypes.length; ++i)
                    $root.ml_metadata.ArtifactType.encode(message.artifactTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactTypesResponse message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactTypesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @static
         * @param {ml_metadata.IGetArtifactTypesResponse} message GetArtifactTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactTypesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactTypesResponse} GetArtifactTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactTypesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifactTypes && message.artifactTypes.length))
                        message.artifactTypes = [];
                    message.artifactTypes.push($root.ml_metadata.ArtifactType.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactTypesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactTypesResponse} GetArtifactTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactTypesResponse message.
         * @function verify
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactTypesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactTypes != null && message.hasOwnProperty("artifactTypes")) {
                if (!Array.isArray(message.artifactTypes))
                    return "artifactTypes: array expected";
                for (var i = 0; i < message.artifactTypes.length; ++i) {
                    var error = $root.ml_metadata.ArtifactType.verify(message.artifactTypes[i]);
                    if (error)
                        return "artifactTypes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetArtifactTypesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactTypesResponse} GetArtifactTypesResponse
         */
        GetArtifactTypesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactTypesResponse)
                return object;
            var message = new $root.ml_metadata.GetArtifactTypesResponse();
            if (object.artifactTypes) {
                if (!Array.isArray(object.artifactTypes))
                    throw TypeError(".ml_metadata.GetArtifactTypesResponse.artifactTypes: array expected");
                message.artifactTypes = [];
                for (var i = 0; i < object.artifactTypes.length; ++i) {
                    if (typeof object.artifactTypes[i] !== "object")
                        throw TypeError(".ml_metadata.GetArtifactTypesResponse.artifactTypes: object expected");
                    message.artifactTypes[i] = $root.ml_metadata.ArtifactType.fromObject(object.artifactTypes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactTypesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @static
         * @param {ml_metadata.GetArtifactTypesResponse} message GetArtifactTypesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactTypesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifactTypes = [];
            if (message.artifactTypes && message.artifactTypes.length) {
                object.artifactTypes = [];
                for (var j = 0; j < message.artifactTypes.length; ++j)
                    object.artifactTypes[j] = $root.ml_metadata.ArtifactType.toObject(message.artifactTypes[j], options);
            }
            return object;
        };

        /**
         * Converts this GetArtifactTypesResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactTypesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactTypesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactTypesResponse;
    })();

    ml_metadata.GetExecutionTypesRequest = (function() {

        /**
         * Properties of a GetExecutionTypesRequest.
         * @memberof ml_metadata
         * @interface IGetExecutionTypesRequest
         */

        /**
         * Constructs a new GetExecutionTypesRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionTypesRequest.
         * @implements IGetExecutionTypesRequest
         * @constructor
         * @param {ml_metadata.IGetExecutionTypesRequest=} [properties] Properties to set
         */
        function GetExecutionTypesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetExecutionTypesRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionTypesRequest
         * @static
         * @param {ml_metadata.IGetExecutionTypesRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionTypesRequest} GetExecutionTypesRequest instance
         */
        GetExecutionTypesRequest.create = function create(properties) {
            return new GetExecutionTypesRequest(properties);
        };

        /**
         * Encodes the specified GetExecutionTypesRequest message. Does not implicitly {@link ml_metadata.GetExecutionTypesRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionTypesRequest
         * @static
         * @param {ml_metadata.IGetExecutionTypesRequest} message GetExecutionTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetExecutionTypesRequest message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionTypesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionTypesRequest
         * @static
         * @param {ml_metadata.IGetExecutionTypesRequest} message GetExecutionTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionTypesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionTypesRequest} GetExecutionTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionTypesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionTypesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionTypesRequest} GetExecutionTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionTypesRequest message.
         * @function verify
         * @memberof ml_metadata.GetExecutionTypesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionTypesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetExecutionTypesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionTypesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionTypesRequest} GetExecutionTypesRequest
         */
        GetExecutionTypesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionTypesRequest)
                return object;
            return new $root.ml_metadata.GetExecutionTypesRequest();
        };

        /**
         * Creates a plain object from a GetExecutionTypesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionTypesRequest
         * @static
         * @param {ml_metadata.GetExecutionTypesRequest} message GetExecutionTypesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionTypesRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetExecutionTypesRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionTypesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionTypesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionTypesRequest;
    })();

    ml_metadata.GetExecutionTypesResponse = (function() {

        /**
         * Properties of a GetExecutionTypesResponse.
         * @memberof ml_metadata
         * @interface IGetExecutionTypesResponse
         * @property {Array.<ml_metadata.IExecutionType>|null} [executionTypes] GetExecutionTypesResponse executionTypes
         */

        /**
         * Constructs a new GetExecutionTypesResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionTypesResponse.
         * @implements IGetExecutionTypesResponse
         * @constructor
         * @param {ml_metadata.IGetExecutionTypesResponse=} [properties] Properties to set
         */
        function GetExecutionTypesResponse(properties) {
            this.executionTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionTypesResponse executionTypes.
         * @member {Array.<ml_metadata.IExecutionType>} executionTypes
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @instance
         */
        GetExecutionTypesResponse.prototype.executionTypes = $util.emptyArray;

        /**
         * Creates a new GetExecutionTypesResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @static
         * @param {ml_metadata.IGetExecutionTypesResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionTypesResponse} GetExecutionTypesResponse instance
         */
        GetExecutionTypesResponse.create = function create(properties) {
            return new GetExecutionTypesResponse(properties);
        };

        /**
         * Encodes the specified GetExecutionTypesResponse message. Does not implicitly {@link ml_metadata.GetExecutionTypesResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @static
         * @param {ml_metadata.IGetExecutionTypesResponse} message GetExecutionTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionTypes != null && message.executionTypes.length)
                for (var i = 0; i < message.executionTypes.length; ++i)
                    $root.ml_metadata.ExecutionType.encode(message.executionTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetExecutionTypesResponse message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionTypesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @static
         * @param {ml_metadata.IGetExecutionTypesResponse} message GetExecutionTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionTypesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionTypesResponse} GetExecutionTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionTypesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executionTypes && message.executionTypes.length))
                        message.executionTypes = [];
                    message.executionTypes.push($root.ml_metadata.ExecutionType.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionTypesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionTypesResponse} GetExecutionTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionTypesResponse message.
         * @function verify
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionTypesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionTypes != null && message.hasOwnProperty("executionTypes")) {
                if (!Array.isArray(message.executionTypes))
                    return "executionTypes: array expected";
                for (var i = 0; i < message.executionTypes.length; ++i) {
                    var error = $root.ml_metadata.ExecutionType.verify(message.executionTypes[i]);
                    if (error)
                        return "executionTypes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetExecutionTypesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionTypesResponse} GetExecutionTypesResponse
         */
        GetExecutionTypesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionTypesResponse)
                return object;
            var message = new $root.ml_metadata.GetExecutionTypesResponse();
            if (object.executionTypes) {
                if (!Array.isArray(object.executionTypes))
                    throw TypeError(".ml_metadata.GetExecutionTypesResponse.executionTypes: array expected");
                message.executionTypes = [];
                for (var i = 0; i < object.executionTypes.length; ++i) {
                    if (typeof object.executionTypes[i] !== "object")
                        throw TypeError(".ml_metadata.GetExecutionTypesResponse.executionTypes: object expected");
                    message.executionTypes[i] = $root.ml_metadata.ExecutionType.fromObject(object.executionTypes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionTypesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @static
         * @param {ml_metadata.GetExecutionTypesResponse} message GetExecutionTypesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionTypesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executionTypes = [];
            if (message.executionTypes && message.executionTypes.length) {
                object.executionTypes = [];
                for (var j = 0; j < message.executionTypes.length; ++j)
                    object.executionTypes[j] = $root.ml_metadata.ExecutionType.toObject(message.executionTypes[j], options);
            }
            return object;
        };

        /**
         * Converts this GetExecutionTypesResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionTypesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionTypesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionTypesResponse;
    })();

    ml_metadata.GetContextTypesRequest = (function() {

        /**
         * Properties of a GetContextTypesRequest.
         * @memberof ml_metadata
         * @interface IGetContextTypesRequest
         */

        /**
         * Constructs a new GetContextTypesRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextTypesRequest.
         * @implements IGetContextTypesRequest
         * @constructor
         * @param {ml_metadata.IGetContextTypesRequest=} [properties] Properties to set
         */
        function GetContextTypesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetContextTypesRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextTypesRequest
         * @static
         * @param {ml_metadata.IGetContextTypesRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetContextTypesRequest} GetContextTypesRequest instance
         */
        GetContextTypesRequest.create = function create(properties) {
            return new GetContextTypesRequest(properties);
        };

        /**
         * Encodes the specified GetContextTypesRequest message. Does not implicitly {@link ml_metadata.GetContextTypesRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextTypesRequest
         * @static
         * @param {ml_metadata.IGetContextTypesRequest} message GetContextTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetContextTypesRequest message, length delimited. Does not implicitly {@link ml_metadata.GetContextTypesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextTypesRequest
         * @static
         * @param {ml_metadata.IGetContextTypesRequest} message GetContextTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextTypesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextTypesRequest} GetContextTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextTypesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextTypesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextTypesRequest} GetContextTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextTypesRequest message.
         * @function verify
         * @memberof ml_metadata.GetContextTypesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextTypesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetContextTypesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextTypesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextTypesRequest} GetContextTypesRequest
         */
        GetContextTypesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextTypesRequest)
                return object;
            return new $root.ml_metadata.GetContextTypesRequest();
        };

        /**
         * Creates a plain object from a GetContextTypesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextTypesRequest
         * @static
         * @param {ml_metadata.GetContextTypesRequest} message GetContextTypesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextTypesRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetContextTypesRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextTypesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextTypesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextTypesRequest;
    })();

    ml_metadata.GetContextTypesResponse = (function() {

        /**
         * Properties of a GetContextTypesResponse.
         * @memberof ml_metadata
         * @interface IGetContextTypesResponse
         * @property {Array.<ml_metadata.IContextType>|null} [contextTypes] GetContextTypesResponse contextTypes
         */

        /**
         * Constructs a new GetContextTypesResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextTypesResponse.
         * @implements IGetContextTypesResponse
         * @constructor
         * @param {ml_metadata.IGetContextTypesResponse=} [properties] Properties to set
         */
        function GetContextTypesResponse(properties) {
            this.contextTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextTypesResponse contextTypes.
         * @member {Array.<ml_metadata.IContextType>} contextTypes
         * @memberof ml_metadata.GetContextTypesResponse
         * @instance
         */
        GetContextTypesResponse.prototype.contextTypes = $util.emptyArray;

        /**
         * Creates a new GetContextTypesResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextTypesResponse
         * @static
         * @param {ml_metadata.IGetContextTypesResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetContextTypesResponse} GetContextTypesResponse instance
         */
        GetContextTypesResponse.create = function create(properties) {
            return new GetContextTypesResponse(properties);
        };

        /**
         * Encodes the specified GetContextTypesResponse message. Does not implicitly {@link ml_metadata.GetContextTypesResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextTypesResponse
         * @static
         * @param {ml_metadata.IGetContextTypesResponse} message GetContextTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextTypes != null && message.contextTypes.length)
                for (var i = 0; i < message.contextTypes.length; ++i)
                    $root.ml_metadata.ContextType.encode(message.contextTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetContextTypesResponse message, length delimited. Does not implicitly {@link ml_metadata.GetContextTypesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextTypesResponse
         * @static
         * @param {ml_metadata.IGetContextTypesResponse} message GetContextTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextTypesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextTypesResponse} GetContextTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextTypesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contextTypes && message.contextTypes.length))
                        message.contextTypes = [];
                    message.contextTypes.push($root.ml_metadata.ContextType.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextTypesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextTypesResponse} GetContextTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextTypesResponse message.
         * @function verify
         * @memberof ml_metadata.GetContextTypesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextTypesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextTypes != null && message.hasOwnProperty("contextTypes")) {
                if (!Array.isArray(message.contextTypes))
                    return "contextTypes: array expected";
                for (var i = 0; i < message.contextTypes.length; ++i) {
                    var error = $root.ml_metadata.ContextType.verify(message.contextTypes[i]);
                    if (error)
                        return "contextTypes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetContextTypesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextTypesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextTypesResponse} GetContextTypesResponse
         */
        GetContextTypesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextTypesResponse)
                return object;
            var message = new $root.ml_metadata.GetContextTypesResponse();
            if (object.contextTypes) {
                if (!Array.isArray(object.contextTypes))
                    throw TypeError(".ml_metadata.GetContextTypesResponse.contextTypes: array expected");
                message.contextTypes = [];
                for (var i = 0; i < object.contextTypes.length; ++i) {
                    if (typeof object.contextTypes[i] !== "object")
                        throw TypeError(".ml_metadata.GetContextTypesResponse.contextTypes: object expected");
                    message.contextTypes[i] = $root.ml_metadata.ContextType.fromObject(object.contextTypes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextTypesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextTypesResponse
         * @static
         * @param {ml_metadata.GetContextTypesResponse} message GetContextTypesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextTypesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contextTypes = [];
            if (message.contextTypes && message.contextTypes.length) {
                object.contextTypes = [];
                for (var j = 0; j < message.contextTypes.length; ++j)
                    object.contextTypes[j] = $root.ml_metadata.ContextType.toObject(message.contextTypes[j], options);
            }
            return object;
        };

        /**
         * Converts this GetContextTypesResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextTypesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextTypesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextTypesResponse;
    })();

    ml_metadata.GetExecutionsByTypeRequest = (function() {

        /**
         * Properties of a GetExecutionsByTypeRequest.
         * @memberof ml_metadata
         * @interface IGetExecutionsByTypeRequest
         * @property {string|null} [typeName] GetExecutionsByTypeRequest typeName
         * @property {string|null} [typeVersion] GetExecutionsByTypeRequest typeVersion
         */

        /**
         * Constructs a new GetExecutionsByTypeRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionsByTypeRequest.
         * @implements IGetExecutionsByTypeRequest
         * @constructor
         * @param {ml_metadata.IGetExecutionsByTypeRequest=} [properties] Properties to set
         */
        function GetExecutionsByTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionsByTypeRequest typeName.
         * @member {string} typeName
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @instance
         */
        GetExecutionsByTypeRequest.prototype.typeName = "";

        /**
         * GetExecutionsByTypeRequest typeVersion.
         * @member {string} typeVersion
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @instance
         */
        GetExecutionsByTypeRequest.prototype.typeVersion = "";

        /**
         * Creates a new GetExecutionsByTypeRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @static
         * @param {ml_metadata.IGetExecutionsByTypeRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionsByTypeRequest} GetExecutionsByTypeRequest instance
         */
        GetExecutionsByTypeRequest.create = function create(properties) {
            return new GetExecutionsByTypeRequest(properties);
        };

        /**
         * Encodes the specified GetExecutionsByTypeRequest message. Does not implicitly {@link ml_metadata.GetExecutionsByTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @static
         * @param {ml_metadata.IGetExecutionsByTypeRequest} message GetExecutionsByTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeName);
            if (message.typeVersion != null && Object.hasOwnProperty.call(message, "typeVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.typeVersion);
            return writer;
        };

        /**
         * Encodes the specified GetExecutionsByTypeRequest message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionsByTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @static
         * @param {ml_metadata.IGetExecutionsByTypeRequest} message GetExecutionsByTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionsByTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionsByTypeRequest} GetExecutionsByTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionsByTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 2:
                    message.typeVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionsByTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionsByTypeRequest} GetExecutionsByTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionsByTypeRequest message.
         * @function verify
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionsByTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                if (!$util.isString(message.typeVersion))
                    return "typeVersion: string expected";
            return null;
        };

        /**
         * Creates a GetExecutionsByTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionsByTypeRequest} GetExecutionsByTypeRequest
         */
        GetExecutionsByTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionsByTypeRequest)
                return object;
            var message = new $root.ml_metadata.GetExecutionsByTypeRequest();
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            if (object.typeVersion != null)
                message.typeVersion = String(object.typeVersion);
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionsByTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @static
         * @param {ml_metadata.GetExecutionsByTypeRequest} message GetExecutionsByTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionsByTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeName = "";
                object.typeVersion = "";
            }
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                object.typeVersion = message.typeVersion;
            return object;
        };

        /**
         * Converts this GetExecutionsByTypeRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionsByTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionsByTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionsByTypeRequest;
    })();

    ml_metadata.GetExecutionsByTypeResponse = (function() {

        /**
         * Properties of a GetExecutionsByTypeResponse.
         * @memberof ml_metadata
         * @interface IGetExecutionsByTypeResponse
         * @property {Array.<ml_metadata.IExecution>|null} [executions] GetExecutionsByTypeResponse executions
         */

        /**
         * Constructs a new GetExecutionsByTypeResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionsByTypeResponse.
         * @implements IGetExecutionsByTypeResponse
         * @constructor
         * @param {ml_metadata.IGetExecutionsByTypeResponse=} [properties] Properties to set
         */
        function GetExecutionsByTypeResponse(properties) {
            this.executions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionsByTypeResponse executions.
         * @member {Array.<ml_metadata.IExecution>} executions
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @instance
         */
        GetExecutionsByTypeResponse.prototype.executions = $util.emptyArray;

        /**
         * Creates a new GetExecutionsByTypeResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @static
         * @param {ml_metadata.IGetExecutionsByTypeResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionsByTypeResponse} GetExecutionsByTypeResponse instance
         */
        GetExecutionsByTypeResponse.create = function create(properties) {
            return new GetExecutionsByTypeResponse(properties);
        };

        /**
         * Encodes the specified GetExecutionsByTypeResponse message. Does not implicitly {@link ml_metadata.GetExecutionsByTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @static
         * @param {ml_metadata.IGetExecutionsByTypeResponse} message GetExecutionsByTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executions != null && message.executions.length)
                for (var i = 0; i < message.executions.length; ++i)
                    $root.ml_metadata.Execution.encode(message.executions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetExecutionsByTypeResponse message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionsByTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @static
         * @param {ml_metadata.IGetExecutionsByTypeResponse} message GetExecutionsByTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionsByTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionsByTypeResponse} GetExecutionsByTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionsByTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executions && message.executions.length))
                        message.executions = [];
                    message.executions.push($root.ml_metadata.Execution.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionsByTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionsByTypeResponse} GetExecutionsByTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionsByTypeResponse message.
         * @function verify
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionsByTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executions != null && message.hasOwnProperty("executions")) {
                if (!Array.isArray(message.executions))
                    return "executions: array expected";
                for (var i = 0; i < message.executions.length; ++i) {
                    var error = $root.ml_metadata.Execution.verify(message.executions[i]);
                    if (error)
                        return "executions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetExecutionsByTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionsByTypeResponse} GetExecutionsByTypeResponse
         */
        GetExecutionsByTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionsByTypeResponse)
                return object;
            var message = new $root.ml_metadata.GetExecutionsByTypeResponse();
            if (object.executions) {
                if (!Array.isArray(object.executions))
                    throw TypeError(".ml_metadata.GetExecutionsByTypeResponse.executions: array expected");
                message.executions = [];
                for (var i = 0; i < object.executions.length; ++i) {
                    if (typeof object.executions[i] !== "object")
                        throw TypeError(".ml_metadata.GetExecutionsByTypeResponse.executions: object expected");
                    message.executions[i] = $root.ml_metadata.Execution.fromObject(object.executions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionsByTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @static
         * @param {ml_metadata.GetExecutionsByTypeResponse} message GetExecutionsByTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionsByTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executions = [];
            if (message.executions && message.executions.length) {
                object.executions = [];
                for (var j = 0; j < message.executions.length; ++j)
                    object.executions[j] = $root.ml_metadata.Execution.toObject(message.executions[j], options);
            }
            return object;
        };

        /**
         * Converts this GetExecutionsByTypeResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionsByTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionsByTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionsByTypeResponse;
    })();

    ml_metadata.GetExecutionByTypeAndNameRequest = (function() {

        /**
         * Properties of a GetExecutionByTypeAndNameRequest.
         * @memberof ml_metadata
         * @interface IGetExecutionByTypeAndNameRequest
         * @property {string|null} [typeName] GetExecutionByTypeAndNameRequest typeName
         * @property {string|null} [typeVersion] GetExecutionByTypeAndNameRequest typeVersion
         * @property {string|null} [executionName] GetExecutionByTypeAndNameRequest executionName
         */

        /**
         * Constructs a new GetExecutionByTypeAndNameRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionByTypeAndNameRequest.
         * @implements IGetExecutionByTypeAndNameRequest
         * @constructor
         * @param {ml_metadata.IGetExecutionByTypeAndNameRequest=} [properties] Properties to set
         */
        function GetExecutionByTypeAndNameRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionByTypeAndNameRequest typeName.
         * @member {string} typeName
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @instance
         */
        GetExecutionByTypeAndNameRequest.prototype.typeName = "";

        /**
         * GetExecutionByTypeAndNameRequest typeVersion.
         * @member {string} typeVersion
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @instance
         */
        GetExecutionByTypeAndNameRequest.prototype.typeVersion = "";

        /**
         * GetExecutionByTypeAndNameRequest executionName.
         * @member {string} executionName
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @instance
         */
        GetExecutionByTypeAndNameRequest.prototype.executionName = "";

        /**
         * Creates a new GetExecutionByTypeAndNameRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @static
         * @param {ml_metadata.IGetExecutionByTypeAndNameRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionByTypeAndNameRequest} GetExecutionByTypeAndNameRequest instance
         */
        GetExecutionByTypeAndNameRequest.create = function create(properties) {
            return new GetExecutionByTypeAndNameRequest(properties);
        };

        /**
         * Encodes the specified GetExecutionByTypeAndNameRequest message. Does not implicitly {@link ml_metadata.GetExecutionByTypeAndNameRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @static
         * @param {ml_metadata.IGetExecutionByTypeAndNameRequest} message GetExecutionByTypeAndNameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionByTypeAndNameRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeName);
            if (message.executionName != null && Object.hasOwnProperty.call(message, "executionName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.executionName);
            if (message.typeVersion != null && Object.hasOwnProperty.call(message, "typeVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.typeVersion);
            return writer;
        };

        /**
         * Encodes the specified GetExecutionByTypeAndNameRequest message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionByTypeAndNameRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @static
         * @param {ml_metadata.IGetExecutionByTypeAndNameRequest} message GetExecutionByTypeAndNameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionByTypeAndNameRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionByTypeAndNameRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionByTypeAndNameRequest} GetExecutionByTypeAndNameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionByTypeAndNameRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionByTypeAndNameRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 3:
                    message.typeVersion = reader.string();
                    break;
                case 2:
                    message.executionName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionByTypeAndNameRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionByTypeAndNameRequest} GetExecutionByTypeAndNameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionByTypeAndNameRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionByTypeAndNameRequest message.
         * @function verify
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionByTypeAndNameRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                if (!$util.isString(message.typeVersion))
                    return "typeVersion: string expected";
            if (message.executionName != null && message.hasOwnProperty("executionName"))
                if (!$util.isString(message.executionName))
                    return "executionName: string expected";
            return null;
        };

        /**
         * Creates a GetExecutionByTypeAndNameRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionByTypeAndNameRequest} GetExecutionByTypeAndNameRequest
         */
        GetExecutionByTypeAndNameRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionByTypeAndNameRequest)
                return object;
            var message = new $root.ml_metadata.GetExecutionByTypeAndNameRequest();
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            if (object.typeVersion != null)
                message.typeVersion = String(object.typeVersion);
            if (object.executionName != null)
                message.executionName = String(object.executionName);
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionByTypeAndNameRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @static
         * @param {ml_metadata.GetExecutionByTypeAndNameRequest} message GetExecutionByTypeAndNameRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionByTypeAndNameRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeName = "";
                object.executionName = "";
                object.typeVersion = "";
            }
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            if (message.executionName != null && message.hasOwnProperty("executionName"))
                object.executionName = message.executionName;
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                object.typeVersion = message.typeVersion;
            return object;
        };

        /**
         * Converts this GetExecutionByTypeAndNameRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionByTypeAndNameRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionByTypeAndNameRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionByTypeAndNameRequest;
    })();

    ml_metadata.GetExecutionByTypeAndNameResponse = (function() {

        /**
         * Properties of a GetExecutionByTypeAndNameResponse.
         * @memberof ml_metadata
         * @interface IGetExecutionByTypeAndNameResponse
         * @property {ml_metadata.IExecution|null} [execution] GetExecutionByTypeAndNameResponse execution
         */

        /**
         * Constructs a new GetExecutionByTypeAndNameResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionByTypeAndNameResponse.
         * @implements IGetExecutionByTypeAndNameResponse
         * @constructor
         * @param {ml_metadata.IGetExecutionByTypeAndNameResponse=} [properties] Properties to set
         */
        function GetExecutionByTypeAndNameResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionByTypeAndNameResponse execution.
         * @member {ml_metadata.IExecution|null|undefined} execution
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @instance
         */
        GetExecutionByTypeAndNameResponse.prototype.execution = null;

        /**
         * Creates a new GetExecutionByTypeAndNameResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @static
         * @param {ml_metadata.IGetExecutionByTypeAndNameResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionByTypeAndNameResponse} GetExecutionByTypeAndNameResponse instance
         */
        GetExecutionByTypeAndNameResponse.create = function create(properties) {
            return new GetExecutionByTypeAndNameResponse(properties);
        };

        /**
         * Encodes the specified GetExecutionByTypeAndNameResponse message. Does not implicitly {@link ml_metadata.GetExecutionByTypeAndNameResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @static
         * @param {ml_metadata.IGetExecutionByTypeAndNameResponse} message GetExecutionByTypeAndNameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionByTypeAndNameResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.execution != null && Object.hasOwnProperty.call(message, "execution"))
                $root.ml_metadata.Execution.encode(message.execution, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetExecutionByTypeAndNameResponse message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionByTypeAndNameResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @static
         * @param {ml_metadata.IGetExecutionByTypeAndNameResponse} message GetExecutionByTypeAndNameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionByTypeAndNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionByTypeAndNameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionByTypeAndNameResponse} GetExecutionByTypeAndNameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionByTypeAndNameResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionByTypeAndNameResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.execution = $root.ml_metadata.Execution.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionByTypeAndNameResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionByTypeAndNameResponse} GetExecutionByTypeAndNameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionByTypeAndNameResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionByTypeAndNameResponse message.
         * @function verify
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionByTypeAndNameResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.execution != null && message.hasOwnProperty("execution")) {
                var error = $root.ml_metadata.Execution.verify(message.execution);
                if (error)
                    return "execution." + error;
            }
            return null;
        };

        /**
         * Creates a GetExecutionByTypeAndNameResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionByTypeAndNameResponse} GetExecutionByTypeAndNameResponse
         */
        GetExecutionByTypeAndNameResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionByTypeAndNameResponse)
                return object;
            var message = new $root.ml_metadata.GetExecutionByTypeAndNameResponse();
            if (object.execution != null) {
                if (typeof object.execution !== "object")
                    throw TypeError(".ml_metadata.GetExecutionByTypeAndNameResponse.execution: object expected");
                message.execution = $root.ml_metadata.Execution.fromObject(object.execution);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionByTypeAndNameResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @static
         * @param {ml_metadata.GetExecutionByTypeAndNameResponse} message GetExecutionByTypeAndNameResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionByTypeAndNameResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.execution = null;
            if (message.execution != null && message.hasOwnProperty("execution"))
                object.execution = $root.ml_metadata.Execution.toObject(message.execution, options);
            return object;
        };

        /**
         * Converts this GetExecutionByTypeAndNameResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionByTypeAndNameResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionByTypeAndNameResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionByTypeAndNameResponse;
    })();

    ml_metadata.GetExecutionsByIDRequest = (function() {

        /**
         * Properties of a GetExecutionsByIDRequest.
         * @memberof ml_metadata
         * @interface IGetExecutionsByIDRequest
         * @property {Array.<number|Long>|null} [executionIds] GetExecutionsByIDRequest executionIds
         */

        /**
         * Constructs a new GetExecutionsByIDRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionsByIDRequest.
         * @implements IGetExecutionsByIDRequest
         * @constructor
         * @param {ml_metadata.IGetExecutionsByIDRequest=} [properties] Properties to set
         */
        function GetExecutionsByIDRequest(properties) {
            this.executionIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionsByIDRequest executionIds.
         * @member {Array.<number|Long>} executionIds
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @instance
         */
        GetExecutionsByIDRequest.prototype.executionIds = $util.emptyArray;

        /**
         * Creates a new GetExecutionsByIDRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @static
         * @param {ml_metadata.IGetExecutionsByIDRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionsByIDRequest} GetExecutionsByIDRequest instance
         */
        GetExecutionsByIDRequest.create = function create(properties) {
            return new GetExecutionsByIDRequest(properties);
        };

        /**
         * Encodes the specified GetExecutionsByIDRequest message. Does not implicitly {@link ml_metadata.GetExecutionsByIDRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @static
         * @param {ml_metadata.IGetExecutionsByIDRequest} message GetExecutionsByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByIDRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionIds != null && message.executionIds.length)
                for (var i = 0; i < message.executionIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.executionIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GetExecutionsByIDRequest message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionsByIDRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @static
         * @param {ml_metadata.IGetExecutionsByIDRequest} message GetExecutionsByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionsByIDRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionsByIDRequest} GetExecutionsByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByIDRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionsByIDRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executionIds && message.executionIds.length))
                        message.executionIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.executionIds.push(reader.int64());
                    } else
                        message.executionIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionsByIDRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionsByIDRequest} GetExecutionsByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByIDRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionsByIDRequest message.
         * @function verify
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionsByIDRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionIds != null && message.hasOwnProperty("executionIds")) {
                if (!Array.isArray(message.executionIds))
                    return "executionIds: array expected";
                for (var i = 0; i < message.executionIds.length; ++i)
                    if (!$util.isInteger(message.executionIds[i]) && !(message.executionIds[i] && $util.isInteger(message.executionIds[i].low) && $util.isInteger(message.executionIds[i].high)))
                        return "executionIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a GetExecutionsByIDRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionsByIDRequest} GetExecutionsByIDRequest
         */
        GetExecutionsByIDRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionsByIDRequest)
                return object;
            var message = new $root.ml_metadata.GetExecutionsByIDRequest();
            if (object.executionIds) {
                if (!Array.isArray(object.executionIds))
                    throw TypeError(".ml_metadata.GetExecutionsByIDRequest.executionIds: array expected");
                message.executionIds = [];
                for (var i = 0; i < object.executionIds.length; ++i)
                    if ($util.Long)
                        (message.executionIds[i] = $util.Long.fromValue(object.executionIds[i])).unsigned = false;
                    else if (typeof object.executionIds[i] === "string")
                        message.executionIds[i] = parseInt(object.executionIds[i], 10);
                    else if (typeof object.executionIds[i] === "number")
                        message.executionIds[i] = object.executionIds[i];
                    else if (typeof object.executionIds[i] === "object")
                        message.executionIds[i] = new $util.LongBits(object.executionIds[i].low >>> 0, object.executionIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionsByIDRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @static
         * @param {ml_metadata.GetExecutionsByIDRequest} message GetExecutionsByIDRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionsByIDRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executionIds = [];
            if (message.executionIds && message.executionIds.length) {
                object.executionIds = [];
                for (var j = 0; j < message.executionIds.length; ++j)
                    if (typeof message.executionIds[j] === "number")
                        object.executionIds[j] = options.longs === String ? String(message.executionIds[j]) : message.executionIds[j];
                    else
                        object.executionIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.executionIds[j]) : options.longs === Number ? new $util.LongBits(message.executionIds[j].low >>> 0, message.executionIds[j].high >>> 0).toNumber() : message.executionIds[j];
            }
            return object;
        };

        /**
         * Converts this GetExecutionsByIDRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionsByIDRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionsByIDRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionsByIDRequest;
    })();

    ml_metadata.GetExecutionsByIDResponse = (function() {

        /**
         * Properties of a GetExecutionsByIDResponse.
         * @memberof ml_metadata
         * @interface IGetExecutionsByIDResponse
         * @property {Array.<ml_metadata.IExecution>|null} [executions] GetExecutionsByIDResponse executions
         */

        /**
         * Constructs a new GetExecutionsByIDResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionsByIDResponse.
         * @implements IGetExecutionsByIDResponse
         * @constructor
         * @param {ml_metadata.IGetExecutionsByIDResponse=} [properties] Properties to set
         */
        function GetExecutionsByIDResponse(properties) {
            this.executions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionsByIDResponse executions.
         * @member {Array.<ml_metadata.IExecution>} executions
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @instance
         */
        GetExecutionsByIDResponse.prototype.executions = $util.emptyArray;

        /**
         * Creates a new GetExecutionsByIDResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @static
         * @param {ml_metadata.IGetExecutionsByIDResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionsByIDResponse} GetExecutionsByIDResponse instance
         */
        GetExecutionsByIDResponse.create = function create(properties) {
            return new GetExecutionsByIDResponse(properties);
        };

        /**
         * Encodes the specified GetExecutionsByIDResponse message. Does not implicitly {@link ml_metadata.GetExecutionsByIDResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @static
         * @param {ml_metadata.IGetExecutionsByIDResponse} message GetExecutionsByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByIDResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executions != null && message.executions.length)
                for (var i = 0; i < message.executions.length; ++i)
                    $root.ml_metadata.Execution.encode(message.executions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetExecutionsByIDResponse message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionsByIDResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @static
         * @param {ml_metadata.IGetExecutionsByIDResponse} message GetExecutionsByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionsByIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionsByIDResponse} GetExecutionsByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByIDResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionsByIDResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executions && message.executions.length))
                        message.executions = [];
                    message.executions.push($root.ml_metadata.Execution.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionsByIDResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionsByIDResponse} GetExecutionsByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByIDResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionsByIDResponse message.
         * @function verify
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionsByIDResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executions != null && message.hasOwnProperty("executions")) {
                if (!Array.isArray(message.executions))
                    return "executions: array expected";
                for (var i = 0; i < message.executions.length; ++i) {
                    var error = $root.ml_metadata.Execution.verify(message.executions[i]);
                    if (error)
                        return "executions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetExecutionsByIDResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionsByIDResponse} GetExecutionsByIDResponse
         */
        GetExecutionsByIDResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionsByIDResponse)
                return object;
            var message = new $root.ml_metadata.GetExecutionsByIDResponse();
            if (object.executions) {
                if (!Array.isArray(object.executions))
                    throw TypeError(".ml_metadata.GetExecutionsByIDResponse.executions: array expected");
                message.executions = [];
                for (var i = 0; i < object.executions.length; ++i) {
                    if (typeof object.executions[i] !== "object")
                        throw TypeError(".ml_metadata.GetExecutionsByIDResponse.executions: object expected");
                    message.executions[i] = $root.ml_metadata.Execution.fromObject(object.executions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionsByIDResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @static
         * @param {ml_metadata.GetExecutionsByIDResponse} message GetExecutionsByIDResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionsByIDResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executions = [];
            if (message.executions && message.executions.length) {
                object.executions = [];
                for (var j = 0; j < message.executions.length; ++j)
                    object.executions[j] = $root.ml_metadata.Execution.toObject(message.executions[j], options);
            }
            return object;
        };

        /**
         * Converts this GetExecutionsByIDResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionsByIDResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionsByIDResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionsByIDResponse;
    })();

    ml_metadata.GetExecutionTypeRequest = (function() {

        /**
         * Properties of a GetExecutionTypeRequest.
         * @memberof ml_metadata
         * @interface IGetExecutionTypeRequest
         * @property {string|null} [typeName] GetExecutionTypeRequest typeName
         * @property {string|null} [typeVersion] GetExecutionTypeRequest typeVersion
         */

        /**
         * Constructs a new GetExecutionTypeRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionTypeRequest.
         * @implements IGetExecutionTypeRequest
         * @constructor
         * @param {ml_metadata.IGetExecutionTypeRequest=} [properties] Properties to set
         */
        function GetExecutionTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionTypeRequest typeName.
         * @member {string} typeName
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @instance
         */
        GetExecutionTypeRequest.prototype.typeName = "";

        /**
         * GetExecutionTypeRequest typeVersion.
         * @member {string} typeVersion
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @instance
         */
        GetExecutionTypeRequest.prototype.typeVersion = "";

        /**
         * Creates a new GetExecutionTypeRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @static
         * @param {ml_metadata.IGetExecutionTypeRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionTypeRequest} GetExecutionTypeRequest instance
         */
        GetExecutionTypeRequest.create = function create(properties) {
            return new GetExecutionTypeRequest(properties);
        };

        /**
         * Encodes the specified GetExecutionTypeRequest message. Does not implicitly {@link ml_metadata.GetExecutionTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @static
         * @param {ml_metadata.IGetExecutionTypeRequest} message GetExecutionTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeName);
            if (message.typeVersion != null && Object.hasOwnProperty.call(message, "typeVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.typeVersion);
            return writer;
        };

        /**
         * Encodes the specified GetExecutionTypeRequest message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @static
         * @param {ml_metadata.IGetExecutionTypeRequest} message GetExecutionTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionTypeRequest} GetExecutionTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 2:
                    message.typeVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionTypeRequest} GetExecutionTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionTypeRequest message.
         * @function verify
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                if (!$util.isString(message.typeVersion))
                    return "typeVersion: string expected";
            return null;
        };

        /**
         * Creates a GetExecutionTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionTypeRequest} GetExecutionTypeRequest
         */
        GetExecutionTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionTypeRequest)
                return object;
            var message = new $root.ml_metadata.GetExecutionTypeRequest();
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            if (object.typeVersion != null)
                message.typeVersion = String(object.typeVersion);
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @static
         * @param {ml_metadata.GetExecutionTypeRequest} message GetExecutionTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeName = "";
                object.typeVersion = "";
            }
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                object.typeVersion = message.typeVersion;
            return object;
        };

        /**
         * Converts this GetExecutionTypeRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionTypeRequest;
    })();

    ml_metadata.GetExecutionTypeResponse = (function() {

        /**
         * Properties of a GetExecutionTypeResponse.
         * @memberof ml_metadata
         * @interface IGetExecutionTypeResponse
         * @property {ml_metadata.IExecutionType|null} [executionType] GetExecutionTypeResponse executionType
         */

        /**
         * Constructs a new GetExecutionTypeResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionTypeResponse.
         * @implements IGetExecutionTypeResponse
         * @constructor
         * @param {ml_metadata.IGetExecutionTypeResponse=} [properties] Properties to set
         */
        function GetExecutionTypeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionTypeResponse executionType.
         * @member {ml_metadata.IExecutionType|null|undefined} executionType
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @instance
         */
        GetExecutionTypeResponse.prototype.executionType = null;

        /**
         * Creates a new GetExecutionTypeResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @static
         * @param {ml_metadata.IGetExecutionTypeResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionTypeResponse} GetExecutionTypeResponse instance
         */
        GetExecutionTypeResponse.create = function create(properties) {
            return new GetExecutionTypeResponse(properties);
        };

        /**
         * Encodes the specified GetExecutionTypeResponse message. Does not implicitly {@link ml_metadata.GetExecutionTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @static
         * @param {ml_metadata.IGetExecutionTypeResponse} message GetExecutionTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionType != null && Object.hasOwnProperty.call(message, "executionType"))
                $root.ml_metadata.ExecutionType.encode(message.executionType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetExecutionTypeResponse message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @static
         * @param {ml_metadata.IGetExecutionTypeResponse} message GetExecutionTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionTypeResponse} GetExecutionTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.executionType = $root.ml_metadata.ExecutionType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionTypeResponse} GetExecutionTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionTypeResponse message.
         * @function verify
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionType != null && message.hasOwnProperty("executionType")) {
                var error = $root.ml_metadata.ExecutionType.verify(message.executionType);
                if (error)
                    return "executionType." + error;
            }
            return null;
        };

        /**
         * Creates a GetExecutionTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionTypeResponse} GetExecutionTypeResponse
         */
        GetExecutionTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionTypeResponse)
                return object;
            var message = new $root.ml_metadata.GetExecutionTypeResponse();
            if (object.executionType != null) {
                if (typeof object.executionType !== "object")
                    throw TypeError(".ml_metadata.GetExecutionTypeResponse.executionType: object expected");
                message.executionType = $root.ml_metadata.ExecutionType.fromObject(object.executionType);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @static
         * @param {ml_metadata.GetExecutionTypeResponse} message GetExecutionTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.executionType = null;
            if (message.executionType != null && message.hasOwnProperty("executionType"))
                object.executionType = $root.ml_metadata.ExecutionType.toObject(message.executionType, options);
            return object;
        };

        /**
         * Converts this GetExecutionTypeResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionTypeResponse;
    })();

    ml_metadata.GetEventsByExecutionIDsRequest = (function() {

        /**
         * Properties of a GetEventsByExecutionIDsRequest.
         * @memberof ml_metadata
         * @interface IGetEventsByExecutionIDsRequest
         * @property {Array.<number|Long>|null} [executionIds] GetEventsByExecutionIDsRequest executionIds
         */

        /**
         * Constructs a new GetEventsByExecutionIDsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetEventsByExecutionIDsRequest.
         * @implements IGetEventsByExecutionIDsRequest
         * @constructor
         * @param {ml_metadata.IGetEventsByExecutionIDsRequest=} [properties] Properties to set
         */
        function GetEventsByExecutionIDsRequest(properties) {
            this.executionIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetEventsByExecutionIDsRequest executionIds.
         * @member {Array.<number|Long>} executionIds
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @instance
         */
        GetEventsByExecutionIDsRequest.prototype.executionIds = $util.emptyArray;

        /**
         * Creates a new GetEventsByExecutionIDsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @static
         * @param {ml_metadata.IGetEventsByExecutionIDsRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetEventsByExecutionIDsRequest} GetEventsByExecutionIDsRequest instance
         */
        GetEventsByExecutionIDsRequest.create = function create(properties) {
            return new GetEventsByExecutionIDsRequest(properties);
        };

        /**
         * Encodes the specified GetEventsByExecutionIDsRequest message. Does not implicitly {@link ml_metadata.GetEventsByExecutionIDsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @static
         * @param {ml_metadata.IGetEventsByExecutionIDsRequest} message GetEventsByExecutionIDsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEventsByExecutionIDsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionIds != null && message.executionIds.length)
                for (var i = 0; i < message.executionIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.executionIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GetEventsByExecutionIDsRequest message, length delimited. Does not implicitly {@link ml_metadata.GetEventsByExecutionIDsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @static
         * @param {ml_metadata.IGetEventsByExecutionIDsRequest} message GetEventsByExecutionIDsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEventsByExecutionIDsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetEventsByExecutionIDsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetEventsByExecutionIDsRequest} GetEventsByExecutionIDsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEventsByExecutionIDsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetEventsByExecutionIDsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executionIds && message.executionIds.length))
                        message.executionIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.executionIds.push(reader.int64());
                    } else
                        message.executionIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetEventsByExecutionIDsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetEventsByExecutionIDsRequest} GetEventsByExecutionIDsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEventsByExecutionIDsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetEventsByExecutionIDsRequest message.
         * @function verify
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetEventsByExecutionIDsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionIds != null && message.hasOwnProperty("executionIds")) {
                if (!Array.isArray(message.executionIds))
                    return "executionIds: array expected";
                for (var i = 0; i < message.executionIds.length; ++i)
                    if (!$util.isInteger(message.executionIds[i]) && !(message.executionIds[i] && $util.isInteger(message.executionIds[i].low) && $util.isInteger(message.executionIds[i].high)))
                        return "executionIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a GetEventsByExecutionIDsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetEventsByExecutionIDsRequest} GetEventsByExecutionIDsRequest
         */
        GetEventsByExecutionIDsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetEventsByExecutionIDsRequest)
                return object;
            var message = new $root.ml_metadata.GetEventsByExecutionIDsRequest();
            if (object.executionIds) {
                if (!Array.isArray(object.executionIds))
                    throw TypeError(".ml_metadata.GetEventsByExecutionIDsRequest.executionIds: array expected");
                message.executionIds = [];
                for (var i = 0; i < object.executionIds.length; ++i)
                    if ($util.Long)
                        (message.executionIds[i] = $util.Long.fromValue(object.executionIds[i])).unsigned = false;
                    else if (typeof object.executionIds[i] === "string")
                        message.executionIds[i] = parseInt(object.executionIds[i], 10);
                    else if (typeof object.executionIds[i] === "number")
                        message.executionIds[i] = object.executionIds[i];
                    else if (typeof object.executionIds[i] === "object")
                        message.executionIds[i] = new $util.LongBits(object.executionIds[i].low >>> 0, object.executionIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetEventsByExecutionIDsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @static
         * @param {ml_metadata.GetEventsByExecutionIDsRequest} message GetEventsByExecutionIDsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetEventsByExecutionIDsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executionIds = [];
            if (message.executionIds && message.executionIds.length) {
                object.executionIds = [];
                for (var j = 0; j < message.executionIds.length; ++j)
                    if (typeof message.executionIds[j] === "number")
                        object.executionIds[j] = options.longs === String ? String(message.executionIds[j]) : message.executionIds[j];
                    else
                        object.executionIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.executionIds[j]) : options.longs === Number ? new $util.LongBits(message.executionIds[j].low >>> 0, message.executionIds[j].high >>> 0).toNumber() : message.executionIds[j];
            }
            return object;
        };

        /**
         * Converts this GetEventsByExecutionIDsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetEventsByExecutionIDsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetEventsByExecutionIDsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetEventsByExecutionIDsRequest;
    })();

    ml_metadata.GetEventsByExecutionIDsResponse = (function() {

        /**
         * Properties of a GetEventsByExecutionIDsResponse.
         * @memberof ml_metadata
         * @interface IGetEventsByExecutionIDsResponse
         * @property {Array.<ml_metadata.IEvent>|null} [events] GetEventsByExecutionIDsResponse events
         */

        /**
         * Constructs a new GetEventsByExecutionIDsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetEventsByExecutionIDsResponse.
         * @implements IGetEventsByExecutionIDsResponse
         * @constructor
         * @param {ml_metadata.IGetEventsByExecutionIDsResponse=} [properties] Properties to set
         */
        function GetEventsByExecutionIDsResponse(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetEventsByExecutionIDsResponse events.
         * @member {Array.<ml_metadata.IEvent>} events
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @instance
         */
        GetEventsByExecutionIDsResponse.prototype.events = $util.emptyArray;

        /**
         * Creates a new GetEventsByExecutionIDsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @static
         * @param {ml_metadata.IGetEventsByExecutionIDsResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetEventsByExecutionIDsResponse} GetEventsByExecutionIDsResponse instance
         */
        GetEventsByExecutionIDsResponse.create = function create(properties) {
            return new GetEventsByExecutionIDsResponse(properties);
        };

        /**
         * Encodes the specified GetEventsByExecutionIDsResponse message. Does not implicitly {@link ml_metadata.GetEventsByExecutionIDsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @static
         * @param {ml_metadata.IGetEventsByExecutionIDsResponse} message GetEventsByExecutionIDsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEventsByExecutionIDsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.ml_metadata.Event.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetEventsByExecutionIDsResponse message, length delimited. Does not implicitly {@link ml_metadata.GetEventsByExecutionIDsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @static
         * @param {ml_metadata.IGetEventsByExecutionIDsResponse} message GetEventsByExecutionIDsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEventsByExecutionIDsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetEventsByExecutionIDsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetEventsByExecutionIDsResponse} GetEventsByExecutionIDsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEventsByExecutionIDsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetEventsByExecutionIDsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.ml_metadata.Event.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetEventsByExecutionIDsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetEventsByExecutionIDsResponse} GetEventsByExecutionIDsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEventsByExecutionIDsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetEventsByExecutionIDsResponse message.
         * @function verify
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetEventsByExecutionIDsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.ml_metadata.Event.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetEventsByExecutionIDsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetEventsByExecutionIDsResponse} GetEventsByExecutionIDsResponse
         */
        GetEventsByExecutionIDsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetEventsByExecutionIDsResponse)
                return object;
            var message = new $root.ml_metadata.GetEventsByExecutionIDsResponse();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".ml_metadata.GetEventsByExecutionIDsResponse.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".ml_metadata.GetEventsByExecutionIDsResponse.events: object expected");
                    message.events[i] = $root.ml_metadata.Event.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetEventsByExecutionIDsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @static
         * @param {ml_metadata.GetEventsByExecutionIDsResponse} message GetEventsByExecutionIDsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetEventsByExecutionIDsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.ml_metadata.Event.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this GetEventsByExecutionIDsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetEventsByExecutionIDsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetEventsByExecutionIDsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetEventsByExecutionIDsResponse;
    })();

    ml_metadata.GetEventsByArtifactIDsRequest = (function() {

        /**
         * Properties of a GetEventsByArtifactIDsRequest.
         * @memberof ml_metadata
         * @interface IGetEventsByArtifactIDsRequest
         * @property {Array.<number|Long>|null} [artifactIds] GetEventsByArtifactIDsRequest artifactIds
         */

        /**
         * Constructs a new GetEventsByArtifactIDsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetEventsByArtifactIDsRequest.
         * @implements IGetEventsByArtifactIDsRequest
         * @constructor
         * @param {ml_metadata.IGetEventsByArtifactIDsRequest=} [properties] Properties to set
         */
        function GetEventsByArtifactIDsRequest(properties) {
            this.artifactIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetEventsByArtifactIDsRequest artifactIds.
         * @member {Array.<number|Long>} artifactIds
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @instance
         */
        GetEventsByArtifactIDsRequest.prototype.artifactIds = $util.emptyArray;

        /**
         * Creates a new GetEventsByArtifactIDsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @static
         * @param {ml_metadata.IGetEventsByArtifactIDsRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetEventsByArtifactIDsRequest} GetEventsByArtifactIDsRequest instance
         */
        GetEventsByArtifactIDsRequest.create = function create(properties) {
            return new GetEventsByArtifactIDsRequest(properties);
        };

        /**
         * Encodes the specified GetEventsByArtifactIDsRequest message. Does not implicitly {@link ml_metadata.GetEventsByArtifactIDsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @static
         * @param {ml_metadata.IGetEventsByArtifactIDsRequest} message GetEventsByArtifactIDsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEventsByArtifactIDsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactIds != null && message.artifactIds.length)
                for (var i = 0; i < message.artifactIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.artifactIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GetEventsByArtifactIDsRequest message, length delimited. Does not implicitly {@link ml_metadata.GetEventsByArtifactIDsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @static
         * @param {ml_metadata.IGetEventsByArtifactIDsRequest} message GetEventsByArtifactIDsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEventsByArtifactIDsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetEventsByArtifactIDsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetEventsByArtifactIDsRequest} GetEventsByArtifactIDsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEventsByArtifactIDsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetEventsByArtifactIDsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifactIds && message.artifactIds.length))
                        message.artifactIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.artifactIds.push(reader.int64());
                    } else
                        message.artifactIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetEventsByArtifactIDsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetEventsByArtifactIDsRequest} GetEventsByArtifactIDsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEventsByArtifactIDsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetEventsByArtifactIDsRequest message.
         * @function verify
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetEventsByArtifactIDsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactIds != null && message.hasOwnProperty("artifactIds")) {
                if (!Array.isArray(message.artifactIds))
                    return "artifactIds: array expected";
                for (var i = 0; i < message.artifactIds.length; ++i)
                    if (!$util.isInteger(message.artifactIds[i]) && !(message.artifactIds[i] && $util.isInteger(message.artifactIds[i].low) && $util.isInteger(message.artifactIds[i].high)))
                        return "artifactIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a GetEventsByArtifactIDsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetEventsByArtifactIDsRequest} GetEventsByArtifactIDsRequest
         */
        GetEventsByArtifactIDsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetEventsByArtifactIDsRequest)
                return object;
            var message = new $root.ml_metadata.GetEventsByArtifactIDsRequest();
            if (object.artifactIds) {
                if (!Array.isArray(object.artifactIds))
                    throw TypeError(".ml_metadata.GetEventsByArtifactIDsRequest.artifactIds: array expected");
                message.artifactIds = [];
                for (var i = 0; i < object.artifactIds.length; ++i)
                    if ($util.Long)
                        (message.artifactIds[i] = $util.Long.fromValue(object.artifactIds[i])).unsigned = false;
                    else if (typeof object.artifactIds[i] === "string")
                        message.artifactIds[i] = parseInt(object.artifactIds[i], 10);
                    else if (typeof object.artifactIds[i] === "number")
                        message.artifactIds[i] = object.artifactIds[i];
                    else if (typeof object.artifactIds[i] === "object")
                        message.artifactIds[i] = new $util.LongBits(object.artifactIds[i].low >>> 0, object.artifactIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetEventsByArtifactIDsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @static
         * @param {ml_metadata.GetEventsByArtifactIDsRequest} message GetEventsByArtifactIDsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetEventsByArtifactIDsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifactIds = [];
            if (message.artifactIds && message.artifactIds.length) {
                object.artifactIds = [];
                for (var j = 0; j < message.artifactIds.length; ++j)
                    if (typeof message.artifactIds[j] === "number")
                        object.artifactIds[j] = options.longs === String ? String(message.artifactIds[j]) : message.artifactIds[j];
                    else
                        object.artifactIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.artifactIds[j]) : options.longs === Number ? new $util.LongBits(message.artifactIds[j].low >>> 0, message.artifactIds[j].high >>> 0).toNumber() : message.artifactIds[j];
            }
            return object;
        };

        /**
         * Converts this GetEventsByArtifactIDsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetEventsByArtifactIDsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetEventsByArtifactIDsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetEventsByArtifactIDsRequest;
    })();

    ml_metadata.GetEventsByArtifactIDsResponse = (function() {

        /**
         * Properties of a GetEventsByArtifactIDsResponse.
         * @memberof ml_metadata
         * @interface IGetEventsByArtifactIDsResponse
         * @property {Array.<ml_metadata.IEvent>|null} [events] GetEventsByArtifactIDsResponse events
         */

        /**
         * Constructs a new GetEventsByArtifactIDsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetEventsByArtifactIDsResponse.
         * @implements IGetEventsByArtifactIDsResponse
         * @constructor
         * @param {ml_metadata.IGetEventsByArtifactIDsResponse=} [properties] Properties to set
         */
        function GetEventsByArtifactIDsResponse(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetEventsByArtifactIDsResponse events.
         * @member {Array.<ml_metadata.IEvent>} events
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @instance
         */
        GetEventsByArtifactIDsResponse.prototype.events = $util.emptyArray;

        /**
         * Creates a new GetEventsByArtifactIDsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @static
         * @param {ml_metadata.IGetEventsByArtifactIDsResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetEventsByArtifactIDsResponse} GetEventsByArtifactIDsResponse instance
         */
        GetEventsByArtifactIDsResponse.create = function create(properties) {
            return new GetEventsByArtifactIDsResponse(properties);
        };

        /**
         * Encodes the specified GetEventsByArtifactIDsResponse message. Does not implicitly {@link ml_metadata.GetEventsByArtifactIDsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @static
         * @param {ml_metadata.IGetEventsByArtifactIDsResponse} message GetEventsByArtifactIDsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEventsByArtifactIDsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.ml_metadata.Event.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetEventsByArtifactIDsResponse message, length delimited. Does not implicitly {@link ml_metadata.GetEventsByArtifactIDsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @static
         * @param {ml_metadata.IGetEventsByArtifactIDsResponse} message GetEventsByArtifactIDsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEventsByArtifactIDsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetEventsByArtifactIDsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetEventsByArtifactIDsResponse} GetEventsByArtifactIDsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEventsByArtifactIDsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetEventsByArtifactIDsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.ml_metadata.Event.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetEventsByArtifactIDsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetEventsByArtifactIDsResponse} GetEventsByArtifactIDsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEventsByArtifactIDsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetEventsByArtifactIDsResponse message.
         * @function verify
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetEventsByArtifactIDsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.ml_metadata.Event.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetEventsByArtifactIDsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetEventsByArtifactIDsResponse} GetEventsByArtifactIDsResponse
         */
        GetEventsByArtifactIDsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetEventsByArtifactIDsResponse)
                return object;
            var message = new $root.ml_metadata.GetEventsByArtifactIDsResponse();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".ml_metadata.GetEventsByArtifactIDsResponse.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".ml_metadata.GetEventsByArtifactIDsResponse.events: object expected");
                    message.events[i] = $root.ml_metadata.Event.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetEventsByArtifactIDsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @static
         * @param {ml_metadata.GetEventsByArtifactIDsResponse} message GetEventsByArtifactIDsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetEventsByArtifactIDsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.ml_metadata.Event.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this GetEventsByArtifactIDsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetEventsByArtifactIDsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetEventsByArtifactIDsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetEventsByArtifactIDsResponse;
    })();

    ml_metadata.GetArtifactTypesByIDRequest = (function() {

        /**
         * Properties of a GetArtifactTypesByIDRequest.
         * @memberof ml_metadata
         * @interface IGetArtifactTypesByIDRequest
         * @property {Array.<number|Long>|null} [typeIds] GetArtifactTypesByIDRequest typeIds
         */

        /**
         * Constructs a new GetArtifactTypesByIDRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactTypesByIDRequest.
         * @implements IGetArtifactTypesByIDRequest
         * @constructor
         * @param {ml_metadata.IGetArtifactTypesByIDRequest=} [properties] Properties to set
         */
        function GetArtifactTypesByIDRequest(properties) {
            this.typeIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactTypesByIDRequest typeIds.
         * @member {Array.<number|Long>} typeIds
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @instance
         */
        GetArtifactTypesByIDRequest.prototype.typeIds = $util.emptyArray;

        /**
         * Creates a new GetArtifactTypesByIDRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @static
         * @param {ml_metadata.IGetArtifactTypesByIDRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactTypesByIDRequest} GetArtifactTypesByIDRequest instance
         */
        GetArtifactTypesByIDRequest.create = function create(properties) {
            return new GetArtifactTypesByIDRequest(properties);
        };

        /**
         * Encodes the specified GetArtifactTypesByIDRequest message. Does not implicitly {@link ml_metadata.GetArtifactTypesByIDRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @static
         * @param {ml_metadata.IGetArtifactTypesByIDRequest} message GetArtifactTypesByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypesByIDRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeIds != null && message.typeIds.length)
                for (var i = 0; i < message.typeIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.typeIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GetArtifactTypesByIDRequest message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactTypesByIDRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @static
         * @param {ml_metadata.IGetArtifactTypesByIDRequest} message GetArtifactTypesByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypesByIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactTypesByIDRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactTypesByIDRequest} GetArtifactTypesByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypesByIDRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactTypesByIDRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.typeIds && message.typeIds.length))
                        message.typeIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.typeIds.push(reader.int64());
                    } else
                        message.typeIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactTypesByIDRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactTypesByIDRequest} GetArtifactTypesByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypesByIDRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactTypesByIDRequest message.
         * @function verify
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactTypesByIDRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeIds != null && message.hasOwnProperty("typeIds")) {
                if (!Array.isArray(message.typeIds))
                    return "typeIds: array expected";
                for (var i = 0; i < message.typeIds.length; ++i)
                    if (!$util.isInteger(message.typeIds[i]) && !(message.typeIds[i] && $util.isInteger(message.typeIds[i].low) && $util.isInteger(message.typeIds[i].high)))
                        return "typeIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a GetArtifactTypesByIDRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactTypesByIDRequest} GetArtifactTypesByIDRequest
         */
        GetArtifactTypesByIDRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactTypesByIDRequest)
                return object;
            var message = new $root.ml_metadata.GetArtifactTypesByIDRequest();
            if (object.typeIds) {
                if (!Array.isArray(object.typeIds))
                    throw TypeError(".ml_metadata.GetArtifactTypesByIDRequest.typeIds: array expected");
                message.typeIds = [];
                for (var i = 0; i < object.typeIds.length; ++i)
                    if ($util.Long)
                        (message.typeIds[i] = $util.Long.fromValue(object.typeIds[i])).unsigned = false;
                    else if (typeof object.typeIds[i] === "string")
                        message.typeIds[i] = parseInt(object.typeIds[i], 10);
                    else if (typeof object.typeIds[i] === "number")
                        message.typeIds[i] = object.typeIds[i];
                    else if (typeof object.typeIds[i] === "object")
                        message.typeIds[i] = new $util.LongBits(object.typeIds[i].low >>> 0, object.typeIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactTypesByIDRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @static
         * @param {ml_metadata.GetArtifactTypesByIDRequest} message GetArtifactTypesByIDRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactTypesByIDRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.typeIds = [];
            if (message.typeIds && message.typeIds.length) {
                object.typeIds = [];
                for (var j = 0; j < message.typeIds.length; ++j)
                    if (typeof message.typeIds[j] === "number")
                        object.typeIds[j] = options.longs === String ? String(message.typeIds[j]) : message.typeIds[j];
                    else
                        object.typeIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.typeIds[j]) : options.longs === Number ? new $util.LongBits(message.typeIds[j].low >>> 0, message.typeIds[j].high >>> 0).toNumber() : message.typeIds[j];
            }
            return object;
        };

        /**
         * Converts this GetArtifactTypesByIDRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactTypesByIDRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactTypesByIDRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactTypesByIDRequest;
    })();

    ml_metadata.GetArtifactTypesByIDResponse = (function() {

        /**
         * Properties of a GetArtifactTypesByIDResponse.
         * @memberof ml_metadata
         * @interface IGetArtifactTypesByIDResponse
         * @property {Array.<ml_metadata.IArtifactType>|null} [artifactTypes] GetArtifactTypesByIDResponse artifactTypes
         */

        /**
         * Constructs a new GetArtifactTypesByIDResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactTypesByIDResponse.
         * @implements IGetArtifactTypesByIDResponse
         * @constructor
         * @param {ml_metadata.IGetArtifactTypesByIDResponse=} [properties] Properties to set
         */
        function GetArtifactTypesByIDResponse(properties) {
            this.artifactTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactTypesByIDResponse artifactTypes.
         * @member {Array.<ml_metadata.IArtifactType>} artifactTypes
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @instance
         */
        GetArtifactTypesByIDResponse.prototype.artifactTypes = $util.emptyArray;

        /**
         * Creates a new GetArtifactTypesByIDResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @static
         * @param {ml_metadata.IGetArtifactTypesByIDResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactTypesByIDResponse} GetArtifactTypesByIDResponse instance
         */
        GetArtifactTypesByIDResponse.create = function create(properties) {
            return new GetArtifactTypesByIDResponse(properties);
        };

        /**
         * Encodes the specified GetArtifactTypesByIDResponse message. Does not implicitly {@link ml_metadata.GetArtifactTypesByIDResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @static
         * @param {ml_metadata.IGetArtifactTypesByIDResponse} message GetArtifactTypesByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypesByIDResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactTypes != null && message.artifactTypes.length)
                for (var i = 0; i < message.artifactTypes.length; ++i)
                    $root.ml_metadata.ArtifactType.encode(message.artifactTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactTypesByIDResponse message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactTypesByIDResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @static
         * @param {ml_metadata.IGetArtifactTypesByIDResponse} message GetArtifactTypesByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactTypesByIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactTypesByIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactTypesByIDResponse} GetArtifactTypesByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypesByIDResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactTypesByIDResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifactTypes && message.artifactTypes.length))
                        message.artifactTypes = [];
                    message.artifactTypes.push($root.ml_metadata.ArtifactType.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactTypesByIDResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactTypesByIDResponse} GetArtifactTypesByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactTypesByIDResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactTypesByIDResponse message.
         * @function verify
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactTypesByIDResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactTypes != null && message.hasOwnProperty("artifactTypes")) {
                if (!Array.isArray(message.artifactTypes))
                    return "artifactTypes: array expected";
                for (var i = 0; i < message.artifactTypes.length; ++i) {
                    var error = $root.ml_metadata.ArtifactType.verify(message.artifactTypes[i]);
                    if (error)
                        return "artifactTypes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetArtifactTypesByIDResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactTypesByIDResponse} GetArtifactTypesByIDResponse
         */
        GetArtifactTypesByIDResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactTypesByIDResponse)
                return object;
            var message = new $root.ml_metadata.GetArtifactTypesByIDResponse();
            if (object.artifactTypes) {
                if (!Array.isArray(object.artifactTypes))
                    throw TypeError(".ml_metadata.GetArtifactTypesByIDResponse.artifactTypes: array expected");
                message.artifactTypes = [];
                for (var i = 0; i < object.artifactTypes.length; ++i) {
                    if (typeof object.artifactTypes[i] !== "object")
                        throw TypeError(".ml_metadata.GetArtifactTypesByIDResponse.artifactTypes: object expected");
                    message.artifactTypes[i] = $root.ml_metadata.ArtifactType.fromObject(object.artifactTypes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactTypesByIDResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @static
         * @param {ml_metadata.GetArtifactTypesByIDResponse} message GetArtifactTypesByIDResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactTypesByIDResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifactTypes = [];
            if (message.artifactTypes && message.artifactTypes.length) {
                object.artifactTypes = [];
                for (var j = 0; j < message.artifactTypes.length; ++j)
                    object.artifactTypes[j] = $root.ml_metadata.ArtifactType.toObject(message.artifactTypes[j], options);
            }
            return object;
        };

        /**
         * Converts this GetArtifactTypesByIDResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactTypesByIDResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactTypesByIDResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactTypesByIDResponse;
    })();

    ml_metadata.GetExecutionTypesByIDRequest = (function() {

        /**
         * Properties of a GetExecutionTypesByIDRequest.
         * @memberof ml_metadata
         * @interface IGetExecutionTypesByIDRequest
         * @property {Array.<number|Long>|null} [typeIds] GetExecutionTypesByIDRequest typeIds
         */

        /**
         * Constructs a new GetExecutionTypesByIDRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionTypesByIDRequest.
         * @implements IGetExecutionTypesByIDRequest
         * @constructor
         * @param {ml_metadata.IGetExecutionTypesByIDRequest=} [properties] Properties to set
         */
        function GetExecutionTypesByIDRequest(properties) {
            this.typeIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionTypesByIDRequest typeIds.
         * @member {Array.<number|Long>} typeIds
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @instance
         */
        GetExecutionTypesByIDRequest.prototype.typeIds = $util.emptyArray;

        /**
         * Creates a new GetExecutionTypesByIDRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @static
         * @param {ml_metadata.IGetExecutionTypesByIDRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionTypesByIDRequest} GetExecutionTypesByIDRequest instance
         */
        GetExecutionTypesByIDRequest.create = function create(properties) {
            return new GetExecutionTypesByIDRequest(properties);
        };

        /**
         * Encodes the specified GetExecutionTypesByIDRequest message. Does not implicitly {@link ml_metadata.GetExecutionTypesByIDRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @static
         * @param {ml_metadata.IGetExecutionTypesByIDRequest} message GetExecutionTypesByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypesByIDRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeIds != null && message.typeIds.length)
                for (var i = 0; i < message.typeIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.typeIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GetExecutionTypesByIDRequest message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionTypesByIDRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @static
         * @param {ml_metadata.IGetExecutionTypesByIDRequest} message GetExecutionTypesByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypesByIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionTypesByIDRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionTypesByIDRequest} GetExecutionTypesByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypesByIDRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionTypesByIDRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.typeIds && message.typeIds.length))
                        message.typeIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.typeIds.push(reader.int64());
                    } else
                        message.typeIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionTypesByIDRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionTypesByIDRequest} GetExecutionTypesByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypesByIDRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionTypesByIDRequest message.
         * @function verify
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionTypesByIDRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeIds != null && message.hasOwnProperty("typeIds")) {
                if (!Array.isArray(message.typeIds))
                    return "typeIds: array expected";
                for (var i = 0; i < message.typeIds.length; ++i)
                    if (!$util.isInteger(message.typeIds[i]) && !(message.typeIds[i] && $util.isInteger(message.typeIds[i].low) && $util.isInteger(message.typeIds[i].high)))
                        return "typeIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a GetExecutionTypesByIDRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionTypesByIDRequest} GetExecutionTypesByIDRequest
         */
        GetExecutionTypesByIDRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionTypesByIDRequest)
                return object;
            var message = new $root.ml_metadata.GetExecutionTypesByIDRequest();
            if (object.typeIds) {
                if (!Array.isArray(object.typeIds))
                    throw TypeError(".ml_metadata.GetExecutionTypesByIDRequest.typeIds: array expected");
                message.typeIds = [];
                for (var i = 0; i < object.typeIds.length; ++i)
                    if ($util.Long)
                        (message.typeIds[i] = $util.Long.fromValue(object.typeIds[i])).unsigned = false;
                    else if (typeof object.typeIds[i] === "string")
                        message.typeIds[i] = parseInt(object.typeIds[i], 10);
                    else if (typeof object.typeIds[i] === "number")
                        message.typeIds[i] = object.typeIds[i];
                    else if (typeof object.typeIds[i] === "object")
                        message.typeIds[i] = new $util.LongBits(object.typeIds[i].low >>> 0, object.typeIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionTypesByIDRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @static
         * @param {ml_metadata.GetExecutionTypesByIDRequest} message GetExecutionTypesByIDRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionTypesByIDRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.typeIds = [];
            if (message.typeIds && message.typeIds.length) {
                object.typeIds = [];
                for (var j = 0; j < message.typeIds.length; ++j)
                    if (typeof message.typeIds[j] === "number")
                        object.typeIds[j] = options.longs === String ? String(message.typeIds[j]) : message.typeIds[j];
                    else
                        object.typeIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.typeIds[j]) : options.longs === Number ? new $util.LongBits(message.typeIds[j].low >>> 0, message.typeIds[j].high >>> 0).toNumber() : message.typeIds[j];
            }
            return object;
        };

        /**
         * Converts this GetExecutionTypesByIDRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionTypesByIDRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionTypesByIDRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionTypesByIDRequest;
    })();

    ml_metadata.GetExecutionTypesByIDResponse = (function() {

        /**
         * Properties of a GetExecutionTypesByIDResponse.
         * @memberof ml_metadata
         * @interface IGetExecutionTypesByIDResponse
         * @property {Array.<ml_metadata.IExecutionType>|null} [executionTypes] GetExecutionTypesByIDResponse executionTypes
         */

        /**
         * Constructs a new GetExecutionTypesByIDResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionTypesByIDResponse.
         * @implements IGetExecutionTypesByIDResponse
         * @constructor
         * @param {ml_metadata.IGetExecutionTypesByIDResponse=} [properties] Properties to set
         */
        function GetExecutionTypesByIDResponse(properties) {
            this.executionTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionTypesByIDResponse executionTypes.
         * @member {Array.<ml_metadata.IExecutionType>} executionTypes
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @instance
         */
        GetExecutionTypesByIDResponse.prototype.executionTypes = $util.emptyArray;

        /**
         * Creates a new GetExecutionTypesByIDResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @static
         * @param {ml_metadata.IGetExecutionTypesByIDResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionTypesByIDResponse} GetExecutionTypesByIDResponse instance
         */
        GetExecutionTypesByIDResponse.create = function create(properties) {
            return new GetExecutionTypesByIDResponse(properties);
        };

        /**
         * Encodes the specified GetExecutionTypesByIDResponse message. Does not implicitly {@link ml_metadata.GetExecutionTypesByIDResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @static
         * @param {ml_metadata.IGetExecutionTypesByIDResponse} message GetExecutionTypesByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypesByIDResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionTypes != null && message.executionTypes.length)
                for (var i = 0; i < message.executionTypes.length; ++i)
                    $root.ml_metadata.ExecutionType.encode(message.executionTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetExecutionTypesByIDResponse message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionTypesByIDResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @static
         * @param {ml_metadata.IGetExecutionTypesByIDResponse} message GetExecutionTypesByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionTypesByIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionTypesByIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionTypesByIDResponse} GetExecutionTypesByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypesByIDResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionTypesByIDResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executionTypes && message.executionTypes.length))
                        message.executionTypes = [];
                    message.executionTypes.push($root.ml_metadata.ExecutionType.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionTypesByIDResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionTypesByIDResponse} GetExecutionTypesByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionTypesByIDResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionTypesByIDResponse message.
         * @function verify
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionTypesByIDResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionTypes != null && message.hasOwnProperty("executionTypes")) {
                if (!Array.isArray(message.executionTypes))
                    return "executionTypes: array expected";
                for (var i = 0; i < message.executionTypes.length; ++i) {
                    var error = $root.ml_metadata.ExecutionType.verify(message.executionTypes[i]);
                    if (error)
                        return "executionTypes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetExecutionTypesByIDResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionTypesByIDResponse} GetExecutionTypesByIDResponse
         */
        GetExecutionTypesByIDResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionTypesByIDResponse)
                return object;
            var message = new $root.ml_metadata.GetExecutionTypesByIDResponse();
            if (object.executionTypes) {
                if (!Array.isArray(object.executionTypes))
                    throw TypeError(".ml_metadata.GetExecutionTypesByIDResponse.executionTypes: array expected");
                message.executionTypes = [];
                for (var i = 0; i < object.executionTypes.length; ++i) {
                    if (typeof object.executionTypes[i] !== "object")
                        throw TypeError(".ml_metadata.GetExecutionTypesByIDResponse.executionTypes: object expected");
                    message.executionTypes[i] = $root.ml_metadata.ExecutionType.fromObject(object.executionTypes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionTypesByIDResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @static
         * @param {ml_metadata.GetExecutionTypesByIDResponse} message GetExecutionTypesByIDResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionTypesByIDResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executionTypes = [];
            if (message.executionTypes && message.executionTypes.length) {
                object.executionTypes = [];
                for (var j = 0; j < message.executionTypes.length; ++j)
                    object.executionTypes[j] = $root.ml_metadata.ExecutionType.toObject(message.executionTypes[j], options);
            }
            return object;
        };

        /**
         * Converts this GetExecutionTypesByIDResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionTypesByIDResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionTypesByIDResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionTypesByIDResponse;
    })();

    ml_metadata.GetContextTypeRequest = (function() {

        /**
         * Properties of a GetContextTypeRequest.
         * @memberof ml_metadata
         * @interface IGetContextTypeRequest
         * @property {string|null} [typeName] GetContextTypeRequest typeName
         * @property {string|null} [typeVersion] GetContextTypeRequest typeVersion
         */

        /**
         * Constructs a new GetContextTypeRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextTypeRequest.
         * @implements IGetContextTypeRequest
         * @constructor
         * @param {ml_metadata.IGetContextTypeRequest=} [properties] Properties to set
         */
        function GetContextTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextTypeRequest typeName.
         * @member {string} typeName
         * @memberof ml_metadata.GetContextTypeRequest
         * @instance
         */
        GetContextTypeRequest.prototype.typeName = "";

        /**
         * GetContextTypeRequest typeVersion.
         * @member {string} typeVersion
         * @memberof ml_metadata.GetContextTypeRequest
         * @instance
         */
        GetContextTypeRequest.prototype.typeVersion = "";

        /**
         * Creates a new GetContextTypeRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextTypeRequest
         * @static
         * @param {ml_metadata.IGetContextTypeRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetContextTypeRequest} GetContextTypeRequest instance
         */
        GetContextTypeRequest.create = function create(properties) {
            return new GetContextTypeRequest(properties);
        };

        /**
         * Encodes the specified GetContextTypeRequest message. Does not implicitly {@link ml_metadata.GetContextTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextTypeRequest
         * @static
         * @param {ml_metadata.IGetContextTypeRequest} message GetContextTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeName);
            if (message.typeVersion != null && Object.hasOwnProperty.call(message, "typeVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.typeVersion);
            return writer;
        };

        /**
         * Encodes the specified GetContextTypeRequest message, length delimited. Does not implicitly {@link ml_metadata.GetContextTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextTypeRequest
         * @static
         * @param {ml_metadata.IGetContextTypeRequest} message GetContextTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextTypeRequest} GetContextTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 2:
                    message.typeVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextTypeRequest} GetContextTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextTypeRequest message.
         * @function verify
         * @memberof ml_metadata.GetContextTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                if (!$util.isString(message.typeVersion))
                    return "typeVersion: string expected";
            return null;
        };

        /**
         * Creates a GetContextTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextTypeRequest} GetContextTypeRequest
         */
        GetContextTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextTypeRequest)
                return object;
            var message = new $root.ml_metadata.GetContextTypeRequest();
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            if (object.typeVersion != null)
                message.typeVersion = String(object.typeVersion);
            return message;
        };

        /**
         * Creates a plain object from a GetContextTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextTypeRequest
         * @static
         * @param {ml_metadata.GetContextTypeRequest} message GetContextTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeName = "";
                object.typeVersion = "";
            }
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                object.typeVersion = message.typeVersion;
            return object;
        };

        /**
         * Converts this GetContextTypeRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextTypeRequest;
    })();

    ml_metadata.GetContextTypeResponse = (function() {

        /**
         * Properties of a GetContextTypeResponse.
         * @memberof ml_metadata
         * @interface IGetContextTypeResponse
         * @property {ml_metadata.IContextType|null} [contextType] GetContextTypeResponse contextType
         */

        /**
         * Constructs a new GetContextTypeResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextTypeResponse.
         * @implements IGetContextTypeResponse
         * @constructor
         * @param {ml_metadata.IGetContextTypeResponse=} [properties] Properties to set
         */
        function GetContextTypeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextTypeResponse contextType.
         * @member {ml_metadata.IContextType|null|undefined} contextType
         * @memberof ml_metadata.GetContextTypeResponse
         * @instance
         */
        GetContextTypeResponse.prototype.contextType = null;

        /**
         * Creates a new GetContextTypeResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextTypeResponse
         * @static
         * @param {ml_metadata.IGetContextTypeResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetContextTypeResponse} GetContextTypeResponse instance
         */
        GetContextTypeResponse.create = function create(properties) {
            return new GetContextTypeResponse(properties);
        };

        /**
         * Encodes the specified GetContextTypeResponse message. Does not implicitly {@link ml_metadata.GetContextTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextTypeResponse
         * @static
         * @param {ml_metadata.IGetContextTypeResponse} message GetContextTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextType != null && Object.hasOwnProperty.call(message, "contextType"))
                $root.ml_metadata.ContextType.encode(message.contextType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetContextTypeResponse message, length delimited. Does not implicitly {@link ml_metadata.GetContextTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextTypeResponse
         * @static
         * @param {ml_metadata.IGetContextTypeResponse} message GetContextTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextTypeResponse} GetContextTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contextType = $root.ml_metadata.ContextType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextTypeResponse} GetContextTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextTypeResponse message.
         * @function verify
         * @memberof ml_metadata.GetContextTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextType != null && message.hasOwnProperty("contextType")) {
                var error = $root.ml_metadata.ContextType.verify(message.contextType);
                if (error)
                    return "contextType." + error;
            }
            return null;
        };

        /**
         * Creates a GetContextTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextTypeResponse} GetContextTypeResponse
         */
        GetContextTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextTypeResponse)
                return object;
            var message = new $root.ml_metadata.GetContextTypeResponse();
            if (object.contextType != null) {
                if (typeof object.contextType !== "object")
                    throw TypeError(".ml_metadata.GetContextTypeResponse.contextType: object expected");
                message.contextType = $root.ml_metadata.ContextType.fromObject(object.contextType);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextTypeResponse
         * @static
         * @param {ml_metadata.GetContextTypeResponse} message GetContextTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.contextType = null;
            if (message.contextType != null && message.hasOwnProperty("contextType"))
                object.contextType = $root.ml_metadata.ContextType.toObject(message.contextType, options);
            return object;
        };

        /**
         * Converts this GetContextTypeResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextTypeResponse;
    })();

    ml_metadata.GetContextTypesByIDRequest = (function() {

        /**
         * Properties of a GetContextTypesByIDRequest.
         * @memberof ml_metadata
         * @interface IGetContextTypesByIDRequest
         * @property {Array.<number|Long>|null} [typeIds] GetContextTypesByIDRequest typeIds
         */

        /**
         * Constructs a new GetContextTypesByIDRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextTypesByIDRequest.
         * @implements IGetContextTypesByIDRequest
         * @constructor
         * @param {ml_metadata.IGetContextTypesByIDRequest=} [properties] Properties to set
         */
        function GetContextTypesByIDRequest(properties) {
            this.typeIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextTypesByIDRequest typeIds.
         * @member {Array.<number|Long>} typeIds
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @instance
         */
        GetContextTypesByIDRequest.prototype.typeIds = $util.emptyArray;

        /**
         * Creates a new GetContextTypesByIDRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @static
         * @param {ml_metadata.IGetContextTypesByIDRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetContextTypesByIDRequest} GetContextTypesByIDRequest instance
         */
        GetContextTypesByIDRequest.create = function create(properties) {
            return new GetContextTypesByIDRequest(properties);
        };

        /**
         * Encodes the specified GetContextTypesByIDRequest message. Does not implicitly {@link ml_metadata.GetContextTypesByIDRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @static
         * @param {ml_metadata.IGetContextTypesByIDRequest} message GetContextTypesByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypesByIDRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeIds != null && message.typeIds.length)
                for (var i = 0; i < message.typeIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.typeIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GetContextTypesByIDRequest message, length delimited. Does not implicitly {@link ml_metadata.GetContextTypesByIDRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @static
         * @param {ml_metadata.IGetContextTypesByIDRequest} message GetContextTypesByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypesByIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextTypesByIDRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextTypesByIDRequest} GetContextTypesByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypesByIDRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextTypesByIDRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.typeIds && message.typeIds.length))
                        message.typeIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.typeIds.push(reader.int64());
                    } else
                        message.typeIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextTypesByIDRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextTypesByIDRequest} GetContextTypesByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypesByIDRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextTypesByIDRequest message.
         * @function verify
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextTypesByIDRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeIds != null && message.hasOwnProperty("typeIds")) {
                if (!Array.isArray(message.typeIds))
                    return "typeIds: array expected";
                for (var i = 0; i < message.typeIds.length; ++i)
                    if (!$util.isInteger(message.typeIds[i]) && !(message.typeIds[i] && $util.isInteger(message.typeIds[i].low) && $util.isInteger(message.typeIds[i].high)))
                        return "typeIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a GetContextTypesByIDRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextTypesByIDRequest} GetContextTypesByIDRequest
         */
        GetContextTypesByIDRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextTypesByIDRequest)
                return object;
            var message = new $root.ml_metadata.GetContextTypesByIDRequest();
            if (object.typeIds) {
                if (!Array.isArray(object.typeIds))
                    throw TypeError(".ml_metadata.GetContextTypesByIDRequest.typeIds: array expected");
                message.typeIds = [];
                for (var i = 0; i < object.typeIds.length; ++i)
                    if ($util.Long)
                        (message.typeIds[i] = $util.Long.fromValue(object.typeIds[i])).unsigned = false;
                    else if (typeof object.typeIds[i] === "string")
                        message.typeIds[i] = parseInt(object.typeIds[i], 10);
                    else if (typeof object.typeIds[i] === "number")
                        message.typeIds[i] = object.typeIds[i];
                    else if (typeof object.typeIds[i] === "object")
                        message.typeIds[i] = new $util.LongBits(object.typeIds[i].low >>> 0, object.typeIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextTypesByIDRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @static
         * @param {ml_metadata.GetContextTypesByIDRequest} message GetContextTypesByIDRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextTypesByIDRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.typeIds = [];
            if (message.typeIds && message.typeIds.length) {
                object.typeIds = [];
                for (var j = 0; j < message.typeIds.length; ++j)
                    if (typeof message.typeIds[j] === "number")
                        object.typeIds[j] = options.longs === String ? String(message.typeIds[j]) : message.typeIds[j];
                    else
                        object.typeIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.typeIds[j]) : options.longs === Number ? new $util.LongBits(message.typeIds[j].low >>> 0, message.typeIds[j].high >>> 0).toNumber() : message.typeIds[j];
            }
            return object;
        };

        /**
         * Converts this GetContextTypesByIDRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextTypesByIDRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextTypesByIDRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextTypesByIDRequest;
    })();

    ml_metadata.GetContextTypesByIDResponse = (function() {

        /**
         * Properties of a GetContextTypesByIDResponse.
         * @memberof ml_metadata
         * @interface IGetContextTypesByIDResponse
         * @property {Array.<ml_metadata.IContextType>|null} [contextTypes] GetContextTypesByIDResponse contextTypes
         */

        /**
         * Constructs a new GetContextTypesByIDResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextTypesByIDResponse.
         * @implements IGetContextTypesByIDResponse
         * @constructor
         * @param {ml_metadata.IGetContextTypesByIDResponse=} [properties] Properties to set
         */
        function GetContextTypesByIDResponse(properties) {
            this.contextTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextTypesByIDResponse contextTypes.
         * @member {Array.<ml_metadata.IContextType>} contextTypes
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @instance
         */
        GetContextTypesByIDResponse.prototype.contextTypes = $util.emptyArray;

        /**
         * Creates a new GetContextTypesByIDResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @static
         * @param {ml_metadata.IGetContextTypesByIDResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetContextTypesByIDResponse} GetContextTypesByIDResponse instance
         */
        GetContextTypesByIDResponse.create = function create(properties) {
            return new GetContextTypesByIDResponse(properties);
        };

        /**
         * Encodes the specified GetContextTypesByIDResponse message. Does not implicitly {@link ml_metadata.GetContextTypesByIDResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @static
         * @param {ml_metadata.IGetContextTypesByIDResponse} message GetContextTypesByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypesByIDResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextTypes != null && message.contextTypes.length)
                for (var i = 0; i < message.contextTypes.length; ++i)
                    $root.ml_metadata.ContextType.encode(message.contextTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetContextTypesByIDResponse message, length delimited. Does not implicitly {@link ml_metadata.GetContextTypesByIDResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @static
         * @param {ml_metadata.IGetContextTypesByIDResponse} message GetContextTypesByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextTypesByIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextTypesByIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextTypesByIDResponse} GetContextTypesByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypesByIDResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextTypesByIDResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contextTypes && message.contextTypes.length))
                        message.contextTypes = [];
                    message.contextTypes.push($root.ml_metadata.ContextType.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextTypesByIDResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextTypesByIDResponse} GetContextTypesByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextTypesByIDResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextTypesByIDResponse message.
         * @function verify
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextTypesByIDResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextTypes != null && message.hasOwnProperty("contextTypes")) {
                if (!Array.isArray(message.contextTypes))
                    return "contextTypes: array expected";
                for (var i = 0; i < message.contextTypes.length; ++i) {
                    var error = $root.ml_metadata.ContextType.verify(message.contextTypes[i]);
                    if (error)
                        return "contextTypes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetContextTypesByIDResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextTypesByIDResponse} GetContextTypesByIDResponse
         */
        GetContextTypesByIDResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextTypesByIDResponse)
                return object;
            var message = new $root.ml_metadata.GetContextTypesByIDResponse();
            if (object.contextTypes) {
                if (!Array.isArray(object.contextTypes))
                    throw TypeError(".ml_metadata.GetContextTypesByIDResponse.contextTypes: array expected");
                message.contextTypes = [];
                for (var i = 0; i < object.contextTypes.length; ++i) {
                    if (typeof object.contextTypes[i] !== "object")
                        throw TypeError(".ml_metadata.GetContextTypesByIDResponse.contextTypes: object expected");
                    message.contextTypes[i] = $root.ml_metadata.ContextType.fromObject(object.contextTypes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextTypesByIDResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @static
         * @param {ml_metadata.GetContextTypesByIDResponse} message GetContextTypesByIDResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextTypesByIDResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contextTypes = [];
            if (message.contextTypes && message.contextTypes.length) {
                object.contextTypes = [];
                for (var j = 0; j < message.contextTypes.length; ++j)
                    object.contextTypes[j] = $root.ml_metadata.ContextType.toObject(message.contextTypes[j], options);
            }
            return object;
        };

        /**
         * Converts this GetContextTypesByIDResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextTypesByIDResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextTypesByIDResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextTypesByIDResponse;
    })();

    ml_metadata.GetContextsRequest = (function() {

        /**
         * Properties of a GetContextsRequest.
         * @memberof ml_metadata
         * @interface IGetContextsRequest
         * @property {ml_metadata.IListOperationOptions|null} [options] GetContextsRequest options
         */

        /**
         * Constructs a new GetContextsRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsRequest.
         * @implements IGetContextsRequest
         * @constructor
         * @param {ml_metadata.IGetContextsRequest=} [properties] Properties to set
         */
        function GetContextsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsRequest options.
         * @member {ml_metadata.IListOperationOptions|null|undefined} options
         * @memberof ml_metadata.GetContextsRequest
         * @instance
         */
        GetContextsRequest.prototype.options = null;

        /**
         * Creates a new GetContextsRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsRequest
         * @static
         * @param {ml_metadata.IGetContextsRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsRequest} GetContextsRequest instance
         */
        GetContextsRequest.create = function create(properties) {
            return new GetContextsRequest(properties);
        };

        /**
         * Encodes the specified GetContextsRequest message. Does not implicitly {@link ml_metadata.GetContextsRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsRequest
         * @static
         * @param {ml_metadata.IGetContextsRequest} message GetContextsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.ml_metadata.ListOperationOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetContextsRequest message, length delimited. Does not implicitly {@link ml_metadata.GetContextsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsRequest
         * @static
         * @param {ml_metadata.IGetContextsRequest} message GetContextsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsRequest} GetContextsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.options = $root.ml_metadata.ListOperationOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsRequest} GetContextsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsRequest message.
         * @function verify
         * @memberof ml_metadata.GetContextsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.ml_metadata.ListOperationOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a GetContextsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsRequest} GetContextsRequest
         */
        GetContextsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsRequest)
                return object;
            var message = new $root.ml_metadata.GetContextsRequest();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".ml_metadata.GetContextsRequest.options: object expected");
                message.options = $root.ml_metadata.ListOperationOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsRequest
         * @static
         * @param {ml_metadata.GetContextsRequest} message GetContextsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.options = null;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.ml_metadata.ListOperationOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this GetContextsRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsRequest;
    })();

    ml_metadata.GetContextsResponse = (function() {

        /**
         * Properties of a GetContextsResponse.
         * @memberof ml_metadata
         * @interface IGetContextsResponse
         * @property {Array.<ml_metadata.IContext>|null} [contexts] GetContextsResponse contexts
         * @property {string|null} [nextPageToken] GetContextsResponse nextPageToken
         */

        /**
         * Constructs a new GetContextsResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsResponse.
         * @implements IGetContextsResponse
         * @constructor
         * @param {ml_metadata.IGetContextsResponse=} [properties] Properties to set
         */
        function GetContextsResponse(properties) {
            this.contexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsResponse contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.GetContextsResponse
         * @instance
         */
        GetContextsResponse.prototype.contexts = $util.emptyArray;

        /**
         * GetContextsResponse nextPageToken.
         * @member {string} nextPageToken
         * @memberof ml_metadata.GetContextsResponse
         * @instance
         */
        GetContextsResponse.prototype.nextPageToken = "";

        /**
         * Creates a new GetContextsResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsResponse
         * @static
         * @param {ml_metadata.IGetContextsResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsResponse} GetContextsResponse instance
         */
        GetContextsResponse.create = function create(properties) {
            return new GetContextsResponse(properties);
        };

        /**
         * Encodes the specified GetContextsResponse message. Does not implicitly {@link ml_metadata.GetContextsResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsResponse
         * @static
         * @param {ml_metadata.IGetContextsResponse} message GetContextsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageToken);
            return writer;
        };

        /**
         * Encodes the specified GetContextsResponse message, length delimited. Does not implicitly {@link ml_metadata.GetContextsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsResponse
         * @static
         * @param {ml_metadata.IGetContextsResponse} message GetContextsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsResponse} GetContextsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsResponse} GetContextsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsResponse message.
         * @function verify
         * @memberof ml_metadata.GetContextsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                if (!$util.isString(message.nextPageToken))
                    return "nextPageToken: string expected";
            return null;
        };

        /**
         * Creates a GetContextsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsResponse} GetContextsResponse
         */
        GetContextsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsResponse)
                return object;
            var message = new $root.ml_metadata.GetContextsResponse();
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.GetContextsResponse.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.GetContextsResponse.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            if (object.nextPageToken != null)
                message.nextPageToken = String(object.nextPageToken);
            return message;
        };

        /**
         * Creates a plain object from a GetContextsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsResponse
         * @static
         * @param {ml_metadata.GetContextsResponse} message GetContextsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contexts = [];
            if (options.defaults)
                object.nextPageToken = "";
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                object.nextPageToken = message.nextPageToken;
            return object;
        };

        /**
         * Converts this GetContextsResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsResponse;
    })();

    ml_metadata.GetContextsByTypeRequest = (function() {

        /**
         * Properties of a GetContextsByTypeRequest.
         * @memberof ml_metadata
         * @interface IGetContextsByTypeRequest
         * @property {string|null} [typeName] GetContextsByTypeRequest typeName
         * @property {ml_metadata.IListOperationOptions|null} [options] GetContextsByTypeRequest options
         * @property {string|null} [typeVersion] GetContextsByTypeRequest typeVersion
         */

        /**
         * Constructs a new GetContextsByTypeRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsByTypeRequest.
         * @implements IGetContextsByTypeRequest
         * @constructor
         * @param {ml_metadata.IGetContextsByTypeRequest=} [properties] Properties to set
         */
        function GetContextsByTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsByTypeRequest typeName.
         * @member {string} typeName
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @instance
         */
        GetContextsByTypeRequest.prototype.typeName = "";

        /**
         * GetContextsByTypeRequest options.
         * @member {ml_metadata.IListOperationOptions|null|undefined} options
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @instance
         */
        GetContextsByTypeRequest.prototype.options = null;

        /**
         * GetContextsByTypeRequest typeVersion.
         * @member {string} typeVersion
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @instance
         */
        GetContextsByTypeRequest.prototype.typeVersion = "";

        /**
         * Creates a new GetContextsByTypeRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @static
         * @param {ml_metadata.IGetContextsByTypeRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsByTypeRequest} GetContextsByTypeRequest instance
         */
        GetContextsByTypeRequest.create = function create(properties) {
            return new GetContextsByTypeRequest(properties);
        };

        /**
         * Encodes the specified GetContextsByTypeRequest message. Does not implicitly {@link ml_metadata.GetContextsByTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @static
         * @param {ml_metadata.IGetContextsByTypeRequest} message GetContextsByTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeName);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.ml_metadata.ListOperationOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.typeVersion != null && Object.hasOwnProperty.call(message, "typeVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.typeVersion);
            return writer;
        };

        /**
         * Encodes the specified GetContextsByTypeRequest message, length delimited. Does not implicitly {@link ml_metadata.GetContextsByTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @static
         * @param {ml_metadata.IGetContextsByTypeRequest} message GetContextsByTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsByTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsByTypeRequest} GetContextsByTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsByTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 2:
                    message.options = $root.ml_metadata.ListOperationOptions.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.typeVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsByTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsByTypeRequest} GetContextsByTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsByTypeRequest message.
         * @function verify
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsByTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.ml_metadata.ListOperationOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                if (!$util.isString(message.typeVersion))
                    return "typeVersion: string expected";
            return null;
        };

        /**
         * Creates a GetContextsByTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsByTypeRequest} GetContextsByTypeRequest
         */
        GetContextsByTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsByTypeRequest)
                return object;
            var message = new $root.ml_metadata.GetContextsByTypeRequest();
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".ml_metadata.GetContextsByTypeRequest.options: object expected");
                message.options = $root.ml_metadata.ListOperationOptions.fromObject(object.options);
            }
            if (object.typeVersion != null)
                message.typeVersion = String(object.typeVersion);
            return message;
        };

        /**
         * Creates a plain object from a GetContextsByTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @static
         * @param {ml_metadata.GetContextsByTypeRequest} message GetContextsByTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsByTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeName = "";
                object.options = null;
                object.typeVersion = "";
            }
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.ml_metadata.ListOperationOptions.toObject(message.options, options);
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                object.typeVersion = message.typeVersion;
            return object;
        };

        /**
         * Converts this GetContextsByTypeRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsByTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsByTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsByTypeRequest;
    })();

    ml_metadata.GetContextsByTypeResponse = (function() {

        /**
         * Properties of a GetContextsByTypeResponse.
         * @memberof ml_metadata
         * @interface IGetContextsByTypeResponse
         * @property {Array.<ml_metadata.IContext>|null} [contexts] GetContextsByTypeResponse contexts
         * @property {string|null} [nextPageToken] GetContextsByTypeResponse nextPageToken
         */

        /**
         * Constructs a new GetContextsByTypeResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsByTypeResponse.
         * @implements IGetContextsByTypeResponse
         * @constructor
         * @param {ml_metadata.IGetContextsByTypeResponse=} [properties] Properties to set
         */
        function GetContextsByTypeResponse(properties) {
            this.contexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsByTypeResponse contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @instance
         */
        GetContextsByTypeResponse.prototype.contexts = $util.emptyArray;

        /**
         * GetContextsByTypeResponse nextPageToken.
         * @member {string} nextPageToken
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @instance
         */
        GetContextsByTypeResponse.prototype.nextPageToken = "";

        /**
         * Creates a new GetContextsByTypeResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @static
         * @param {ml_metadata.IGetContextsByTypeResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsByTypeResponse} GetContextsByTypeResponse instance
         */
        GetContextsByTypeResponse.create = function create(properties) {
            return new GetContextsByTypeResponse(properties);
        };

        /**
         * Encodes the specified GetContextsByTypeResponse message. Does not implicitly {@link ml_metadata.GetContextsByTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @static
         * @param {ml_metadata.IGetContextsByTypeResponse} message GetContextsByTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageToken);
            return writer;
        };

        /**
         * Encodes the specified GetContextsByTypeResponse message, length delimited. Does not implicitly {@link ml_metadata.GetContextsByTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @static
         * @param {ml_metadata.IGetContextsByTypeResponse} message GetContextsByTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsByTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsByTypeResponse} GetContextsByTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsByTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsByTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsByTypeResponse} GetContextsByTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsByTypeResponse message.
         * @function verify
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsByTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                if (!$util.isString(message.nextPageToken))
                    return "nextPageToken: string expected";
            return null;
        };

        /**
         * Creates a GetContextsByTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsByTypeResponse} GetContextsByTypeResponse
         */
        GetContextsByTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsByTypeResponse)
                return object;
            var message = new $root.ml_metadata.GetContextsByTypeResponse();
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.GetContextsByTypeResponse.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.GetContextsByTypeResponse.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            if (object.nextPageToken != null)
                message.nextPageToken = String(object.nextPageToken);
            return message;
        };

        /**
         * Creates a plain object from a GetContextsByTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @static
         * @param {ml_metadata.GetContextsByTypeResponse} message GetContextsByTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsByTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contexts = [];
            if (options.defaults)
                object.nextPageToken = "";
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                object.nextPageToken = message.nextPageToken;
            return object;
        };

        /**
         * Converts this GetContextsByTypeResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsByTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsByTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsByTypeResponse;
    })();

    ml_metadata.GetContextByTypeAndNameRequest = (function() {

        /**
         * Properties of a GetContextByTypeAndNameRequest.
         * @memberof ml_metadata
         * @interface IGetContextByTypeAndNameRequest
         * @property {string|null} [typeName] GetContextByTypeAndNameRequest typeName
         * @property {string|null} [typeVersion] GetContextByTypeAndNameRequest typeVersion
         * @property {string|null} [contextName] GetContextByTypeAndNameRequest contextName
         */

        /**
         * Constructs a new GetContextByTypeAndNameRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextByTypeAndNameRequest.
         * @implements IGetContextByTypeAndNameRequest
         * @constructor
         * @param {ml_metadata.IGetContextByTypeAndNameRequest=} [properties] Properties to set
         */
        function GetContextByTypeAndNameRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextByTypeAndNameRequest typeName.
         * @member {string} typeName
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @instance
         */
        GetContextByTypeAndNameRequest.prototype.typeName = "";

        /**
         * GetContextByTypeAndNameRequest typeVersion.
         * @member {string} typeVersion
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @instance
         */
        GetContextByTypeAndNameRequest.prototype.typeVersion = "";

        /**
         * GetContextByTypeAndNameRequest contextName.
         * @member {string} contextName
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @instance
         */
        GetContextByTypeAndNameRequest.prototype.contextName = "";

        /**
         * Creates a new GetContextByTypeAndNameRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @static
         * @param {ml_metadata.IGetContextByTypeAndNameRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetContextByTypeAndNameRequest} GetContextByTypeAndNameRequest instance
         */
        GetContextByTypeAndNameRequest.create = function create(properties) {
            return new GetContextByTypeAndNameRequest(properties);
        };

        /**
         * Encodes the specified GetContextByTypeAndNameRequest message. Does not implicitly {@link ml_metadata.GetContextByTypeAndNameRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @static
         * @param {ml_metadata.IGetContextByTypeAndNameRequest} message GetContextByTypeAndNameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextByTypeAndNameRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeName);
            if (message.contextName != null && Object.hasOwnProperty.call(message, "contextName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.contextName);
            if (message.typeVersion != null && Object.hasOwnProperty.call(message, "typeVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.typeVersion);
            return writer;
        };

        /**
         * Encodes the specified GetContextByTypeAndNameRequest message, length delimited. Does not implicitly {@link ml_metadata.GetContextByTypeAndNameRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @static
         * @param {ml_metadata.IGetContextByTypeAndNameRequest} message GetContextByTypeAndNameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextByTypeAndNameRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextByTypeAndNameRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextByTypeAndNameRequest} GetContextByTypeAndNameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextByTypeAndNameRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextByTypeAndNameRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 3:
                    message.typeVersion = reader.string();
                    break;
                case 2:
                    message.contextName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextByTypeAndNameRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextByTypeAndNameRequest} GetContextByTypeAndNameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextByTypeAndNameRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextByTypeAndNameRequest message.
         * @function verify
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextByTypeAndNameRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                if (!$util.isString(message.typeVersion))
                    return "typeVersion: string expected";
            if (message.contextName != null && message.hasOwnProperty("contextName"))
                if (!$util.isString(message.contextName))
                    return "contextName: string expected";
            return null;
        };

        /**
         * Creates a GetContextByTypeAndNameRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextByTypeAndNameRequest} GetContextByTypeAndNameRequest
         */
        GetContextByTypeAndNameRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextByTypeAndNameRequest)
                return object;
            var message = new $root.ml_metadata.GetContextByTypeAndNameRequest();
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            if (object.typeVersion != null)
                message.typeVersion = String(object.typeVersion);
            if (object.contextName != null)
                message.contextName = String(object.contextName);
            return message;
        };

        /**
         * Creates a plain object from a GetContextByTypeAndNameRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @static
         * @param {ml_metadata.GetContextByTypeAndNameRequest} message GetContextByTypeAndNameRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextByTypeAndNameRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeName = "";
                object.contextName = "";
                object.typeVersion = "";
            }
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            if (message.contextName != null && message.hasOwnProperty("contextName"))
                object.contextName = message.contextName;
            if (message.typeVersion != null && message.hasOwnProperty("typeVersion"))
                object.typeVersion = message.typeVersion;
            return object;
        };

        /**
         * Converts this GetContextByTypeAndNameRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextByTypeAndNameRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextByTypeAndNameRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextByTypeAndNameRequest;
    })();

    ml_metadata.GetContextByTypeAndNameResponse = (function() {

        /**
         * Properties of a GetContextByTypeAndNameResponse.
         * @memberof ml_metadata
         * @interface IGetContextByTypeAndNameResponse
         * @property {ml_metadata.IContext|null} [context] GetContextByTypeAndNameResponse context
         */

        /**
         * Constructs a new GetContextByTypeAndNameResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextByTypeAndNameResponse.
         * @implements IGetContextByTypeAndNameResponse
         * @constructor
         * @param {ml_metadata.IGetContextByTypeAndNameResponse=} [properties] Properties to set
         */
        function GetContextByTypeAndNameResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextByTypeAndNameResponse context.
         * @member {ml_metadata.IContext|null|undefined} context
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @instance
         */
        GetContextByTypeAndNameResponse.prototype.context = null;

        /**
         * Creates a new GetContextByTypeAndNameResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @static
         * @param {ml_metadata.IGetContextByTypeAndNameResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetContextByTypeAndNameResponse} GetContextByTypeAndNameResponse instance
         */
        GetContextByTypeAndNameResponse.create = function create(properties) {
            return new GetContextByTypeAndNameResponse(properties);
        };

        /**
         * Encodes the specified GetContextByTypeAndNameResponse message. Does not implicitly {@link ml_metadata.GetContextByTypeAndNameResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @static
         * @param {ml_metadata.IGetContextByTypeAndNameResponse} message GetContextByTypeAndNameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextByTypeAndNameResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                $root.ml_metadata.Context.encode(message.context, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetContextByTypeAndNameResponse message, length delimited. Does not implicitly {@link ml_metadata.GetContextByTypeAndNameResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @static
         * @param {ml_metadata.IGetContextByTypeAndNameResponse} message GetContextByTypeAndNameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextByTypeAndNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextByTypeAndNameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextByTypeAndNameResponse} GetContextByTypeAndNameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextByTypeAndNameResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextByTypeAndNameResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.context = $root.ml_metadata.Context.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextByTypeAndNameResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextByTypeAndNameResponse} GetContextByTypeAndNameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextByTypeAndNameResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextByTypeAndNameResponse message.
         * @function verify
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextByTypeAndNameResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.context != null && message.hasOwnProperty("context")) {
                var error = $root.ml_metadata.Context.verify(message.context);
                if (error)
                    return "context." + error;
            }
            return null;
        };

        /**
         * Creates a GetContextByTypeAndNameResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextByTypeAndNameResponse} GetContextByTypeAndNameResponse
         */
        GetContextByTypeAndNameResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextByTypeAndNameResponse)
                return object;
            var message = new $root.ml_metadata.GetContextByTypeAndNameResponse();
            if (object.context != null) {
                if (typeof object.context !== "object")
                    throw TypeError(".ml_metadata.GetContextByTypeAndNameResponse.context: object expected");
                message.context = $root.ml_metadata.Context.fromObject(object.context);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextByTypeAndNameResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @static
         * @param {ml_metadata.GetContextByTypeAndNameResponse} message GetContextByTypeAndNameResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextByTypeAndNameResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.context = null;
            if (message.context != null && message.hasOwnProperty("context"))
                object.context = $root.ml_metadata.Context.toObject(message.context, options);
            return object;
        };

        /**
         * Converts this GetContextByTypeAndNameResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextByTypeAndNameResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextByTypeAndNameResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextByTypeAndNameResponse;
    })();

    ml_metadata.GetContextsByIDRequest = (function() {

        /**
         * Properties of a GetContextsByIDRequest.
         * @memberof ml_metadata
         * @interface IGetContextsByIDRequest
         * @property {Array.<number|Long>|null} [contextIds] GetContextsByIDRequest contextIds
         */

        /**
         * Constructs a new GetContextsByIDRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsByIDRequest.
         * @implements IGetContextsByIDRequest
         * @constructor
         * @param {ml_metadata.IGetContextsByIDRequest=} [properties] Properties to set
         */
        function GetContextsByIDRequest(properties) {
            this.contextIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsByIDRequest contextIds.
         * @member {Array.<number|Long>} contextIds
         * @memberof ml_metadata.GetContextsByIDRequest
         * @instance
         */
        GetContextsByIDRequest.prototype.contextIds = $util.emptyArray;

        /**
         * Creates a new GetContextsByIDRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsByIDRequest
         * @static
         * @param {ml_metadata.IGetContextsByIDRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsByIDRequest} GetContextsByIDRequest instance
         */
        GetContextsByIDRequest.create = function create(properties) {
            return new GetContextsByIDRequest(properties);
        };

        /**
         * Encodes the specified GetContextsByIDRequest message. Does not implicitly {@link ml_metadata.GetContextsByIDRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsByIDRequest
         * @static
         * @param {ml_metadata.IGetContextsByIDRequest} message GetContextsByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByIDRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextIds != null && message.contextIds.length)
                for (var i = 0; i < message.contextIds.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.contextIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GetContextsByIDRequest message, length delimited. Does not implicitly {@link ml_metadata.GetContextsByIDRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsByIDRequest
         * @static
         * @param {ml_metadata.IGetContextsByIDRequest} message GetContextsByIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsByIDRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsByIDRequest} GetContextsByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByIDRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsByIDRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contextIds && message.contextIds.length))
                        message.contextIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.contextIds.push(reader.int64());
                    } else
                        message.contextIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsByIDRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsByIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsByIDRequest} GetContextsByIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByIDRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsByIDRequest message.
         * @function verify
         * @memberof ml_metadata.GetContextsByIDRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsByIDRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextIds != null && message.hasOwnProperty("contextIds")) {
                if (!Array.isArray(message.contextIds))
                    return "contextIds: array expected";
                for (var i = 0; i < message.contextIds.length; ++i)
                    if (!$util.isInteger(message.contextIds[i]) && !(message.contextIds[i] && $util.isInteger(message.contextIds[i].low) && $util.isInteger(message.contextIds[i].high)))
                        return "contextIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a GetContextsByIDRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsByIDRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsByIDRequest} GetContextsByIDRequest
         */
        GetContextsByIDRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsByIDRequest)
                return object;
            var message = new $root.ml_metadata.GetContextsByIDRequest();
            if (object.contextIds) {
                if (!Array.isArray(object.contextIds))
                    throw TypeError(".ml_metadata.GetContextsByIDRequest.contextIds: array expected");
                message.contextIds = [];
                for (var i = 0; i < object.contextIds.length; ++i)
                    if ($util.Long)
                        (message.contextIds[i] = $util.Long.fromValue(object.contextIds[i])).unsigned = false;
                    else if (typeof object.contextIds[i] === "string")
                        message.contextIds[i] = parseInt(object.contextIds[i], 10);
                    else if (typeof object.contextIds[i] === "number")
                        message.contextIds[i] = object.contextIds[i];
                    else if (typeof object.contextIds[i] === "object")
                        message.contextIds[i] = new $util.LongBits(object.contextIds[i].low >>> 0, object.contextIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextsByIDRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsByIDRequest
         * @static
         * @param {ml_metadata.GetContextsByIDRequest} message GetContextsByIDRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsByIDRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contextIds = [];
            if (message.contextIds && message.contextIds.length) {
                object.contextIds = [];
                for (var j = 0; j < message.contextIds.length; ++j)
                    if (typeof message.contextIds[j] === "number")
                        object.contextIds[j] = options.longs === String ? String(message.contextIds[j]) : message.contextIds[j];
                    else
                        object.contextIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.contextIds[j]) : options.longs === Number ? new $util.LongBits(message.contextIds[j].low >>> 0, message.contextIds[j].high >>> 0).toNumber() : message.contextIds[j];
            }
            return object;
        };

        /**
         * Converts this GetContextsByIDRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsByIDRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsByIDRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsByIDRequest;
    })();

    ml_metadata.GetContextsByIDResponse = (function() {

        /**
         * Properties of a GetContextsByIDResponse.
         * @memberof ml_metadata
         * @interface IGetContextsByIDResponse
         * @property {Array.<ml_metadata.IContext>|null} [contexts] GetContextsByIDResponse contexts
         */

        /**
         * Constructs a new GetContextsByIDResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsByIDResponse.
         * @implements IGetContextsByIDResponse
         * @constructor
         * @param {ml_metadata.IGetContextsByIDResponse=} [properties] Properties to set
         */
        function GetContextsByIDResponse(properties) {
            this.contexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsByIDResponse contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.GetContextsByIDResponse
         * @instance
         */
        GetContextsByIDResponse.prototype.contexts = $util.emptyArray;

        /**
         * Creates a new GetContextsByIDResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsByIDResponse
         * @static
         * @param {ml_metadata.IGetContextsByIDResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsByIDResponse} GetContextsByIDResponse instance
         */
        GetContextsByIDResponse.create = function create(properties) {
            return new GetContextsByIDResponse(properties);
        };

        /**
         * Encodes the specified GetContextsByIDResponse message. Does not implicitly {@link ml_metadata.GetContextsByIDResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsByIDResponse
         * @static
         * @param {ml_metadata.IGetContextsByIDResponse} message GetContextsByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByIDResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetContextsByIDResponse message, length delimited. Does not implicitly {@link ml_metadata.GetContextsByIDResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsByIDResponse
         * @static
         * @param {ml_metadata.IGetContextsByIDResponse} message GetContextsByIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsByIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsByIDResponse} GetContextsByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByIDResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsByIDResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsByIDResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsByIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsByIDResponse} GetContextsByIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByIDResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsByIDResponse message.
         * @function verify
         * @memberof ml_metadata.GetContextsByIDResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsByIDResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetContextsByIDResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsByIDResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsByIDResponse} GetContextsByIDResponse
         */
        GetContextsByIDResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsByIDResponse)
                return object;
            var message = new $root.ml_metadata.GetContextsByIDResponse();
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.GetContextsByIDResponse.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.GetContextsByIDResponse.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextsByIDResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsByIDResponse
         * @static
         * @param {ml_metadata.GetContextsByIDResponse} message GetContextsByIDResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsByIDResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contexts = [];
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            return object;
        };

        /**
         * Converts this GetContextsByIDResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsByIDResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsByIDResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsByIDResponse;
    })();

    ml_metadata.GetContextsByArtifactRequest = (function() {

        /**
         * Properties of a GetContextsByArtifactRequest.
         * @memberof ml_metadata
         * @interface IGetContextsByArtifactRequest
         * @property {number|Long|null} [artifactId] GetContextsByArtifactRequest artifactId
         */

        /**
         * Constructs a new GetContextsByArtifactRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsByArtifactRequest.
         * @implements IGetContextsByArtifactRequest
         * @constructor
         * @param {ml_metadata.IGetContextsByArtifactRequest=} [properties] Properties to set
         */
        function GetContextsByArtifactRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsByArtifactRequest artifactId.
         * @member {number|Long} artifactId
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @instance
         */
        GetContextsByArtifactRequest.prototype.artifactId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetContextsByArtifactRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @static
         * @param {ml_metadata.IGetContextsByArtifactRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsByArtifactRequest} GetContextsByArtifactRequest instance
         */
        GetContextsByArtifactRequest.create = function create(properties) {
            return new GetContextsByArtifactRequest(properties);
        };

        /**
         * Encodes the specified GetContextsByArtifactRequest message. Does not implicitly {@link ml_metadata.GetContextsByArtifactRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @static
         * @param {ml_metadata.IGetContextsByArtifactRequest} message GetContextsByArtifactRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByArtifactRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactId != null && Object.hasOwnProperty.call(message, "artifactId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.artifactId);
            return writer;
        };

        /**
         * Encodes the specified GetContextsByArtifactRequest message, length delimited. Does not implicitly {@link ml_metadata.GetContextsByArtifactRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @static
         * @param {ml_metadata.IGetContextsByArtifactRequest} message GetContextsByArtifactRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByArtifactRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsByArtifactRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsByArtifactRequest} GetContextsByArtifactRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByArtifactRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsByArtifactRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.artifactId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsByArtifactRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsByArtifactRequest} GetContextsByArtifactRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByArtifactRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsByArtifactRequest message.
         * @function verify
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsByArtifactRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactId != null && message.hasOwnProperty("artifactId"))
                if (!$util.isInteger(message.artifactId) && !(message.artifactId && $util.isInteger(message.artifactId.low) && $util.isInteger(message.artifactId.high)))
                    return "artifactId: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetContextsByArtifactRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsByArtifactRequest} GetContextsByArtifactRequest
         */
        GetContextsByArtifactRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsByArtifactRequest)
                return object;
            var message = new $root.ml_metadata.GetContextsByArtifactRequest();
            if (object.artifactId != null)
                if ($util.Long)
                    (message.artifactId = $util.Long.fromValue(object.artifactId)).unsigned = false;
                else if (typeof object.artifactId === "string")
                    message.artifactId = parseInt(object.artifactId, 10);
                else if (typeof object.artifactId === "number")
                    message.artifactId = object.artifactId;
                else if (typeof object.artifactId === "object")
                    message.artifactId = new $util.LongBits(object.artifactId.low >>> 0, object.artifactId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GetContextsByArtifactRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @static
         * @param {ml_metadata.GetContextsByArtifactRequest} message GetContextsByArtifactRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsByArtifactRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.artifactId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.artifactId = options.longs === String ? "0" : 0;
            if (message.artifactId != null && message.hasOwnProperty("artifactId"))
                if (typeof message.artifactId === "number")
                    object.artifactId = options.longs === String ? String(message.artifactId) : message.artifactId;
                else
                    object.artifactId = options.longs === String ? $util.Long.prototype.toString.call(message.artifactId) : options.longs === Number ? new $util.LongBits(message.artifactId.low >>> 0, message.artifactId.high >>> 0).toNumber() : message.artifactId;
            return object;
        };

        /**
         * Converts this GetContextsByArtifactRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsByArtifactRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsByArtifactRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsByArtifactRequest;
    })();

    ml_metadata.GetContextsByArtifactResponse = (function() {

        /**
         * Properties of a GetContextsByArtifactResponse.
         * @memberof ml_metadata
         * @interface IGetContextsByArtifactResponse
         * @property {Array.<ml_metadata.IContext>|null} [contexts] GetContextsByArtifactResponse contexts
         */

        /**
         * Constructs a new GetContextsByArtifactResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsByArtifactResponse.
         * @implements IGetContextsByArtifactResponse
         * @constructor
         * @param {ml_metadata.IGetContextsByArtifactResponse=} [properties] Properties to set
         */
        function GetContextsByArtifactResponse(properties) {
            this.contexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsByArtifactResponse contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @instance
         */
        GetContextsByArtifactResponse.prototype.contexts = $util.emptyArray;

        /**
         * Creates a new GetContextsByArtifactResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @static
         * @param {ml_metadata.IGetContextsByArtifactResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsByArtifactResponse} GetContextsByArtifactResponse instance
         */
        GetContextsByArtifactResponse.create = function create(properties) {
            return new GetContextsByArtifactResponse(properties);
        };

        /**
         * Encodes the specified GetContextsByArtifactResponse message. Does not implicitly {@link ml_metadata.GetContextsByArtifactResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @static
         * @param {ml_metadata.IGetContextsByArtifactResponse} message GetContextsByArtifactResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByArtifactResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetContextsByArtifactResponse message, length delimited. Does not implicitly {@link ml_metadata.GetContextsByArtifactResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @static
         * @param {ml_metadata.IGetContextsByArtifactResponse} message GetContextsByArtifactResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByArtifactResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsByArtifactResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsByArtifactResponse} GetContextsByArtifactResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByArtifactResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsByArtifactResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsByArtifactResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsByArtifactResponse} GetContextsByArtifactResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByArtifactResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsByArtifactResponse message.
         * @function verify
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsByArtifactResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetContextsByArtifactResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsByArtifactResponse} GetContextsByArtifactResponse
         */
        GetContextsByArtifactResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsByArtifactResponse)
                return object;
            var message = new $root.ml_metadata.GetContextsByArtifactResponse();
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.GetContextsByArtifactResponse.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.GetContextsByArtifactResponse.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextsByArtifactResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @static
         * @param {ml_metadata.GetContextsByArtifactResponse} message GetContextsByArtifactResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsByArtifactResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contexts = [];
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            return object;
        };

        /**
         * Converts this GetContextsByArtifactResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsByArtifactResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsByArtifactResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsByArtifactResponse;
    })();

    ml_metadata.GetContextsByExecutionRequest = (function() {

        /**
         * Properties of a GetContextsByExecutionRequest.
         * @memberof ml_metadata
         * @interface IGetContextsByExecutionRequest
         * @property {number|Long|null} [executionId] GetContextsByExecutionRequest executionId
         */

        /**
         * Constructs a new GetContextsByExecutionRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsByExecutionRequest.
         * @implements IGetContextsByExecutionRequest
         * @constructor
         * @param {ml_metadata.IGetContextsByExecutionRequest=} [properties] Properties to set
         */
        function GetContextsByExecutionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsByExecutionRequest executionId.
         * @member {number|Long} executionId
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @instance
         */
        GetContextsByExecutionRequest.prototype.executionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetContextsByExecutionRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @static
         * @param {ml_metadata.IGetContextsByExecutionRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsByExecutionRequest} GetContextsByExecutionRequest instance
         */
        GetContextsByExecutionRequest.create = function create(properties) {
            return new GetContextsByExecutionRequest(properties);
        };

        /**
         * Encodes the specified GetContextsByExecutionRequest message. Does not implicitly {@link ml_metadata.GetContextsByExecutionRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @static
         * @param {ml_metadata.IGetContextsByExecutionRequest} message GetContextsByExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByExecutionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionId != null && Object.hasOwnProperty.call(message, "executionId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.executionId);
            return writer;
        };

        /**
         * Encodes the specified GetContextsByExecutionRequest message, length delimited. Does not implicitly {@link ml_metadata.GetContextsByExecutionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @static
         * @param {ml_metadata.IGetContextsByExecutionRequest} message GetContextsByExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByExecutionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsByExecutionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsByExecutionRequest} GetContextsByExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByExecutionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsByExecutionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.executionId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsByExecutionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsByExecutionRequest} GetContextsByExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByExecutionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsByExecutionRequest message.
         * @function verify
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsByExecutionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionId != null && message.hasOwnProperty("executionId"))
                if (!$util.isInteger(message.executionId) && !(message.executionId && $util.isInteger(message.executionId.low) && $util.isInteger(message.executionId.high)))
                    return "executionId: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetContextsByExecutionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsByExecutionRequest} GetContextsByExecutionRequest
         */
        GetContextsByExecutionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsByExecutionRequest)
                return object;
            var message = new $root.ml_metadata.GetContextsByExecutionRequest();
            if (object.executionId != null)
                if ($util.Long)
                    (message.executionId = $util.Long.fromValue(object.executionId)).unsigned = false;
                else if (typeof object.executionId === "string")
                    message.executionId = parseInt(object.executionId, 10);
                else if (typeof object.executionId === "number")
                    message.executionId = object.executionId;
                else if (typeof object.executionId === "object")
                    message.executionId = new $util.LongBits(object.executionId.low >>> 0, object.executionId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GetContextsByExecutionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @static
         * @param {ml_metadata.GetContextsByExecutionRequest} message GetContextsByExecutionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsByExecutionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.executionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.executionId = options.longs === String ? "0" : 0;
            if (message.executionId != null && message.hasOwnProperty("executionId"))
                if (typeof message.executionId === "number")
                    object.executionId = options.longs === String ? String(message.executionId) : message.executionId;
                else
                    object.executionId = options.longs === String ? $util.Long.prototype.toString.call(message.executionId) : options.longs === Number ? new $util.LongBits(message.executionId.low >>> 0, message.executionId.high >>> 0).toNumber() : message.executionId;
            return object;
        };

        /**
         * Converts this GetContextsByExecutionRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsByExecutionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsByExecutionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsByExecutionRequest;
    })();

    ml_metadata.GetContextsByExecutionResponse = (function() {

        /**
         * Properties of a GetContextsByExecutionResponse.
         * @memberof ml_metadata
         * @interface IGetContextsByExecutionResponse
         * @property {Array.<ml_metadata.IContext>|null} [contexts] GetContextsByExecutionResponse contexts
         */

        /**
         * Constructs a new GetContextsByExecutionResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetContextsByExecutionResponse.
         * @implements IGetContextsByExecutionResponse
         * @constructor
         * @param {ml_metadata.IGetContextsByExecutionResponse=} [properties] Properties to set
         */
        function GetContextsByExecutionResponse(properties) {
            this.contexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetContextsByExecutionResponse contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @instance
         */
        GetContextsByExecutionResponse.prototype.contexts = $util.emptyArray;

        /**
         * Creates a new GetContextsByExecutionResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @static
         * @param {ml_metadata.IGetContextsByExecutionResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetContextsByExecutionResponse} GetContextsByExecutionResponse instance
         */
        GetContextsByExecutionResponse.create = function create(properties) {
            return new GetContextsByExecutionResponse(properties);
        };

        /**
         * Encodes the specified GetContextsByExecutionResponse message. Does not implicitly {@link ml_metadata.GetContextsByExecutionResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @static
         * @param {ml_metadata.IGetContextsByExecutionResponse} message GetContextsByExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByExecutionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetContextsByExecutionResponse message, length delimited. Does not implicitly {@link ml_metadata.GetContextsByExecutionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @static
         * @param {ml_metadata.IGetContextsByExecutionResponse} message GetContextsByExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetContextsByExecutionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetContextsByExecutionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetContextsByExecutionResponse} GetContextsByExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByExecutionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetContextsByExecutionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetContextsByExecutionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetContextsByExecutionResponse} GetContextsByExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetContextsByExecutionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetContextsByExecutionResponse message.
         * @function verify
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetContextsByExecutionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetContextsByExecutionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetContextsByExecutionResponse} GetContextsByExecutionResponse
         */
        GetContextsByExecutionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetContextsByExecutionResponse)
                return object;
            var message = new $root.ml_metadata.GetContextsByExecutionResponse();
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.GetContextsByExecutionResponse.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.GetContextsByExecutionResponse.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetContextsByExecutionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @static
         * @param {ml_metadata.GetContextsByExecutionResponse} message GetContextsByExecutionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetContextsByExecutionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contexts = [];
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            return object;
        };

        /**
         * Converts this GetContextsByExecutionResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetContextsByExecutionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetContextsByExecutionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetContextsByExecutionResponse;
    })();

    ml_metadata.GetParentContextsByContextRequest = (function() {

        /**
         * Properties of a GetParentContextsByContextRequest.
         * @memberof ml_metadata
         * @interface IGetParentContextsByContextRequest
         * @property {number|Long|null} [contextId] GetParentContextsByContextRequest contextId
         */

        /**
         * Constructs a new GetParentContextsByContextRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetParentContextsByContextRequest.
         * @implements IGetParentContextsByContextRequest
         * @constructor
         * @param {ml_metadata.IGetParentContextsByContextRequest=} [properties] Properties to set
         */
        function GetParentContextsByContextRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetParentContextsByContextRequest contextId.
         * @member {number|Long} contextId
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @instance
         */
        GetParentContextsByContextRequest.prototype.contextId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetParentContextsByContextRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @static
         * @param {ml_metadata.IGetParentContextsByContextRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetParentContextsByContextRequest} GetParentContextsByContextRequest instance
         */
        GetParentContextsByContextRequest.create = function create(properties) {
            return new GetParentContextsByContextRequest(properties);
        };

        /**
         * Encodes the specified GetParentContextsByContextRequest message. Does not implicitly {@link ml_metadata.GetParentContextsByContextRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @static
         * @param {ml_metadata.IGetParentContextsByContextRequest} message GetParentContextsByContextRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetParentContextsByContextRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.contextId);
            return writer;
        };

        /**
         * Encodes the specified GetParentContextsByContextRequest message, length delimited. Does not implicitly {@link ml_metadata.GetParentContextsByContextRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @static
         * @param {ml_metadata.IGetParentContextsByContextRequest} message GetParentContextsByContextRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetParentContextsByContextRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetParentContextsByContextRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetParentContextsByContextRequest} GetParentContextsByContextRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetParentContextsByContextRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetParentContextsByContextRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contextId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetParentContextsByContextRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetParentContextsByContextRequest} GetParentContextsByContextRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetParentContextsByContextRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetParentContextsByContextRequest message.
         * @function verify
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetParentContextsByContextRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (!$util.isInteger(message.contextId) && !(message.contextId && $util.isInteger(message.contextId.low) && $util.isInteger(message.contextId.high)))
                    return "contextId: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetParentContextsByContextRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetParentContextsByContextRequest} GetParentContextsByContextRequest
         */
        GetParentContextsByContextRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetParentContextsByContextRequest)
                return object;
            var message = new $root.ml_metadata.GetParentContextsByContextRequest();
            if (object.contextId != null)
                if ($util.Long)
                    (message.contextId = $util.Long.fromValue(object.contextId)).unsigned = false;
                else if (typeof object.contextId === "string")
                    message.contextId = parseInt(object.contextId, 10);
                else if (typeof object.contextId === "number")
                    message.contextId = object.contextId;
                else if (typeof object.contextId === "object")
                    message.contextId = new $util.LongBits(object.contextId.low >>> 0, object.contextId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GetParentContextsByContextRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @static
         * @param {ml_metadata.GetParentContextsByContextRequest} message GetParentContextsByContextRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetParentContextsByContextRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.contextId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.contextId = options.longs === String ? "0" : 0;
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (typeof message.contextId === "number")
                    object.contextId = options.longs === String ? String(message.contextId) : message.contextId;
                else
                    object.contextId = options.longs === String ? $util.Long.prototype.toString.call(message.contextId) : options.longs === Number ? new $util.LongBits(message.contextId.low >>> 0, message.contextId.high >>> 0).toNumber() : message.contextId;
            return object;
        };

        /**
         * Converts this GetParentContextsByContextRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetParentContextsByContextRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetParentContextsByContextRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetParentContextsByContextRequest;
    })();

    ml_metadata.GetParentContextsByContextResponse = (function() {

        /**
         * Properties of a GetParentContextsByContextResponse.
         * @memberof ml_metadata
         * @interface IGetParentContextsByContextResponse
         * @property {Array.<ml_metadata.IContext>|null} [contexts] GetParentContextsByContextResponse contexts
         */

        /**
         * Constructs a new GetParentContextsByContextResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetParentContextsByContextResponse.
         * @implements IGetParentContextsByContextResponse
         * @constructor
         * @param {ml_metadata.IGetParentContextsByContextResponse=} [properties] Properties to set
         */
        function GetParentContextsByContextResponse(properties) {
            this.contexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetParentContextsByContextResponse contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @instance
         */
        GetParentContextsByContextResponse.prototype.contexts = $util.emptyArray;

        /**
         * Creates a new GetParentContextsByContextResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @static
         * @param {ml_metadata.IGetParentContextsByContextResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetParentContextsByContextResponse} GetParentContextsByContextResponse instance
         */
        GetParentContextsByContextResponse.create = function create(properties) {
            return new GetParentContextsByContextResponse(properties);
        };

        /**
         * Encodes the specified GetParentContextsByContextResponse message. Does not implicitly {@link ml_metadata.GetParentContextsByContextResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @static
         * @param {ml_metadata.IGetParentContextsByContextResponse} message GetParentContextsByContextResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetParentContextsByContextResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetParentContextsByContextResponse message, length delimited. Does not implicitly {@link ml_metadata.GetParentContextsByContextResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @static
         * @param {ml_metadata.IGetParentContextsByContextResponse} message GetParentContextsByContextResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetParentContextsByContextResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetParentContextsByContextResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetParentContextsByContextResponse} GetParentContextsByContextResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetParentContextsByContextResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetParentContextsByContextResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetParentContextsByContextResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetParentContextsByContextResponse} GetParentContextsByContextResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetParentContextsByContextResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetParentContextsByContextResponse message.
         * @function verify
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetParentContextsByContextResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetParentContextsByContextResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetParentContextsByContextResponse} GetParentContextsByContextResponse
         */
        GetParentContextsByContextResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetParentContextsByContextResponse)
                return object;
            var message = new $root.ml_metadata.GetParentContextsByContextResponse();
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.GetParentContextsByContextResponse.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.GetParentContextsByContextResponse.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetParentContextsByContextResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @static
         * @param {ml_metadata.GetParentContextsByContextResponse} message GetParentContextsByContextResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetParentContextsByContextResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contexts = [];
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            return object;
        };

        /**
         * Converts this GetParentContextsByContextResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetParentContextsByContextResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetParentContextsByContextResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetParentContextsByContextResponse;
    })();

    ml_metadata.GetChildrenContextsByContextRequest = (function() {

        /**
         * Properties of a GetChildrenContextsByContextRequest.
         * @memberof ml_metadata
         * @interface IGetChildrenContextsByContextRequest
         * @property {number|Long|null} [contextId] GetChildrenContextsByContextRequest contextId
         */

        /**
         * Constructs a new GetChildrenContextsByContextRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetChildrenContextsByContextRequest.
         * @implements IGetChildrenContextsByContextRequest
         * @constructor
         * @param {ml_metadata.IGetChildrenContextsByContextRequest=} [properties] Properties to set
         */
        function GetChildrenContextsByContextRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetChildrenContextsByContextRequest contextId.
         * @member {number|Long} contextId
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @instance
         */
        GetChildrenContextsByContextRequest.prototype.contextId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetChildrenContextsByContextRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @static
         * @param {ml_metadata.IGetChildrenContextsByContextRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetChildrenContextsByContextRequest} GetChildrenContextsByContextRequest instance
         */
        GetChildrenContextsByContextRequest.create = function create(properties) {
            return new GetChildrenContextsByContextRequest(properties);
        };

        /**
         * Encodes the specified GetChildrenContextsByContextRequest message. Does not implicitly {@link ml_metadata.GetChildrenContextsByContextRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @static
         * @param {ml_metadata.IGetChildrenContextsByContextRequest} message GetChildrenContextsByContextRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetChildrenContextsByContextRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.contextId);
            return writer;
        };

        /**
         * Encodes the specified GetChildrenContextsByContextRequest message, length delimited. Does not implicitly {@link ml_metadata.GetChildrenContextsByContextRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @static
         * @param {ml_metadata.IGetChildrenContextsByContextRequest} message GetChildrenContextsByContextRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetChildrenContextsByContextRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetChildrenContextsByContextRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetChildrenContextsByContextRequest} GetChildrenContextsByContextRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetChildrenContextsByContextRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetChildrenContextsByContextRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contextId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetChildrenContextsByContextRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetChildrenContextsByContextRequest} GetChildrenContextsByContextRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetChildrenContextsByContextRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetChildrenContextsByContextRequest message.
         * @function verify
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetChildrenContextsByContextRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (!$util.isInteger(message.contextId) && !(message.contextId && $util.isInteger(message.contextId.low) && $util.isInteger(message.contextId.high)))
                    return "contextId: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetChildrenContextsByContextRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetChildrenContextsByContextRequest} GetChildrenContextsByContextRequest
         */
        GetChildrenContextsByContextRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetChildrenContextsByContextRequest)
                return object;
            var message = new $root.ml_metadata.GetChildrenContextsByContextRequest();
            if (object.contextId != null)
                if ($util.Long)
                    (message.contextId = $util.Long.fromValue(object.contextId)).unsigned = false;
                else if (typeof object.contextId === "string")
                    message.contextId = parseInt(object.contextId, 10);
                else if (typeof object.contextId === "number")
                    message.contextId = object.contextId;
                else if (typeof object.contextId === "object")
                    message.contextId = new $util.LongBits(object.contextId.low >>> 0, object.contextId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GetChildrenContextsByContextRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @static
         * @param {ml_metadata.GetChildrenContextsByContextRequest} message GetChildrenContextsByContextRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetChildrenContextsByContextRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.contextId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.contextId = options.longs === String ? "0" : 0;
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (typeof message.contextId === "number")
                    object.contextId = options.longs === String ? String(message.contextId) : message.contextId;
                else
                    object.contextId = options.longs === String ? $util.Long.prototype.toString.call(message.contextId) : options.longs === Number ? new $util.LongBits(message.contextId.low >>> 0, message.contextId.high >>> 0).toNumber() : message.contextId;
            return object;
        };

        /**
         * Converts this GetChildrenContextsByContextRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetChildrenContextsByContextRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetChildrenContextsByContextRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetChildrenContextsByContextRequest;
    })();

    ml_metadata.GetChildrenContextsByContextResponse = (function() {

        /**
         * Properties of a GetChildrenContextsByContextResponse.
         * @memberof ml_metadata
         * @interface IGetChildrenContextsByContextResponse
         * @property {Array.<ml_metadata.IContext>|null} [contexts] GetChildrenContextsByContextResponse contexts
         */

        /**
         * Constructs a new GetChildrenContextsByContextResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetChildrenContextsByContextResponse.
         * @implements IGetChildrenContextsByContextResponse
         * @constructor
         * @param {ml_metadata.IGetChildrenContextsByContextResponse=} [properties] Properties to set
         */
        function GetChildrenContextsByContextResponse(properties) {
            this.contexts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetChildrenContextsByContextResponse contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @instance
         */
        GetChildrenContextsByContextResponse.prototype.contexts = $util.emptyArray;

        /**
         * Creates a new GetChildrenContextsByContextResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @static
         * @param {ml_metadata.IGetChildrenContextsByContextResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetChildrenContextsByContextResponse} GetChildrenContextsByContextResponse instance
         */
        GetChildrenContextsByContextResponse.create = function create(properties) {
            return new GetChildrenContextsByContextResponse(properties);
        };

        /**
         * Encodes the specified GetChildrenContextsByContextResponse message. Does not implicitly {@link ml_metadata.GetChildrenContextsByContextResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @static
         * @param {ml_metadata.IGetChildrenContextsByContextResponse} message GetChildrenContextsByContextResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetChildrenContextsByContextResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetChildrenContextsByContextResponse message, length delimited. Does not implicitly {@link ml_metadata.GetChildrenContextsByContextResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @static
         * @param {ml_metadata.IGetChildrenContextsByContextResponse} message GetChildrenContextsByContextResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetChildrenContextsByContextResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetChildrenContextsByContextResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetChildrenContextsByContextResponse} GetChildrenContextsByContextResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetChildrenContextsByContextResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetChildrenContextsByContextResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetChildrenContextsByContextResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetChildrenContextsByContextResponse} GetChildrenContextsByContextResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetChildrenContextsByContextResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetChildrenContextsByContextResponse message.
         * @function verify
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetChildrenContextsByContextResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetChildrenContextsByContextResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetChildrenContextsByContextResponse} GetChildrenContextsByContextResponse
         */
        GetChildrenContextsByContextResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetChildrenContextsByContextResponse)
                return object;
            var message = new $root.ml_metadata.GetChildrenContextsByContextResponse();
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.GetChildrenContextsByContextResponse.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.GetChildrenContextsByContextResponse.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetChildrenContextsByContextResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @static
         * @param {ml_metadata.GetChildrenContextsByContextResponse} message GetChildrenContextsByContextResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetChildrenContextsByContextResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contexts = [];
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            return object;
        };

        /**
         * Converts this GetChildrenContextsByContextResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetChildrenContextsByContextResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetChildrenContextsByContextResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetChildrenContextsByContextResponse;
    })();

    ml_metadata.GetArtifactsByContextRequest = (function() {

        /**
         * Properties of a GetArtifactsByContextRequest.
         * @memberof ml_metadata
         * @interface IGetArtifactsByContextRequest
         * @property {number|Long|null} [contextId] GetArtifactsByContextRequest contextId
         * @property {ml_metadata.IListOperationOptions|null} [options] GetArtifactsByContextRequest options
         */

        /**
         * Constructs a new GetArtifactsByContextRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsByContextRequest.
         * @implements IGetArtifactsByContextRequest
         * @constructor
         * @param {ml_metadata.IGetArtifactsByContextRequest=} [properties] Properties to set
         */
        function GetArtifactsByContextRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsByContextRequest contextId.
         * @member {number|Long} contextId
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @instance
         */
        GetArtifactsByContextRequest.prototype.contextId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GetArtifactsByContextRequest options.
         * @member {ml_metadata.IListOperationOptions|null|undefined} options
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @instance
         */
        GetArtifactsByContextRequest.prototype.options = null;

        /**
         * Creates a new GetArtifactsByContextRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByContextRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsByContextRequest} GetArtifactsByContextRequest instance
         */
        GetArtifactsByContextRequest.create = function create(properties) {
            return new GetArtifactsByContextRequest(properties);
        };

        /**
         * Encodes the specified GetArtifactsByContextRequest message. Does not implicitly {@link ml_metadata.GetArtifactsByContextRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByContextRequest} message GetArtifactsByContextRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByContextRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.contextId);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.ml_metadata.ListOperationOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsByContextRequest message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsByContextRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @static
         * @param {ml_metadata.IGetArtifactsByContextRequest} message GetArtifactsByContextRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByContextRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsByContextRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsByContextRequest} GetArtifactsByContextRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByContextRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsByContextRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contextId = reader.int64();
                    break;
                case 2:
                    message.options = $root.ml_metadata.ListOperationOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsByContextRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsByContextRequest} GetArtifactsByContextRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByContextRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsByContextRequest message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsByContextRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (!$util.isInteger(message.contextId) && !(message.contextId && $util.isInteger(message.contextId.low) && $util.isInteger(message.contextId.high)))
                    return "contextId: integer|Long expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.ml_metadata.ListOperationOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a GetArtifactsByContextRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsByContextRequest} GetArtifactsByContextRequest
         */
        GetArtifactsByContextRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsByContextRequest)
                return object;
            var message = new $root.ml_metadata.GetArtifactsByContextRequest();
            if (object.contextId != null)
                if ($util.Long)
                    (message.contextId = $util.Long.fromValue(object.contextId)).unsigned = false;
                else if (typeof object.contextId === "string")
                    message.contextId = parseInt(object.contextId, 10);
                else if (typeof object.contextId === "number")
                    message.contextId = object.contextId;
                else if (typeof object.contextId === "object")
                    message.contextId = new $util.LongBits(object.contextId.low >>> 0, object.contextId.high >>> 0).toNumber();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".ml_metadata.GetArtifactsByContextRequest.options: object expected");
                message.options = $root.ml_metadata.ListOperationOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsByContextRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @static
         * @param {ml_metadata.GetArtifactsByContextRequest} message GetArtifactsByContextRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsByContextRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.contextId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.contextId = options.longs === String ? "0" : 0;
                object.options = null;
            }
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (typeof message.contextId === "number")
                    object.contextId = options.longs === String ? String(message.contextId) : message.contextId;
                else
                    object.contextId = options.longs === String ? $util.Long.prototype.toString.call(message.contextId) : options.longs === Number ? new $util.LongBits(message.contextId.low >>> 0, message.contextId.high >>> 0).toNumber() : message.contextId;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.ml_metadata.ListOperationOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this GetArtifactsByContextRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsByContextRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsByContextRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsByContextRequest;
    })();

    ml_metadata.GetArtifactsByContextResponse = (function() {

        /**
         * Properties of a GetArtifactsByContextResponse.
         * @memberof ml_metadata
         * @interface IGetArtifactsByContextResponse
         * @property {Array.<ml_metadata.IArtifact>|null} [artifacts] GetArtifactsByContextResponse artifacts
         * @property {string|null} [nextPageToken] GetArtifactsByContextResponse nextPageToken
         */

        /**
         * Constructs a new GetArtifactsByContextResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetArtifactsByContextResponse.
         * @implements IGetArtifactsByContextResponse
         * @constructor
         * @param {ml_metadata.IGetArtifactsByContextResponse=} [properties] Properties to set
         */
        function GetArtifactsByContextResponse(properties) {
            this.artifacts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetArtifactsByContextResponse artifacts.
         * @member {Array.<ml_metadata.IArtifact>} artifacts
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @instance
         */
        GetArtifactsByContextResponse.prototype.artifacts = $util.emptyArray;

        /**
         * GetArtifactsByContextResponse nextPageToken.
         * @member {string} nextPageToken
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @instance
         */
        GetArtifactsByContextResponse.prototype.nextPageToken = "";

        /**
         * Creates a new GetArtifactsByContextResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByContextResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetArtifactsByContextResponse} GetArtifactsByContextResponse instance
         */
        GetArtifactsByContextResponse.create = function create(properties) {
            return new GetArtifactsByContextResponse(properties);
        };

        /**
         * Encodes the specified GetArtifactsByContextResponse message. Does not implicitly {@link ml_metadata.GetArtifactsByContextResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByContextResponse} message GetArtifactsByContextResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByContextResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifacts != null && message.artifacts.length)
                for (var i = 0; i < message.artifacts.length; ++i)
                    $root.ml_metadata.Artifact.encode(message.artifacts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageToken);
            return writer;
        };

        /**
         * Encodes the specified GetArtifactsByContextResponse message, length delimited. Does not implicitly {@link ml_metadata.GetArtifactsByContextResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @static
         * @param {ml_metadata.IGetArtifactsByContextResponse} message GetArtifactsByContextResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetArtifactsByContextResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetArtifactsByContextResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetArtifactsByContextResponse} GetArtifactsByContextResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByContextResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetArtifactsByContextResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifacts && message.artifacts.length))
                        message.artifacts = [];
                    message.artifacts.push($root.ml_metadata.Artifact.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetArtifactsByContextResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetArtifactsByContextResponse} GetArtifactsByContextResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetArtifactsByContextResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetArtifactsByContextResponse message.
         * @function verify
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetArtifactsByContextResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifacts != null && message.hasOwnProperty("artifacts")) {
                if (!Array.isArray(message.artifacts))
                    return "artifacts: array expected";
                for (var i = 0; i < message.artifacts.length; ++i) {
                    var error = $root.ml_metadata.Artifact.verify(message.artifacts[i]);
                    if (error)
                        return "artifacts." + error;
                }
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                if (!$util.isString(message.nextPageToken))
                    return "nextPageToken: string expected";
            return null;
        };

        /**
         * Creates a GetArtifactsByContextResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetArtifactsByContextResponse} GetArtifactsByContextResponse
         */
        GetArtifactsByContextResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetArtifactsByContextResponse)
                return object;
            var message = new $root.ml_metadata.GetArtifactsByContextResponse();
            if (object.artifacts) {
                if (!Array.isArray(object.artifacts))
                    throw TypeError(".ml_metadata.GetArtifactsByContextResponse.artifacts: array expected");
                message.artifacts = [];
                for (var i = 0; i < object.artifacts.length; ++i) {
                    if (typeof object.artifacts[i] !== "object")
                        throw TypeError(".ml_metadata.GetArtifactsByContextResponse.artifacts: object expected");
                    message.artifacts[i] = $root.ml_metadata.Artifact.fromObject(object.artifacts[i]);
                }
            }
            if (object.nextPageToken != null)
                message.nextPageToken = String(object.nextPageToken);
            return message;
        };

        /**
         * Creates a plain object from a GetArtifactsByContextResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @static
         * @param {ml_metadata.GetArtifactsByContextResponse} message GetArtifactsByContextResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetArtifactsByContextResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.artifacts = [];
            if (options.defaults)
                object.nextPageToken = "";
            if (message.artifacts && message.artifacts.length) {
                object.artifacts = [];
                for (var j = 0; j < message.artifacts.length; ++j)
                    object.artifacts[j] = $root.ml_metadata.Artifact.toObject(message.artifacts[j], options);
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                object.nextPageToken = message.nextPageToken;
            return object;
        };

        /**
         * Converts this GetArtifactsByContextResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetArtifactsByContextResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetArtifactsByContextResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetArtifactsByContextResponse;
    })();

    ml_metadata.GetExecutionsByContextRequest = (function() {

        /**
         * Properties of a GetExecutionsByContextRequest.
         * @memberof ml_metadata
         * @interface IGetExecutionsByContextRequest
         * @property {number|Long|null} [contextId] GetExecutionsByContextRequest contextId
         * @property {ml_metadata.IListOperationOptions|null} [options] GetExecutionsByContextRequest options
         */

        /**
         * Constructs a new GetExecutionsByContextRequest.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionsByContextRequest.
         * @implements IGetExecutionsByContextRequest
         * @constructor
         * @param {ml_metadata.IGetExecutionsByContextRequest=} [properties] Properties to set
         */
        function GetExecutionsByContextRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionsByContextRequest contextId.
         * @member {number|Long} contextId
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @instance
         */
        GetExecutionsByContextRequest.prototype.contextId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GetExecutionsByContextRequest options.
         * @member {ml_metadata.IListOperationOptions|null|undefined} options
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @instance
         */
        GetExecutionsByContextRequest.prototype.options = null;

        /**
         * Creates a new GetExecutionsByContextRequest instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @static
         * @param {ml_metadata.IGetExecutionsByContextRequest=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionsByContextRequest} GetExecutionsByContextRequest instance
         */
        GetExecutionsByContextRequest.create = function create(properties) {
            return new GetExecutionsByContextRequest(properties);
        };

        /**
         * Encodes the specified GetExecutionsByContextRequest message. Does not implicitly {@link ml_metadata.GetExecutionsByContextRequest.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @static
         * @param {ml_metadata.IGetExecutionsByContextRequest} message GetExecutionsByContextRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByContextRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.contextId);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.ml_metadata.ListOperationOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetExecutionsByContextRequest message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionsByContextRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @static
         * @param {ml_metadata.IGetExecutionsByContextRequest} message GetExecutionsByContextRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByContextRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionsByContextRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionsByContextRequest} GetExecutionsByContextRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByContextRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionsByContextRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contextId = reader.int64();
                    break;
                case 2:
                    message.options = $root.ml_metadata.ListOperationOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionsByContextRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionsByContextRequest} GetExecutionsByContextRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByContextRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionsByContextRequest message.
         * @function verify
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionsByContextRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (!$util.isInteger(message.contextId) && !(message.contextId && $util.isInteger(message.contextId.low) && $util.isInteger(message.contextId.high)))
                    return "contextId: integer|Long expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.ml_metadata.ListOperationOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a GetExecutionsByContextRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionsByContextRequest} GetExecutionsByContextRequest
         */
        GetExecutionsByContextRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionsByContextRequest)
                return object;
            var message = new $root.ml_metadata.GetExecutionsByContextRequest();
            if (object.contextId != null)
                if ($util.Long)
                    (message.contextId = $util.Long.fromValue(object.contextId)).unsigned = false;
                else if (typeof object.contextId === "string")
                    message.contextId = parseInt(object.contextId, 10);
                else if (typeof object.contextId === "number")
                    message.contextId = object.contextId;
                else if (typeof object.contextId === "object")
                    message.contextId = new $util.LongBits(object.contextId.low >>> 0, object.contextId.high >>> 0).toNumber();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".ml_metadata.GetExecutionsByContextRequest.options: object expected");
                message.options = $root.ml_metadata.ListOperationOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionsByContextRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @static
         * @param {ml_metadata.GetExecutionsByContextRequest} message GetExecutionsByContextRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionsByContextRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.contextId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.contextId = options.longs === String ? "0" : 0;
                object.options = null;
            }
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (typeof message.contextId === "number")
                    object.contextId = options.longs === String ? String(message.contextId) : message.contextId;
                else
                    object.contextId = options.longs === String ? $util.Long.prototype.toString.call(message.contextId) : options.longs === Number ? new $util.LongBits(message.contextId.low >>> 0, message.contextId.high >>> 0).toNumber() : message.contextId;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.ml_metadata.ListOperationOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this GetExecutionsByContextRequest to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionsByContextRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionsByContextRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionsByContextRequest;
    })();

    ml_metadata.GetExecutionsByContextResponse = (function() {

        /**
         * Properties of a GetExecutionsByContextResponse.
         * @memberof ml_metadata
         * @interface IGetExecutionsByContextResponse
         * @property {Array.<ml_metadata.IExecution>|null} [executions] GetExecutionsByContextResponse executions
         * @property {string|null} [nextPageToken] GetExecutionsByContextResponse nextPageToken
         */

        /**
         * Constructs a new GetExecutionsByContextResponse.
         * @memberof ml_metadata
         * @classdesc Represents a GetExecutionsByContextResponse.
         * @implements IGetExecutionsByContextResponse
         * @constructor
         * @param {ml_metadata.IGetExecutionsByContextResponse=} [properties] Properties to set
         */
        function GetExecutionsByContextResponse(properties) {
            this.executions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExecutionsByContextResponse executions.
         * @member {Array.<ml_metadata.IExecution>} executions
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @instance
         */
        GetExecutionsByContextResponse.prototype.executions = $util.emptyArray;

        /**
         * GetExecutionsByContextResponse nextPageToken.
         * @member {string} nextPageToken
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @instance
         */
        GetExecutionsByContextResponse.prototype.nextPageToken = "";

        /**
         * Creates a new GetExecutionsByContextResponse instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @static
         * @param {ml_metadata.IGetExecutionsByContextResponse=} [properties] Properties to set
         * @returns {ml_metadata.GetExecutionsByContextResponse} GetExecutionsByContextResponse instance
         */
        GetExecutionsByContextResponse.create = function create(properties) {
            return new GetExecutionsByContextResponse(properties);
        };

        /**
         * Encodes the specified GetExecutionsByContextResponse message. Does not implicitly {@link ml_metadata.GetExecutionsByContextResponse.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @static
         * @param {ml_metadata.IGetExecutionsByContextResponse} message GetExecutionsByContextResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByContextResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executions != null && message.executions.length)
                for (var i = 0; i < message.executions.length; ++i)
                    $root.ml_metadata.Execution.encode(message.executions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageToken);
            return writer;
        };

        /**
         * Encodes the specified GetExecutionsByContextResponse message, length delimited. Does not implicitly {@link ml_metadata.GetExecutionsByContextResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @static
         * @param {ml_metadata.IGetExecutionsByContextResponse} message GetExecutionsByContextResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExecutionsByContextResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExecutionsByContextResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GetExecutionsByContextResponse} GetExecutionsByContextResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByContextResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GetExecutionsByContextResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executions && message.executions.length))
                        message.executions = [];
                    message.executions.push($root.ml_metadata.Execution.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExecutionsByContextResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GetExecutionsByContextResponse} GetExecutionsByContextResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExecutionsByContextResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExecutionsByContextResponse message.
         * @function verify
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExecutionsByContextResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executions != null && message.hasOwnProperty("executions")) {
                if (!Array.isArray(message.executions))
                    return "executions: array expected";
                for (var i = 0; i < message.executions.length; ++i) {
                    var error = $root.ml_metadata.Execution.verify(message.executions[i]);
                    if (error)
                        return "executions." + error;
                }
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                if (!$util.isString(message.nextPageToken))
                    return "nextPageToken: string expected";
            return null;
        };

        /**
         * Creates a GetExecutionsByContextResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GetExecutionsByContextResponse} GetExecutionsByContextResponse
         */
        GetExecutionsByContextResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GetExecutionsByContextResponse)
                return object;
            var message = new $root.ml_metadata.GetExecutionsByContextResponse();
            if (object.executions) {
                if (!Array.isArray(object.executions))
                    throw TypeError(".ml_metadata.GetExecutionsByContextResponse.executions: array expected");
                message.executions = [];
                for (var i = 0; i < object.executions.length; ++i) {
                    if (typeof object.executions[i] !== "object")
                        throw TypeError(".ml_metadata.GetExecutionsByContextResponse.executions: object expected");
                    message.executions[i] = $root.ml_metadata.Execution.fromObject(object.executions[i]);
                }
            }
            if (object.nextPageToken != null)
                message.nextPageToken = String(object.nextPageToken);
            return message;
        };

        /**
         * Creates a plain object from a GetExecutionsByContextResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @static
         * @param {ml_metadata.GetExecutionsByContextResponse} message GetExecutionsByContextResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExecutionsByContextResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.executions = [];
            if (options.defaults)
                object.nextPageToken = "";
            if (message.executions && message.executions.length) {
                object.executions = [];
                for (var j = 0; j < message.executions.length; ++j)
                    object.executions[j] = $root.ml_metadata.Execution.toObject(message.executions[j], options);
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                object.nextPageToken = message.nextPageToken;
            return object;
        };

        /**
         * Converts this GetExecutionsByContextResponse to JSON.
         * @function toJSON
         * @memberof ml_metadata.GetExecutionsByContextResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExecutionsByContextResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetExecutionsByContextResponse;
    })();

    ml_metadata.MetadataStoreService = (function() {

        /**
         * Constructs a new MetadataStoreService service.
         * @memberof ml_metadata
         * @classdesc Represents a MetadataStoreService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function MetadataStoreService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (MetadataStoreService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MetadataStoreService;

        /**
         * Creates new MetadataStoreService service using the specified rpc implementation.
         * @function create
         * @memberof ml_metadata.MetadataStoreService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {MetadataStoreService} RPC service. Useful where requests and/or responses are streamed.
         */
        MetadataStoreService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putArtifactType}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutArtifactTypeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutArtifactTypeResponse} [response] PutArtifactTypeResponse
         */

        /**
         * Calls PutArtifactType.
         * @function putArtifactType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutArtifactTypeRequest} request PutArtifactTypeRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutArtifactTypeCallback} callback Node-style callback called with the error, if any, and PutArtifactTypeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putArtifactType = function putArtifactType(request, callback) {
            return this.rpcCall(putArtifactType, $root.ml_metadata.PutArtifactTypeRequest, $root.ml_metadata.PutArtifactTypeResponse, request, callback);
        }, "name", { value: "PutArtifactType" });

        /**
         * Calls PutArtifactType.
         * @function putArtifactType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutArtifactTypeRequest} request PutArtifactTypeRequest message or plain object
         * @returns {Promise<ml_metadata.PutArtifactTypeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putExecutionType}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutExecutionTypeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutExecutionTypeResponse} [response] PutExecutionTypeResponse
         */

        /**
         * Calls PutExecutionType.
         * @function putExecutionType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutExecutionTypeRequest} request PutExecutionTypeRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutExecutionTypeCallback} callback Node-style callback called with the error, if any, and PutExecutionTypeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putExecutionType = function putExecutionType(request, callback) {
            return this.rpcCall(putExecutionType, $root.ml_metadata.PutExecutionTypeRequest, $root.ml_metadata.PutExecutionTypeResponse, request, callback);
        }, "name", { value: "PutExecutionType" });

        /**
         * Calls PutExecutionType.
         * @function putExecutionType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutExecutionTypeRequest} request PutExecutionTypeRequest message or plain object
         * @returns {Promise<ml_metadata.PutExecutionTypeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putContextType}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutContextTypeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutContextTypeResponse} [response] PutContextTypeResponse
         */

        /**
         * Calls PutContextType.
         * @function putContextType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutContextTypeRequest} request PutContextTypeRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutContextTypeCallback} callback Node-style callback called with the error, if any, and PutContextTypeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putContextType = function putContextType(request, callback) {
            return this.rpcCall(putContextType, $root.ml_metadata.PutContextTypeRequest, $root.ml_metadata.PutContextTypeResponse, request, callback);
        }, "name", { value: "PutContextType" });

        /**
         * Calls PutContextType.
         * @function putContextType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutContextTypeRequest} request PutContextTypeRequest message or plain object
         * @returns {Promise<ml_metadata.PutContextTypeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putTypes}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutTypesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutTypesResponse} [response] PutTypesResponse
         */

        /**
         * Calls PutTypes.
         * @function putTypes
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutTypesRequest} request PutTypesRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutTypesCallback} callback Node-style callback called with the error, if any, and PutTypesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putTypes = function putTypes(request, callback) {
            return this.rpcCall(putTypes, $root.ml_metadata.PutTypesRequest, $root.ml_metadata.PutTypesResponse, request, callback);
        }, "name", { value: "PutTypes" });

        /**
         * Calls PutTypes.
         * @function putTypes
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutTypesRequest} request PutTypesRequest message or plain object
         * @returns {Promise<ml_metadata.PutTypesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putArtifacts}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutArtifactsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutArtifactsResponse} [response] PutArtifactsResponse
         */

        /**
         * Calls PutArtifacts.
         * @function putArtifacts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutArtifactsRequest} request PutArtifactsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutArtifactsCallback} callback Node-style callback called with the error, if any, and PutArtifactsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putArtifacts = function putArtifacts(request, callback) {
            return this.rpcCall(putArtifacts, $root.ml_metadata.PutArtifactsRequest, $root.ml_metadata.PutArtifactsResponse, request, callback);
        }, "name", { value: "PutArtifacts" });

        /**
         * Calls PutArtifacts.
         * @function putArtifacts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutArtifactsRequest} request PutArtifactsRequest message or plain object
         * @returns {Promise<ml_metadata.PutArtifactsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putExecutions}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutExecutionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutExecutionsResponse} [response] PutExecutionsResponse
         */

        /**
         * Calls PutExecutions.
         * @function putExecutions
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutExecutionsRequest} request PutExecutionsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutExecutionsCallback} callback Node-style callback called with the error, if any, and PutExecutionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putExecutions = function putExecutions(request, callback) {
            return this.rpcCall(putExecutions, $root.ml_metadata.PutExecutionsRequest, $root.ml_metadata.PutExecutionsResponse, request, callback);
        }, "name", { value: "PutExecutions" });

        /**
         * Calls PutExecutions.
         * @function putExecutions
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutExecutionsRequest} request PutExecutionsRequest message or plain object
         * @returns {Promise<ml_metadata.PutExecutionsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putEvents}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutEventsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutEventsResponse} [response] PutEventsResponse
         */

        /**
         * Calls PutEvents.
         * @function putEvents
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutEventsRequest} request PutEventsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutEventsCallback} callback Node-style callback called with the error, if any, and PutEventsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putEvents = function putEvents(request, callback) {
            return this.rpcCall(putEvents, $root.ml_metadata.PutEventsRequest, $root.ml_metadata.PutEventsResponse, request, callback);
        }, "name", { value: "PutEvents" });

        /**
         * Calls PutEvents.
         * @function putEvents
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutEventsRequest} request PutEventsRequest message or plain object
         * @returns {Promise<ml_metadata.PutEventsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putExecution}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutExecutionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutExecutionResponse} [response] PutExecutionResponse
         */

        /**
         * Calls PutExecution.
         * @function putExecution
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutExecutionRequest} request PutExecutionRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutExecutionCallback} callback Node-style callback called with the error, if any, and PutExecutionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putExecution = function putExecution(request, callback) {
            return this.rpcCall(putExecution, $root.ml_metadata.PutExecutionRequest, $root.ml_metadata.PutExecutionResponse, request, callback);
        }, "name", { value: "PutExecution" });

        /**
         * Calls PutExecution.
         * @function putExecution
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutExecutionRequest} request PutExecutionRequest message or plain object
         * @returns {Promise<ml_metadata.PutExecutionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putContexts}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutContextsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutContextsResponse} [response] PutContextsResponse
         */

        /**
         * Calls PutContexts.
         * @function putContexts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutContextsRequest} request PutContextsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutContextsCallback} callback Node-style callback called with the error, if any, and PutContextsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putContexts = function putContexts(request, callback) {
            return this.rpcCall(putContexts, $root.ml_metadata.PutContextsRequest, $root.ml_metadata.PutContextsResponse, request, callback);
        }, "name", { value: "PutContexts" });

        /**
         * Calls PutContexts.
         * @function putContexts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutContextsRequest} request PutContextsRequest message or plain object
         * @returns {Promise<ml_metadata.PutContextsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putAttributionsAndAssociations}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutAttributionsAndAssociationsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutAttributionsAndAssociationsResponse} [response] PutAttributionsAndAssociationsResponse
         */

        /**
         * Calls PutAttributionsAndAssociations.
         * @function putAttributionsAndAssociations
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutAttributionsAndAssociationsRequest} request PutAttributionsAndAssociationsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutAttributionsAndAssociationsCallback} callback Node-style callback called with the error, if any, and PutAttributionsAndAssociationsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putAttributionsAndAssociations = function putAttributionsAndAssociations(request, callback) {
            return this.rpcCall(putAttributionsAndAssociations, $root.ml_metadata.PutAttributionsAndAssociationsRequest, $root.ml_metadata.PutAttributionsAndAssociationsResponse, request, callback);
        }, "name", { value: "PutAttributionsAndAssociations" });

        /**
         * Calls PutAttributionsAndAssociations.
         * @function putAttributionsAndAssociations
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutAttributionsAndAssociationsRequest} request PutAttributionsAndAssociationsRequest message or plain object
         * @returns {Promise<ml_metadata.PutAttributionsAndAssociationsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#putParentContexts}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef PutParentContextsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.PutParentContextsResponse} [response] PutParentContextsResponse
         */

        /**
         * Calls PutParentContexts.
         * @function putParentContexts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutParentContextsRequest} request PutParentContextsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.PutParentContextsCallback} callback Node-style callback called with the error, if any, and PutParentContextsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.putParentContexts = function putParentContexts(request, callback) {
            return this.rpcCall(putParentContexts, $root.ml_metadata.PutParentContextsRequest, $root.ml_metadata.PutParentContextsResponse, request, callback);
        }, "name", { value: "PutParentContexts" });

        /**
         * Calls PutParentContexts.
         * @function putParentContexts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IPutParentContextsRequest} request PutParentContextsRequest message or plain object
         * @returns {Promise<ml_metadata.PutParentContextsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getArtifactType}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetArtifactTypeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetArtifactTypeResponse} [response] GetArtifactTypeResponse
         */

        /**
         * Calls GetArtifactType.
         * @function getArtifactType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactTypeRequest} request GetArtifactTypeRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetArtifactTypeCallback} callback Node-style callback called with the error, if any, and GetArtifactTypeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getArtifactType = function getArtifactType(request, callback) {
            return this.rpcCall(getArtifactType, $root.ml_metadata.GetArtifactTypeRequest, $root.ml_metadata.GetArtifactTypeResponse, request, callback);
        }, "name", { value: "GetArtifactType" });

        /**
         * Calls GetArtifactType.
         * @function getArtifactType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactTypeRequest} request GetArtifactTypeRequest message or plain object
         * @returns {Promise<ml_metadata.GetArtifactTypeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getArtifactTypesByID}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetArtifactTypesByIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetArtifactTypesByIDResponse} [response] GetArtifactTypesByIDResponse
         */

        /**
         * Calls GetArtifactTypesByID.
         * @function getArtifactTypesByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactTypesByIDRequest} request GetArtifactTypesByIDRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetArtifactTypesByIDCallback} callback Node-style callback called with the error, if any, and GetArtifactTypesByIDResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getArtifactTypesByID = function getArtifactTypesByID(request, callback) {
            return this.rpcCall(getArtifactTypesByID, $root.ml_metadata.GetArtifactTypesByIDRequest, $root.ml_metadata.GetArtifactTypesByIDResponse, request, callback);
        }, "name", { value: "GetArtifactTypesByID" });

        /**
         * Calls GetArtifactTypesByID.
         * @function getArtifactTypesByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactTypesByIDRequest} request GetArtifactTypesByIDRequest message or plain object
         * @returns {Promise<ml_metadata.GetArtifactTypesByIDResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getArtifactTypes}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetArtifactTypesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetArtifactTypesResponse} [response] GetArtifactTypesResponse
         */

        /**
         * Calls GetArtifactTypes.
         * @function getArtifactTypes
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactTypesRequest} request GetArtifactTypesRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetArtifactTypesCallback} callback Node-style callback called with the error, if any, and GetArtifactTypesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getArtifactTypes = function getArtifactTypes(request, callback) {
            return this.rpcCall(getArtifactTypes, $root.ml_metadata.GetArtifactTypesRequest, $root.ml_metadata.GetArtifactTypesResponse, request, callback);
        }, "name", { value: "GetArtifactTypes" });

        /**
         * Calls GetArtifactTypes.
         * @function getArtifactTypes
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactTypesRequest} request GetArtifactTypesRequest message or plain object
         * @returns {Promise<ml_metadata.GetArtifactTypesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getExecutionType}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetExecutionTypeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetExecutionTypeResponse} [response] GetExecutionTypeResponse
         */

        /**
         * Calls GetExecutionType.
         * @function getExecutionType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionTypeRequest} request GetExecutionTypeRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetExecutionTypeCallback} callback Node-style callback called with the error, if any, and GetExecutionTypeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getExecutionType = function getExecutionType(request, callback) {
            return this.rpcCall(getExecutionType, $root.ml_metadata.GetExecutionTypeRequest, $root.ml_metadata.GetExecutionTypeResponse, request, callback);
        }, "name", { value: "GetExecutionType" });

        /**
         * Calls GetExecutionType.
         * @function getExecutionType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionTypeRequest} request GetExecutionTypeRequest message or plain object
         * @returns {Promise<ml_metadata.GetExecutionTypeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getExecutionTypesByID}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetExecutionTypesByIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetExecutionTypesByIDResponse} [response] GetExecutionTypesByIDResponse
         */

        /**
         * Calls GetExecutionTypesByID.
         * @function getExecutionTypesByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionTypesByIDRequest} request GetExecutionTypesByIDRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetExecutionTypesByIDCallback} callback Node-style callback called with the error, if any, and GetExecutionTypesByIDResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getExecutionTypesByID = function getExecutionTypesByID(request, callback) {
            return this.rpcCall(getExecutionTypesByID, $root.ml_metadata.GetExecutionTypesByIDRequest, $root.ml_metadata.GetExecutionTypesByIDResponse, request, callback);
        }, "name", { value: "GetExecutionTypesByID" });

        /**
         * Calls GetExecutionTypesByID.
         * @function getExecutionTypesByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionTypesByIDRequest} request GetExecutionTypesByIDRequest message or plain object
         * @returns {Promise<ml_metadata.GetExecutionTypesByIDResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getExecutionTypes}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetExecutionTypesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetExecutionTypesResponse} [response] GetExecutionTypesResponse
         */

        /**
         * Calls GetExecutionTypes.
         * @function getExecutionTypes
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionTypesRequest} request GetExecutionTypesRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetExecutionTypesCallback} callback Node-style callback called with the error, if any, and GetExecutionTypesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getExecutionTypes = function getExecutionTypes(request, callback) {
            return this.rpcCall(getExecutionTypes, $root.ml_metadata.GetExecutionTypesRequest, $root.ml_metadata.GetExecutionTypesResponse, request, callback);
        }, "name", { value: "GetExecutionTypes" });

        /**
         * Calls GetExecutionTypes.
         * @function getExecutionTypes
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionTypesRequest} request GetExecutionTypesRequest message or plain object
         * @returns {Promise<ml_metadata.GetExecutionTypesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getContextType}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetContextTypeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetContextTypeResponse} [response] GetContextTypeResponse
         */

        /**
         * Calls GetContextType.
         * @function getContextType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextTypeRequest} request GetContextTypeRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetContextTypeCallback} callback Node-style callback called with the error, if any, and GetContextTypeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getContextType = function getContextType(request, callback) {
            return this.rpcCall(getContextType, $root.ml_metadata.GetContextTypeRequest, $root.ml_metadata.GetContextTypeResponse, request, callback);
        }, "name", { value: "GetContextType" });

        /**
         * Calls GetContextType.
         * @function getContextType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextTypeRequest} request GetContextTypeRequest message or plain object
         * @returns {Promise<ml_metadata.GetContextTypeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getContextTypesByID}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetContextTypesByIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetContextTypesByIDResponse} [response] GetContextTypesByIDResponse
         */

        /**
         * Calls GetContextTypesByID.
         * @function getContextTypesByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextTypesByIDRequest} request GetContextTypesByIDRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetContextTypesByIDCallback} callback Node-style callback called with the error, if any, and GetContextTypesByIDResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getContextTypesByID = function getContextTypesByID(request, callback) {
            return this.rpcCall(getContextTypesByID, $root.ml_metadata.GetContextTypesByIDRequest, $root.ml_metadata.GetContextTypesByIDResponse, request, callback);
        }, "name", { value: "GetContextTypesByID" });

        /**
         * Calls GetContextTypesByID.
         * @function getContextTypesByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextTypesByIDRequest} request GetContextTypesByIDRequest message or plain object
         * @returns {Promise<ml_metadata.GetContextTypesByIDResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getContextTypes}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetContextTypesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetContextTypesResponse} [response] GetContextTypesResponse
         */

        /**
         * Calls GetContextTypes.
         * @function getContextTypes
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextTypesRequest} request GetContextTypesRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetContextTypesCallback} callback Node-style callback called with the error, if any, and GetContextTypesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getContextTypes = function getContextTypes(request, callback) {
            return this.rpcCall(getContextTypes, $root.ml_metadata.GetContextTypesRequest, $root.ml_metadata.GetContextTypesResponse, request, callback);
        }, "name", { value: "GetContextTypes" });

        /**
         * Calls GetContextTypes.
         * @function getContextTypes
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextTypesRequest} request GetContextTypesRequest message or plain object
         * @returns {Promise<ml_metadata.GetContextTypesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getArtifacts}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetArtifactsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetArtifactsResponse} [response] GetArtifactsResponse
         */

        /**
         * Calls GetArtifacts.
         * @function getArtifacts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsRequest} request GetArtifactsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetArtifactsCallback} callback Node-style callback called with the error, if any, and GetArtifactsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getArtifacts = function getArtifacts(request, callback) {
            return this.rpcCall(getArtifacts, $root.ml_metadata.GetArtifactsRequest, $root.ml_metadata.GetArtifactsResponse, request, callback);
        }, "name", { value: "GetArtifacts" });

        /**
         * Calls GetArtifacts.
         * @function getArtifacts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsRequest} request GetArtifactsRequest message or plain object
         * @returns {Promise<ml_metadata.GetArtifactsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getExecutions}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetExecutionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetExecutionsResponse} [response] GetExecutionsResponse
         */

        /**
         * Calls GetExecutions.
         * @function getExecutions
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionsRequest} request GetExecutionsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetExecutionsCallback} callback Node-style callback called with the error, if any, and GetExecutionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getExecutions = function getExecutions(request, callback) {
            return this.rpcCall(getExecutions, $root.ml_metadata.GetExecutionsRequest, $root.ml_metadata.GetExecutionsResponse, request, callback);
        }, "name", { value: "GetExecutions" });

        /**
         * Calls GetExecutions.
         * @function getExecutions
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionsRequest} request GetExecutionsRequest message or plain object
         * @returns {Promise<ml_metadata.GetExecutionsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getContexts}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetContextsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetContextsResponse} [response] GetContextsResponse
         */

        /**
         * Calls GetContexts.
         * @function getContexts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsRequest} request GetContextsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetContextsCallback} callback Node-style callback called with the error, if any, and GetContextsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getContexts = function getContexts(request, callback) {
            return this.rpcCall(getContexts, $root.ml_metadata.GetContextsRequest, $root.ml_metadata.GetContextsResponse, request, callback);
        }, "name", { value: "GetContexts" });

        /**
         * Calls GetContexts.
         * @function getContexts
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsRequest} request GetContextsRequest message or plain object
         * @returns {Promise<ml_metadata.GetContextsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getArtifactsByID}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetArtifactsByIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetArtifactsByIDResponse} [response] GetArtifactsByIDResponse
         */

        /**
         * Calls GetArtifactsByID.
         * @function getArtifactsByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsByIDRequest} request GetArtifactsByIDRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetArtifactsByIDCallback} callback Node-style callback called with the error, if any, and GetArtifactsByIDResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getArtifactsByID = function getArtifactsByID(request, callback) {
            return this.rpcCall(getArtifactsByID, $root.ml_metadata.GetArtifactsByIDRequest, $root.ml_metadata.GetArtifactsByIDResponse, request, callback);
        }, "name", { value: "GetArtifactsByID" });

        /**
         * Calls GetArtifactsByID.
         * @function getArtifactsByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsByIDRequest} request GetArtifactsByIDRequest message or plain object
         * @returns {Promise<ml_metadata.GetArtifactsByIDResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getExecutionsByID}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetExecutionsByIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetExecutionsByIDResponse} [response] GetExecutionsByIDResponse
         */

        /**
         * Calls GetExecutionsByID.
         * @function getExecutionsByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionsByIDRequest} request GetExecutionsByIDRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetExecutionsByIDCallback} callback Node-style callback called with the error, if any, and GetExecutionsByIDResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getExecutionsByID = function getExecutionsByID(request, callback) {
            return this.rpcCall(getExecutionsByID, $root.ml_metadata.GetExecutionsByIDRequest, $root.ml_metadata.GetExecutionsByIDResponse, request, callback);
        }, "name", { value: "GetExecutionsByID" });

        /**
         * Calls GetExecutionsByID.
         * @function getExecutionsByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionsByIDRequest} request GetExecutionsByIDRequest message or plain object
         * @returns {Promise<ml_metadata.GetExecutionsByIDResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getContextsByID}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetContextsByIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetContextsByIDResponse} [response] GetContextsByIDResponse
         */

        /**
         * Calls GetContextsByID.
         * @function getContextsByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsByIDRequest} request GetContextsByIDRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetContextsByIDCallback} callback Node-style callback called with the error, if any, and GetContextsByIDResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getContextsByID = function getContextsByID(request, callback) {
            return this.rpcCall(getContextsByID, $root.ml_metadata.GetContextsByIDRequest, $root.ml_metadata.GetContextsByIDResponse, request, callback);
        }, "name", { value: "GetContextsByID" });

        /**
         * Calls GetContextsByID.
         * @function getContextsByID
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsByIDRequest} request GetContextsByIDRequest message or plain object
         * @returns {Promise<ml_metadata.GetContextsByIDResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getArtifactsByType}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetArtifactsByTypeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetArtifactsByTypeResponse} [response] GetArtifactsByTypeResponse
         */

        /**
         * Calls GetArtifactsByType.
         * @function getArtifactsByType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsByTypeRequest} request GetArtifactsByTypeRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetArtifactsByTypeCallback} callback Node-style callback called with the error, if any, and GetArtifactsByTypeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getArtifactsByType = function getArtifactsByType(request, callback) {
            return this.rpcCall(getArtifactsByType, $root.ml_metadata.GetArtifactsByTypeRequest, $root.ml_metadata.GetArtifactsByTypeResponse, request, callback);
        }, "name", { value: "GetArtifactsByType" });

        /**
         * Calls GetArtifactsByType.
         * @function getArtifactsByType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsByTypeRequest} request GetArtifactsByTypeRequest message or plain object
         * @returns {Promise<ml_metadata.GetArtifactsByTypeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getExecutionsByType}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetExecutionsByTypeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetExecutionsByTypeResponse} [response] GetExecutionsByTypeResponse
         */

        /**
         * Calls GetExecutionsByType.
         * @function getExecutionsByType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionsByTypeRequest} request GetExecutionsByTypeRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetExecutionsByTypeCallback} callback Node-style callback called with the error, if any, and GetExecutionsByTypeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getExecutionsByType = function getExecutionsByType(request, callback) {
            return this.rpcCall(getExecutionsByType, $root.ml_metadata.GetExecutionsByTypeRequest, $root.ml_metadata.GetExecutionsByTypeResponse, request, callback);
        }, "name", { value: "GetExecutionsByType" });

        /**
         * Calls GetExecutionsByType.
         * @function getExecutionsByType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionsByTypeRequest} request GetExecutionsByTypeRequest message or plain object
         * @returns {Promise<ml_metadata.GetExecutionsByTypeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getContextsByType}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetContextsByTypeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetContextsByTypeResponse} [response] GetContextsByTypeResponse
         */

        /**
         * Calls GetContextsByType.
         * @function getContextsByType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsByTypeRequest} request GetContextsByTypeRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetContextsByTypeCallback} callback Node-style callback called with the error, if any, and GetContextsByTypeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getContextsByType = function getContextsByType(request, callback) {
            return this.rpcCall(getContextsByType, $root.ml_metadata.GetContextsByTypeRequest, $root.ml_metadata.GetContextsByTypeResponse, request, callback);
        }, "name", { value: "GetContextsByType" });

        /**
         * Calls GetContextsByType.
         * @function getContextsByType
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsByTypeRequest} request GetContextsByTypeRequest message or plain object
         * @returns {Promise<ml_metadata.GetContextsByTypeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getArtifactByTypeAndName}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetArtifactByTypeAndNameCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetArtifactByTypeAndNameResponse} [response] GetArtifactByTypeAndNameResponse
         */

        /**
         * Calls GetArtifactByTypeAndName.
         * @function getArtifactByTypeAndName
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactByTypeAndNameRequest} request GetArtifactByTypeAndNameRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetArtifactByTypeAndNameCallback} callback Node-style callback called with the error, if any, and GetArtifactByTypeAndNameResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getArtifactByTypeAndName = function getArtifactByTypeAndName(request, callback) {
            return this.rpcCall(getArtifactByTypeAndName, $root.ml_metadata.GetArtifactByTypeAndNameRequest, $root.ml_metadata.GetArtifactByTypeAndNameResponse, request, callback);
        }, "name", { value: "GetArtifactByTypeAndName" });

        /**
         * Calls GetArtifactByTypeAndName.
         * @function getArtifactByTypeAndName
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactByTypeAndNameRequest} request GetArtifactByTypeAndNameRequest message or plain object
         * @returns {Promise<ml_metadata.GetArtifactByTypeAndNameResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getExecutionByTypeAndName}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetExecutionByTypeAndNameCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetExecutionByTypeAndNameResponse} [response] GetExecutionByTypeAndNameResponse
         */

        /**
         * Calls GetExecutionByTypeAndName.
         * @function getExecutionByTypeAndName
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionByTypeAndNameRequest} request GetExecutionByTypeAndNameRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetExecutionByTypeAndNameCallback} callback Node-style callback called with the error, if any, and GetExecutionByTypeAndNameResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getExecutionByTypeAndName = function getExecutionByTypeAndName(request, callback) {
            return this.rpcCall(getExecutionByTypeAndName, $root.ml_metadata.GetExecutionByTypeAndNameRequest, $root.ml_metadata.GetExecutionByTypeAndNameResponse, request, callback);
        }, "name", { value: "GetExecutionByTypeAndName" });

        /**
         * Calls GetExecutionByTypeAndName.
         * @function getExecutionByTypeAndName
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionByTypeAndNameRequest} request GetExecutionByTypeAndNameRequest message or plain object
         * @returns {Promise<ml_metadata.GetExecutionByTypeAndNameResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getContextByTypeAndName}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetContextByTypeAndNameCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetContextByTypeAndNameResponse} [response] GetContextByTypeAndNameResponse
         */

        /**
         * Calls GetContextByTypeAndName.
         * @function getContextByTypeAndName
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextByTypeAndNameRequest} request GetContextByTypeAndNameRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetContextByTypeAndNameCallback} callback Node-style callback called with the error, if any, and GetContextByTypeAndNameResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getContextByTypeAndName = function getContextByTypeAndName(request, callback) {
            return this.rpcCall(getContextByTypeAndName, $root.ml_metadata.GetContextByTypeAndNameRequest, $root.ml_metadata.GetContextByTypeAndNameResponse, request, callback);
        }, "name", { value: "GetContextByTypeAndName" });

        /**
         * Calls GetContextByTypeAndName.
         * @function getContextByTypeAndName
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextByTypeAndNameRequest} request GetContextByTypeAndNameRequest message or plain object
         * @returns {Promise<ml_metadata.GetContextByTypeAndNameResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getArtifactsByURI}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetArtifactsByURICallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetArtifactsByURIResponse} [response] GetArtifactsByURIResponse
         */

        /**
         * Calls GetArtifactsByURI.
         * @function getArtifactsByURI
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsByURIRequest} request GetArtifactsByURIRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetArtifactsByURICallback} callback Node-style callback called with the error, if any, and GetArtifactsByURIResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getArtifactsByURI = function getArtifactsByURI(request, callback) {
            return this.rpcCall(getArtifactsByURI, $root.ml_metadata.GetArtifactsByURIRequest, $root.ml_metadata.GetArtifactsByURIResponse, request, callback);
        }, "name", { value: "GetArtifactsByURI" });

        /**
         * Calls GetArtifactsByURI.
         * @function getArtifactsByURI
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsByURIRequest} request GetArtifactsByURIRequest message or plain object
         * @returns {Promise<ml_metadata.GetArtifactsByURIResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getEventsByExecutionIDs}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetEventsByExecutionIDsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetEventsByExecutionIDsResponse} [response] GetEventsByExecutionIDsResponse
         */

        /**
         * Calls GetEventsByExecutionIDs.
         * @function getEventsByExecutionIDs
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetEventsByExecutionIDsRequest} request GetEventsByExecutionIDsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetEventsByExecutionIDsCallback} callback Node-style callback called with the error, if any, and GetEventsByExecutionIDsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getEventsByExecutionIDs = function getEventsByExecutionIDs(request, callback) {
            return this.rpcCall(getEventsByExecutionIDs, $root.ml_metadata.GetEventsByExecutionIDsRequest, $root.ml_metadata.GetEventsByExecutionIDsResponse, request, callback);
        }, "name", { value: "GetEventsByExecutionIDs" });

        /**
         * Calls GetEventsByExecutionIDs.
         * @function getEventsByExecutionIDs
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetEventsByExecutionIDsRequest} request GetEventsByExecutionIDsRequest message or plain object
         * @returns {Promise<ml_metadata.GetEventsByExecutionIDsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getEventsByArtifactIDs}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetEventsByArtifactIDsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetEventsByArtifactIDsResponse} [response] GetEventsByArtifactIDsResponse
         */

        /**
         * Calls GetEventsByArtifactIDs.
         * @function getEventsByArtifactIDs
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetEventsByArtifactIDsRequest} request GetEventsByArtifactIDsRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetEventsByArtifactIDsCallback} callback Node-style callback called with the error, if any, and GetEventsByArtifactIDsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getEventsByArtifactIDs = function getEventsByArtifactIDs(request, callback) {
            return this.rpcCall(getEventsByArtifactIDs, $root.ml_metadata.GetEventsByArtifactIDsRequest, $root.ml_metadata.GetEventsByArtifactIDsResponse, request, callback);
        }, "name", { value: "GetEventsByArtifactIDs" });

        /**
         * Calls GetEventsByArtifactIDs.
         * @function getEventsByArtifactIDs
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetEventsByArtifactIDsRequest} request GetEventsByArtifactIDsRequest message or plain object
         * @returns {Promise<ml_metadata.GetEventsByArtifactIDsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getContextsByArtifact}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetContextsByArtifactCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetContextsByArtifactResponse} [response] GetContextsByArtifactResponse
         */

        /**
         * Calls GetContextsByArtifact.
         * @function getContextsByArtifact
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsByArtifactRequest} request GetContextsByArtifactRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetContextsByArtifactCallback} callback Node-style callback called with the error, if any, and GetContextsByArtifactResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getContextsByArtifact = function getContextsByArtifact(request, callback) {
            return this.rpcCall(getContextsByArtifact, $root.ml_metadata.GetContextsByArtifactRequest, $root.ml_metadata.GetContextsByArtifactResponse, request, callback);
        }, "name", { value: "GetContextsByArtifact" });

        /**
         * Calls GetContextsByArtifact.
         * @function getContextsByArtifact
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsByArtifactRequest} request GetContextsByArtifactRequest message or plain object
         * @returns {Promise<ml_metadata.GetContextsByArtifactResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getContextsByExecution}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetContextsByExecutionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetContextsByExecutionResponse} [response] GetContextsByExecutionResponse
         */

        /**
         * Calls GetContextsByExecution.
         * @function getContextsByExecution
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsByExecutionRequest} request GetContextsByExecutionRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetContextsByExecutionCallback} callback Node-style callback called with the error, if any, and GetContextsByExecutionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getContextsByExecution = function getContextsByExecution(request, callback) {
            return this.rpcCall(getContextsByExecution, $root.ml_metadata.GetContextsByExecutionRequest, $root.ml_metadata.GetContextsByExecutionResponse, request, callback);
        }, "name", { value: "GetContextsByExecution" });

        /**
         * Calls GetContextsByExecution.
         * @function getContextsByExecution
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetContextsByExecutionRequest} request GetContextsByExecutionRequest message or plain object
         * @returns {Promise<ml_metadata.GetContextsByExecutionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getParentContextsByContext}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetParentContextsByContextCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetParentContextsByContextResponse} [response] GetParentContextsByContextResponse
         */

        /**
         * Calls GetParentContextsByContext.
         * @function getParentContextsByContext
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetParentContextsByContextRequest} request GetParentContextsByContextRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetParentContextsByContextCallback} callback Node-style callback called with the error, if any, and GetParentContextsByContextResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getParentContextsByContext = function getParentContextsByContext(request, callback) {
            return this.rpcCall(getParentContextsByContext, $root.ml_metadata.GetParentContextsByContextRequest, $root.ml_metadata.GetParentContextsByContextResponse, request, callback);
        }, "name", { value: "GetParentContextsByContext" });

        /**
         * Calls GetParentContextsByContext.
         * @function getParentContextsByContext
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetParentContextsByContextRequest} request GetParentContextsByContextRequest message or plain object
         * @returns {Promise<ml_metadata.GetParentContextsByContextResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getChildrenContextsByContext}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetChildrenContextsByContextCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetChildrenContextsByContextResponse} [response] GetChildrenContextsByContextResponse
         */

        /**
         * Calls GetChildrenContextsByContext.
         * @function getChildrenContextsByContext
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetChildrenContextsByContextRequest} request GetChildrenContextsByContextRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetChildrenContextsByContextCallback} callback Node-style callback called with the error, if any, and GetChildrenContextsByContextResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getChildrenContextsByContext = function getChildrenContextsByContext(request, callback) {
            return this.rpcCall(getChildrenContextsByContext, $root.ml_metadata.GetChildrenContextsByContextRequest, $root.ml_metadata.GetChildrenContextsByContextResponse, request, callback);
        }, "name", { value: "GetChildrenContextsByContext" });

        /**
         * Calls GetChildrenContextsByContext.
         * @function getChildrenContextsByContext
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetChildrenContextsByContextRequest} request GetChildrenContextsByContextRequest message or plain object
         * @returns {Promise<ml_metadata.GetChildrenContextsByContextResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getArtifactsByContext}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetArtifactsByContextCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetArtifactsByContextResponse} [response] GetArtifactsByContextResponse
         */

        /**
         * Calls GetArtifactsByContext.
         * @function getArtifactsByContext
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsByContextRequest} request GetArtifactsByContextRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetArtifactsByContextCallback} callback Node-style callback called with the error, if any, and GetArtifactsByContextResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getArtifactsByContext = function getArtifactsByContext(request, callback) {
            return this.rpcCall(getArtifactsByContext, $root.ml_metadata.GetArtifactsByContextRequest, $root.ml_metadata.GetArtifactsByContextResponse, request, callback);
        }, "name", { value: "GetArtifactsByContext" });

        /**
         * Calls GetArtifactsByContext.
         * @function getArtifactsByContext
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetArtifactsByContextRequest} request GetArtifactsByContextRequest message or plain object
         * @returns {Promise<ml_metadata.GetArtifactsByContextResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ml_metadata.MetadataStoreService#getExecutionsByContext}.
         * @memberof ml_metadata.MetadataStoreService
         * @typedef GetExecutionsByContextCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ml_metadata.GetExecutionsByContextResponse} [response] GetExecutionsByContextResponse
         */

        /**
         * Calls GetExecutionsByContext.
         * @function getExecutionsByContext
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionsByContextRequest} request GetExecutionsByContextRequest message or plain object
         * @param {ml_metadata.MetadataStoreService.GetExecutionsByContextCallback} callback Node-style callback called with the error, if any, and GetExecutionsByContextResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MetadataStoreService.prototype.getExecutionsByContext = function getExecutionsByContext(request, callback) {
            return this.rpcCall(getExecutionsByContext, $root.ml_metadata.GetExecutionsByContextRequest, $root.ml_metadata.GetExecutionsByContextResponse, request, callback);
        }, "name", { value: "GetExecutionsByContext" });

        /**
         * Calls GetExecutionsByContext.
         * @function getExecutionsByContext
         * @memberof ml_metadata.MetadataStoreService
         * @instance
         * @param {ml_metadata.IGetExecutionsByContextRequest} request GetExecutionsByContextRequest message or plain object
         * @returns {Promise<ml_metadata.GetExecutionsByContextResponse>} Promise
         * @variation 2
         */

        return MetadataStoreService;
    })();

    ml_metadata.Value = (function() {

        /**
         * Properties of a Value.
         * @memberof ml_metadata
         * @interface IValue
         * @property {number|Long|null} [intValue] Value intValue
         * @property {number|null} [doubleValue] Value doubleValue
         * @property {string|null} [stringValue] Value stringValue
         * @property {google.protobuf.IStruct|null} [structValue] Value structValue
         */

        /**
         * Constructs a new Value.
         * @memberof ml_metadata
         * @classdesc Represents a Value.
         * @implements IValue
         * @constructor
         * @param {ml_metadata.IValue=} [properties] Properties to set
         */
        function Value(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Value intValue.
         * @member {number|Long|null|undefined} intValue
         * @memberof ml_metadata.Value
         * @instance
         */
        Value.prototype.intValue = null;

        /**
         * Value doubleValue.
         * @member {number|null|undefined} doubleValue
         * @memberof ml_metadata.Value
         * @instance
         */
        Value.prototype.doubleValue = null;

        /**
         * Value stringValue.
         * @member {string|null|undefined} stringValue
         * @memberof ml_metadata.Value
         * @instance
         */
        Value.prototype.stringValue = null;

        /**
         * Value structValue.
         * @member {google.protobuf.IStruct|null|undefined} structValue
         * @memberof ml_metadata.Value
         * @instance
         */
        Value.prototype.structValue = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Value value.
         * @member {"intValue"|"doubleValue"|"stringValue"|"structValue"|undefined} value
         * @memberof ml_metadata.Value
         * @instance
         */
        Object.defineProperty(Value.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["intValue", "doubleValue", "stringValue", "structValue"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Value instance using the specified properties.
         * @function create
         * @memberof ml_metadata.Value
         * @static
         * @param {ml_metadata.IValue=} [properties] Properties to set
         * @returns {ml_metadata.Value} Value instance
         */
        Value.create = function create(properties) {
            return new Value(properties);
        };

        /**
         * Encodes the specified Value message. Does not implicitly {@link ml_metadata.Value.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.Value
         * @static
         * @param {ml_metadata.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.intValue != null && Object.hasOwnProperty.call(message, "intValue"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.intValue);
            if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.doubleValue);
            if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
            if (message.structValue != null && Object.hasOwnProperty.call(message, "structValue"))
                $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Value message, length delimited. Does not implicitly {@link ml_metadata.Value.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.Value
         * @static
         * @param {ml_metadata.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Value message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.Value();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.intValue = reader.int64();
                    break;
                case 2:
                    message.doubleValue = reader.double();
                    break;
                case 3:
                    message.stringValue = reader.string();
                    break;
                case 4:
                    message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Value message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Value message.
         * @function verify
         * @memberof ml_metadata.Value
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Value.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.intValue != null && message.hasOwnProperty("intValue")) {
                properties.value = 1;
                if (!$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))
                    return "intValue: integer|Long expected";
            }
            if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (typeof message.doubleValue !== "number")
                    return "doubleValue: number expected";
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.stringValue))
                    return "stringValue: string expected";
            }
            if (message.structValue != null && message.hasOwnProperty("structValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.google.protobuf.Struct.verify(message.structValue);
                    if (error)
                        return "structValue." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Value message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.Value
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.Value} Value
         */
        Value.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.Value)
                return object;
            var message = new $root.ml_metadata.Value();
            if (object.intValue != null)
                if ($util.Long)
                    (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;
                else if (typeof object.intValue === "string")
                    message.intValue = parseInt(object.intValue, 10);
                else if (typeof object.intValue === "number")
                    message.intValue = object.intValue;
                else if (typeof object.intValue === "object")
                    message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();
            if (object.doubleValue != null)
                message.doubleValue = Number(object.doubleValue);
            if (object.stringValue != null)
                message.stringValue = String(object.stringValue);
            if (object.structValue != null) {
                if (typeof object.structValue !== "object")
                    throw TypeError(".ml_metadata.Value.structValue: object expected");
                message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
            }
            return message;
        };

        /**
         * Creates a plain object from a Value message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.Value
         * @static
         * @param {ml_metadata.Value} message Value
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Value.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.intValue != null && message.hasOwnProperty("intValue")) {
                if (typeof message.intValue === "number")
                    object.intValue = options.longs === String ? String(message.intValue) : message.intValue;
                else
                    object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;
                if (options.oneofs)
                    object.value = "intValue";
            }
            if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (options.oneofs)
                    object.value = "doubleValue";
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                object.stringValue = message.stringValue;
                if (options.oneofs)
                    object.value = "stringValue";
            }
            if (message.structValue != null && message.hasOwnProperty("structValue")) {
                object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                if (options.oneofs)
                    object.value = "structValue";
            }
            return object;
        };

        /**
         * Converts this Value to JSON.
         * @function toJSON
         * @memberof ml_metadata.Value
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Value.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Value;
    })();

    ml_metadata.Artifact = (function() {

        /**
         * Properties of an Artifact.
         * @memberof ml_metadata
         * @interface IArtifact
         * @property {number|Long|null} [id] Artifact id
         * @property {string|null} [name] Artifact name
         * @property {number|Long|null} [typeId] Artifact typeId
         * @property {string|null} [type] Artifact type
         * @property {string|null} [uri] Artifact uri
         * @property {Object.<string,ml_metadata.IValue>|null} [properties] Artifact properties
         * @property {Object.<string,ml_metadata.IValue>|null} [customProperties] Artifact customProperties
         * @property {ml_metadata.Artifact.State|null} [state] Artifact state
         * @property {number|Long|null} [createTimeSinceEpoch] Artifact createTimeSinceEpoch
         * @property {number|Long|null} [lastUpdateTimeSinceEpoch] Artifact lastUpdateTimeSinceEpoch
         */

        /**
         * Constructs a new Artifact.
         * @memberof ml_metadata
         * @classdesc Represents an Artifact.
         * @implements IArtifact
         * @constructor
         * @param {ml_metadata.IArtifact=} [properties] Properties to set
         */
        function Artifact(properties) {
            this.properties = {};
            this.customProperties = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Artifact id.
         * @member {number|Long} id
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Artifact name.
         * @member {string} name
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.name = "";

        /**
         * Artifact typeId.
         * @member {number|Long} typeId
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.typeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Artifact type.
         * @member {string} type
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.type = "";

        /**
         * Artifact uri.
         * @member {string} uri
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.uri = "";

        /**
         * Artifact properties.
         * @member {Object.<string,ml_metadata.IValue>} properties
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.properties = $util.emptyObject;

        /**
         * Artifact customProperties.
         * @member {Object.<string,ml_metadata.IValue>} customProperties
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.customProperties = $util.emptyObject;

        /**
         * Artifact state.
         * @member {ml_metadata.Artifact.State} state
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.state = 0;

        /**
         * Artifact createTimeSinceEpoch.
         * @member {number|Long} createTimeSinceEpoch
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.createTimeSinceEpoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Artifact lastUpdateTimeSinceEpoch.
         * @member {number|Long} lastUpdateTimeSinceEpoch
         * @memberof ml_metadata.Artifact
         * @instance
         */
        Artifact.prototype.lastUpdateTimeSinceEpoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Artifact instance using the specified properties.
         * @function create
         * @memberof ml_metadata.Artifact
         * @static
         * @param {ml_metadata.IArtifact=} [properties] Properties to set
         * @returns {ml_metadata.Artifact} Artifact instance
         */
        Artifact.create = function create(properties) {
            return new Artifact(properties);
        };

        /**
         * Encodes the specified Artifact message. Does not implicitly {@link ml_metadata.Artifact.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.Artifact
         * @static
         * @param {ml_metadata.IArtifact} message Artifact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Artifact.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.typeId != null && Object.hasOwnProperty.call(message, "typeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.typeId);
            if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.uri);
            if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ml_metadata.Value.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.customProperties != null && Object.hasOwnProperty.call(message, "customProperties"))
                for (var keys = Object.keys(message.customProperties), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ml_metadata.Value.encode(message.customProperties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.state);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.type);
            if (message.createTimeSinceEpoch != null && Object.hasOwnProperty.call(message, "createTimeSinceEpoch"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.createTimeSinceEpoch);
            if (message.lastUpdateTimeSinceEpoch != null && Object.hasOwnProperty.call(message, "lastUpdateTimeSinceEpoch"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.lastUpdateTimeSinceEpoch);
            return writer;
        };

        /**
         * Encodes the specified Artifact message, length delimited. Does not implicitly {@link ml_metadata.Artifact.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.Artifact
         * @static
         * @param {ml_metadata.IArtifact} message Artifact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Artifact.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Artifact message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.Artifact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.Artifact} Artifact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Artifact.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.Artifact(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 7:
                    message.name = reader.string();
                    break;
                case 2:
                    message.typeId = reader.int64();
                    break;
                case 8:
                    message.type = reader.string();
                    break;
                case 3:
                    message.uri = reader.string();
                    break;
                case 4:
                    if (message.properties === $util.emptyObject)
                        message.properties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.ml_metadata.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.properties[key] = value;
                    break;
                case 5:
                    if (message.customProperties === $util.emptyObject)
                        message.customProperties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.ml_metadata.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.customProperties[key] = value;
                    break;
                case 6:
                    message.state = reader.int32();
                    break;
                case 9:
                    message.createTimeSinceEpoch = reader.int64();
                    break;
                case 10:
                    message.lastUpdateTimeSinceEpoch = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Artifact message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.Artifact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.Artifact} Artifact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Artifact.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Artifact message.
         * @function verify
         * @memberof ml_metadata.Artifact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Artifact.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (!$util.isInteger(message.typeId) && !(message.typeId && $util.isInteger(message.typeId.low) && $util.isInteger(message.typeId.high)))
                    return "typeId: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.uri != null && message.hasOwnProperty("uri"))
                if (!$util.isString(message.uri))
                    return "uri: string expected";
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!$util.isObject(message.properties))
                    return "properties: object expected";
                var key = Object.keys(message.properties);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.ml_metadata.Value.verify(message.properties[key[i]]);
                    if (error)
                        return "properties." + error;
                }
            }
            if (message.customProperties != null && message.hasOwnProperty("customProperties")) {
                if (!$util.isObject(message.customProperties))
                    return "customProperties: object expected";
                var key = Object.keys(message.customProperties);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.ml_metadata.Value.verify(message.customProperties[key[i]]);
                    if (error)
                        return "customProperties." + error;
                }
            }
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.createTimeSinceEpoch != null && message.hasOwnProperty("createTimeSinceEpoch"))
                if (!$util.isInteger(message.createTimeSinceEpoch) && !(message.createTimeSinceEpoch && $util.isInteger(message.createTimeSinceEpoch.low) && $util.isInteger(message.createTimeSinceEpoch.high)))
                    return "createTimeSinceEpoch: integer|Long expected";
            if (message.lastUpdateTimeSinceEpoch != null && message.hasOwnProperty("lastUpdateTimeSinceEpoch"))
                if (!$util.isInteger(message.lastUpdateTimeSinceEpoch) && !(message.lastUpdateTimeSinceEpoch && $util.isInteger(message.lastUpdateTimeSinceEpoch.low) && $util.isInteger(message.lastUpdateTimeSinceEpoch.high)))
                    return "lastUpdateTimeSinceEpoch: integer|Long expected";
            return null;
        };

        /**
         * Creates an Artifact message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.Artifact
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.Artifact} Artifact
         */
        Artifact.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.Artifact)
                return object;
            var message = new $root.ml_metadata.Artifact();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.typeId != null)
                if ($util.Long)
                    (message.typeId = $util.Long.fromValue(object.typeId)).unsigned = false;
                else if (typeof object.typeId === "string")
                    message.typeId = parseInt(object.typeId, 10);
                else if (typeof object.typeId === "number")
                    message.typeId = object.typeId;
                else if (typeof object.typeId === "object")
                    message.typeId = new $util.LongBits(object.typeId.low >>> 0, object.typeId.high >>> 0).toNumber();
            if (object.type != null)
                message.type = String(object.type);
            if (object.uri != null)
                message.uri = String(object.uri);
            if (object.properties) {
                if (typeof object.properties !== "object")
                    throw TypeError(".ml_metadata.Artifact.properties: object expected");
                message.properties = {};
                for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                    if (typeof object.properties[keys[i]] !== "object")
                        throw TypeError(".ml_metadata.Artifact.properties: object expected");
                    message.properties[keys[i]] = $root.ml_metadata.Value.fromObject(object.properties[keys[i]]);
                }
            }
            if (object.customProperties) {
                if (typeof object.customProperties !== "object")
                    throw TypeError(".ml_metadata.Artifact.customProperties: object expected");
                message.customProperties = {};
                for (var keys = Object.keys(object.customProperties), i = 0; i < keys.length; ++i) {
                    if (typeof object.customProperties[keys[i]] !== "object")
                        throw TypeError(".ml_metadata.Artifact.customProperties: object expected");
                    message.customProperties[keys[i]] = $root.ml_metadata.Value.fromObject(object.customProperties[keys[i]]);
                }
            }
            switch (object.state) {
            case "UNKNOWN":
            case 0:
                message.state = 0;
                break;
            case "PENDING":
            case 1:
                message.state = 1;
                break;
            case "LIVE":
            case 2:
                message.state = 2;
                break;
            case "MARKED_FOR_DELETION":
            case 3:
                message.state = 3;
                break;
            case "DELETED":
            case 4:
                message.state = 4;
                break;
            }
            if (object.createTimeSinceEpoch != null)
                if ($util.Long)
                    (message.createTimeSinceEpoch = $util.Long.fromValue(object.createTimeSinceEpoch)).unsigned = false;
                else if (typeof object.createTimeSinceEpoch === "string")
                    message.createTimeSinceEpoch = parseInt(object.createTimeSinceEpoch, 10);
                else if (typeof object.createTimeSinceEpoch === "number")
                    message.createTimeSinceEpoch = object.createTimeSinceEpoch;
                else if (typeof object.createTimeSinceEpoch === "object")
                    message.createTimeSinceEpoch = new $util.LongBits(object.createTimeSinceEpoch.low >>> 0, object.createTimeSinceEpoch.high >>> 0).toNumber();
            if (object.lastUpdateTimeSinceEpoch != null)
                if ($util.Long)
                    (message.lastUpdateTimeSinceEpoch = $util.Long.fromValue(object.lastUpdateTimeSinceEpoch)).unsigned = false;
                else if (typeof object.lastUpdateTimeSinceEpoch === "string")
                    message.lastUpdateTimeSinceEpoch = parseInt(object.lastUpdateTimeSinceEpoch, 10);
                else if (typeof object.lastUpdateTimeSinceEpoch === "number")
                    message.lastUpdateTimeSinceEpoch = object.lastUpdateTimeSinceEpoch;
                else if (typeof object.lastUpdateTimeSinceEpoch === "object")
                    message.lastUpdateTimeSinceEpoch = new $util.LongBits(object.lastUpdateTimeSinceEpoch.low >>> 0, object.lastUpdateTimeSinceEpoch.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Artifact message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.Artifact
         * @static
         * @param {ml_metadata.Artifact} message Artifact
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Artifact.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.properties = {};
                object.customProperties = {};
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.typeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.typeId = options.longs === String ? "0" : 0;
                object.uri = "";
                object.state = options.enums === String ? "UNKNOWN" : 0;
                object.name = "";
                object.type = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTimeSinceEpoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTimeSinceEpoch = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (typeof message.typeId === "number")
                    object.typeId = options.longs === String ? String(message.typeId) : message.typeId;
                else
                    object.typeId = options.longs === String ? $util.Long.prototype.toString.call(message.typeId) : options.longs === Number ? new $util.LongBits(message.typeId.low >>> 0, message.typeId.high >>> 0).toNumber() : message.typeId;
            if (message.uri != null && message.hasOwnProperty("uri"))
                object.uri = message.uri;
            var keys2;
            if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                object.properties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.properties[keys2[j]] = $root.ml_metadata.Value.toObject(message.properties[keys2[j]], options);
            }
            if (message.customProperties && (keys2 = Object.keys(message.customProperties)).length) {
                object.customProperties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.customProperties[keys2[j]] = $root.ml_metadata.Value.toObject(message.customProperties[keys2[j]], options);
            }
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.ml_metadata.Artifact.State[message.state] : message.state;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.createTimeSinceEpoch != null && message.hasOwnProperty("createTimeSinceEpoch"))
                if (typeof message.createTimeSinceEpoch === "number")
                    object.createTimeSinceEpoch = options.longs === String ? String(message.createTimeSinceEpoch) : message.createTimeSinceEpoch;
                else
                    object.createTimeSinceEpoch = options.longs === String ? $util.Long.prototype.toString.call(message.createTimeSinceEpoch) : options.longs === Number ? new $util.LongBits(message.createTimeSinceEpoch.low >>> 0, message.createTimeSinceEpoch.high >>> 0).toNumber() : message.createTimeSinceEpoch;
            if (message.lastUpdateTimeSinceEpoch != null && message.hasOwnProperty("lastUpdateTimeSinceEpoch"))
                if (typeof message.lastUpdateTimeSinceEpoch === "number")
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? String(message.lastUpdateTimeSinceEpoch) : message.lastUpdateTimeSinceEpoch;
                else
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdateTimeSinceEpoch) : options.longs === Number ? new $util.LongBits(message.lastUpdateTimeSinceEpoch.low >>> 0, message.lastUpdateTimeSinceEpoch.high >>> 0).toNumber() : message.lastUpdateTimeSinceEpoch;
            return object;
        };

        /**
         * Converts this Artifact to JSON.
         * @function toJSON
         * @memberof ml_metadata.Artifact
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Artifact.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * State enum.
         * @name ml_metadata.Artifact.State
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} PENDING=1 PENDING value
         * @property {number} LIVE=2 LIVE value
         * @property {number} MARKED_FOR_DELETION=3 MARKED_FOR_DELETION value
         * @property {number} DELETED=4 DELETED value
         */
        Artifact.State = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "PENDING"] = 1;
            values[valuesById[2] = "LIVE"] = 2;
            values[valuesById[3] = "MARKED_FOR_DELETION"] = 3;
            values[valuesById[4] = "DELETED"] = 4;
            return values;
        })();

        return Artifact;
    })();

    /**
     * PropertyType enum.
     * @name ml_metadata.PropertyType
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} INT=1 INT value
     * @property {number} DOUBLE=2 DOUBLE value
     * @property {number} STRING=3 STRING value
     * @property {number} STRUCT=4 STRUCT value
     */
    ml_metadata.PropertyType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "INT"] = 1;
        values[valuesById[2] = "DOUBLE"] = 2;
        values[valuesById[3] = "STRING"] = 3;
        values[valuesById[4] = "STRUCT"] = 4;
        return values;
    })();

    ml_metadata.ArtifactType = (function() {

        /**
         * Properties of an ArtifactType.
         * @memberof ml_metadata
         * @interface IArtifactType
         * @property {number|Long|null} [id] ArtifactType id
         * @property {string|null} [name] ArtifactType name
         * @property {string|null} [version] ArtifactType version
         * @property {string|null} [description] ArtifactType description
         * @property {Object.<string,ml_metadata.PropertyType>|null} [properties] ArtifactType properties
         */

        /**
         * Constructs a new ArtifactType.
         * @memberof ml_metadata
         * @classdesc Represents an ArtifactType.
         * @implements IArtifactType
         * @constructor
         * @param {ml_metadata.IArtifactType=} [properties] Properties to set
         */
        function ArtifactType(properties) {
            this.properties = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtifactType id.
         * @member {number|Long} id
         * @memberof ml_metadata.ArtifactType
         * @instance
         */
        ArtifactType.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ArtifactType name.
         * @member {string} name
         * @memberof ml_metadata.ArtifactType
         * @instance
         */
        ArtifactType.prototype.name = "";

        /**
         * ArtifactType version.
         * @member {string} version
         * @memberof ml_metadata.ArtifactType
         * @instance
         */
        ArtifactType.prototype.version = "";

        /**
         * ArtifactType description.
         * @member {string} description
         * @memberof ml_metadata.ArtifactType
         * @instance
         */
        ArtifactType.prototype.description = "";

        /**
         * ArtifactType properties.
         * @member {Object.<string,ml_metadata.PropertyType>} properties
         * @memberof ml_metadata.ArtifactType
         * @instance
         */
        ArtifactType.prototype.properties = $util.emptyObject;

        /**
         * Creates a new ArtifactType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ArtifactType
         * @static
         * @param {ml_metadata.IArtifactType=} [properties] Properties to set
         * @returns {ml_metadata.ArtifactType} ArtifactType instance
         */
        ArtifactType.create = function create(properties) {
            return new ArtifactType(properties);
        };

        /**
         * Encodes the specified ArtifactType message. Does not implicitly {@link ml_metadata.ArtifactType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ArtifactType
         * @static
         * @param {ml_metadata.IArtifactType} message ArtifactType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int32(message.properties[keys[i]]).ldelim();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.version);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified ArtifactType message, length delimited. Does not implicitly {@link ml_metadata.ArtifactType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ArtifactType
         * @static
         * @param {ml_metadata.IArtifactType} message ArtifactType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtifactType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ArtifactType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ArtifactType} ArtifactType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ArtifactType(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 4:
                    message.version = reader.string();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                case 3:
                    if (message.properties === $util.emptyObject)
                        message.properties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = 0;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.int32();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.properties[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtifactType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ArtifactType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ArtifactType} ArtifactType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtifactType message.
         * @function verify
         * @memberof ml_metadata.ArtifactType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtifactType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!$util.isObject(message.properties))
                    return "properties: object expected";
                var key = Object.keys(message.properties);
                for (var i = 0; i < key.length; ++i)
                    switch (message.properties[key[i]]) {
                    default:
                        return "properties: enum value{k:string} expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates an ArtifactType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ArtifactType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ArtifactType} ArtifactType
         */
        ArtifactType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ArtifactType)
                return object;
            var message = new $root.ml_metadata.ArtifactType();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.version != null)
                message.version = String(object.version);
            if (object.description != null)
                message.description = String(object.description);
            if (object.properties) {
                if (typeof object.properties !== "object")
                    throw TypeError(".ml_metadata.ArtifactType.properties: object expected");
                message.properties = {};
                for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i)
                    switch (object.properties[keys[i]]) {
                    case "UNKNOWN":
                    case 0:
                        message.properties[keys[i]] = 0;
                        break;
                    case "INT":
                    case 1:
                        message.properties[keys[i]] = 1;
                        break;
                    case "DOUBLE":
                    case 2:
                        message.properties[keys[i]] = 2;
                        break;
                    case "STRING":
                    case 3:
                        message.properties[keys[i]] = 3;
                        break;
                    case "STRUCT":
                    case 4:
                        message.properties[keys[i]] = 4;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtifactType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ArtifactType
         * @static
         * @param {ml_metadata.ArtifactType} message ArtifactType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtifactType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.properties = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.name = "";
                object.version = "";
                object.description = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            var keys2;
            if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                object.properties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.properties[keys2[j]] = options.enums === String ? $root.ml_metadata.PropertyType[message.properties[keys2[j]]] : message.properties[keys2[j]];
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this ArtifactType to JSON.
         * @function toJSON
         * @memberof ml_metadata.ArtifactType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtifactType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtifactType;
    })();

    ml_metadata.Event = (function() {

        /**
         * Properties of an Event.
         * @memberof ml_metadata
         * @interface IEvent
         * @property {number|Long|null} [artifactId] Event artifactId
         * @property {number|Long|null} [executionId] Event executionId
         * @property {ml_metadata.Event.IPath|null} [path] Event path
         * @property {ml_metadata.Event.Type|null} [type] Event type
         * @property {number|Long|null} [millisecondsSinceEpoch] Event millisecondsSinceEpoch
         */

        /**
         * Constructs a new Event.
         * @memberof ml_metadata
         * @classdesc Represents an Event.
         * @implements IEvent
         * @constructor
         * @param {ml_metadata.IEvent=} [properties] Properties to set
         */
        function Event(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Event artifactId.
         * @member {number|Long} artifactId
         * @memberof ml_metadata.Event
         * @instance
         */
        Event.prototype.artifactId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Event executionId.
         * @member {number|Long} executionId
         * @memberof ml_metadata.Event
         * @instance
         */
        Event.prototype.executionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Event path.
         * @member {ml_metadata.Event.IPath|null|undefined} path
         * @memberof ml_metadata.Event
         * @instance
         */
        Event.prototype.path = null;

        /**
         * Event type.
         * @member {ml_metadata.Event.Type} type
         * @memberof ml_metadata.Event
         * @instance
         */
        Event.prototype.type = 0;

        /**
         * Event millisecondsSinceEpoch.
         * @member {number|Long} millisecondsSinceEpoch
         * @memberof ml_metadata.Event
         * @instance
         */
        Event.prototype.millisecondsSinceEpoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Event instance using the specified properties.
         * @function create
         * @memberof ml_metadata.Event
         * @static
         * @param {ml_metadata.IEvent=} [properties] Properties to set
         * @returns {ml_metadata.Event} Event instance
         */
        Event.create = function create(properties) {
            return new Event(properties);
        };

        /**
         * Encodes the specified Event message. Does not implicitly {@link ml_metadata.Event.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.Event
         * @static
         * @param {ml_metadata.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactId != null && Object.hasOwnProperty.call(message, "artifactId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.artifactId);
            if (message.executionId != null && Object.hasOwnProperty.call(message, "executionId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.executionId);
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                $root.ml_metadata.Event.Path.encode(message.path, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
            if (message.millisecondsSinceEpoch != null && Object.hasOwnProperty.call(message, "millisecondsSinceEpoch"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.millisecondsSinceEpoch);
            return writer;
        };

        /**
         * Encodes the specified Event message, length delimited. Does not implicitly {@link ml_metadata.Event.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.Event
         * @static
         * @param {ml_metadata.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Event message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.Event();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.artifactId = reader.int64();
                    break;
                case 2:
                    message.executionId = reader.int64();
                    break;
                case 3:
                    message.path = $root.ml_metadata.Event.Path.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                case 5:
                    message.millisecondsSinceEpoch = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Event message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Event message.
         * @function verify
         * @memberof ml_metadata.Event
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Event.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactId != null && message.hasOwnProperty("artifactId"))
                if (!$util.isInteger(message.artifactId) && !(message.artifactId && $util.isInteger(message.artifactId.low) && $util.isInteger(message.artifactId.high)))
                    return "artifactId: integer|Long expected";
            if (message.executionId != null && message.hasOwnProperty("executionId"))
                if (!$util.isInteger(message.executionId) && !(message.executionId && $util.isInteger(message.executionId.low) && $util.isInteger(message.executionId.high)))
                    return "executionId: integer|Long expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                var error = $root.ml_metadata.Event.Path.verify(message.path);
                if (error)
                    return "path." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.millisecondsSinceEpoch != null && message.hasOwnProperty("millisecondsSinceEpoch"))
                if (!$util.isInteger(message.millisecondsSinceEpoch) && !(message.millisecondsSinceEpoch && $util.isInteger(message.millisecondsSinceEpoch.low) && $util.isInteger(message.millisecondsSinceEpoch.high)))
                    return "millisecondsSinceEpoch: integer|Long expected";
            return null;
        };

        /**
         * Creates an Event message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.Event
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.Event} Event
         */
        Event.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.Event)
                return object;
            var message = new $root.ml_metadata.Event();
            if (object.artifactId != null)
                if ($util.Long)
                    (message.artifactId = $util.Long.fromValue(object.artifactId)).unsigned = false;
                else if (typeof object.artifactId === "string")
                    message.artifactId = parseInt(object.artifactId, 10);
                else if (typeof object.artifactId === "number")
                    message.artifactId = object.artifactId;
                else if (typeof object.artifactId === "object")
                    message.artifactId = new $util.LongBits(object.artifactId.low >>> 0, object.artifactId.high >>> 0).toNumber();
            if (object.executionId != null)
                if ($util.Long)
                    (message.executionId = $util.Long.fromValue(object.executionId)).unsigned = false;
                else if (typeof object.executionId === "string")
                    message.executionId = parseInt(object.executionId, 10);
                else if (typeof object.executionId === "number")
                    message.executionId = object.executionId;
                else if (typeof object.executionId === "object")
                    message.executionId = new $util.LongBits(object.executionId.low >>> 0, object.executionId.high >>> 0).toNumber();
            if (object.path != null) {
                if (typeof object.path !== "object")
                    throw TypeError(".ml_metadata.Event.path: object expected");
                message.path = $root.ml_metadata.Event.Path.fromObject(object.path);
            }
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "DECLARED_OUTPUT":
            case 1:
                message.type = 1;
                break;
            case "DECLARED_INPUT":
            case 2:
                message.type = 2;
                break;
            case "INPUT":
            case 3:
                message.type = 3;
                break;
            case "OUTPUT":
            case 4:
                message.type = 4;
                break;
            case "INTERNAL_INPUT":
            case 5:
                message.type = 5;
                break;
            case "INTERNAL_OUTPUT":
            case 6:
                message.type = 6;
                break;
            }
            if (object.millisecondsSinceEpoch != null)
                if ($util.Long)
                    (message.millisecondsSinceEpoch = $util.Long.fromValue(object.millisecondsSinceEpoch)).unsigned = false;
                else if (typeof object.millisecondsSinceEpoch === "string")
                    message.millisecondsSinceEpoch = parseInt(object.millisecondsSinceEpoch, 10);
                else if (typeof object.millisecondsSinceEpoch === "number")
                    message.millisecondsSinceEpoch = object.millisecondsSinceEpoch;
                else if (typeof object.millisecondsSinceEpoch === "object")
                    message.millisecondsSinceEpoch = new $util.LongBits(object.millisecondsSinceEpoch.low >>> 0, object.millisecondsSinceEpoch.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Event message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.Event
         * @static
         * @param {ml_metadata.Event} message Event
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Event.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.artifactId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.artifactId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.executionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.executionId = options.longs === String ? "0" : 0;
                object.path = null;
                object.type = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.millisecondsSinceEpoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.millisecondsSinceEpoch = options.longs === String ? "0" : 0;
            }
            if (message.artifactId != null && message.hasOwnProperty("artifactId"))
                if (typeof message.artifactId === "number")
                    object.artifactId = options.longs === String ? String(message.artifactId) : message.artifactId;
                else
                    object.artifactId = options.longs === String ? $util.Long.prototype.toString.call(message.artifactId) : options.longs === Number ? new $util.LongBits(message.artifactId.low >>> 0, message.artifactId.high >>> 0).toNumber() : message.artifactId;
            if (message.executionId != null && message.hasOwnProperty("executionId"))
                if (typeof message.executionId === "number")
                    object.executionId = options.longs === String ? String(message.executionId) : message.executionId;
                else
                    object.executionId = options.longs === String ? $util.Long.prototype.toString.call(message.executionId) : options.longs === Number ? new $util.LongBits(message.executionId.low >>> 0, message.executionId.high >>> 0).toNumber() : message.executionId;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = $root.ml_metadata.Event.Path.toObject(message.path, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ml_metadata.Event.Type[message.type] : message.type;
            if (message.millisecondsSinceEpoch != null && message.hasOwnProperty("millisecondsSinceEpoch"))
                if (typeof message.millisecondsSinceEpoch === "number")
                    object.millisecondsSinceEpoch = options.longs === String ? String(message.millisecondsSinceEpoch) : message.millisecondsSinceEpoch;
                else
                    object.millisecondsSinceEpoch = options.longs === String ? $util.Long.prototype.toString.call(message.millisecondsSinceEpoch) : options.longs === Number ? new $util.LongBits(message.millisecondsSinceEpoch.low >>> 0, message.millisecondsSinceEpoch.high >>> 0).toNumber() : message.millisecondsSinceEpoch;
            return object;
        };

        /**
         * Converts this Event to JSON.
         * @function toJSON
         * @memberof ml_metadata.Event
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Event.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Event.Path = (function() {

            /**
             * Properties of a Path.
             * @memberof ml_metadata.Event
             * @interface IPath
             * @property {Array.<ml_metadata.Event.Path.IStep>|null} [steps] Path steps
             */

            /**
             * Constructs a new Path.
             * @memberof ml_metadata.Event
             * @classdesc Represents a Path.
             * @implements IPath
             * @constructor
             * @param {ml_metadata.Event.IPath=} [properties] Properties to set
             */
            function Path(properties) {
                this.steps = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Path steps.
             * @member {Array.<ml_metadata.Event.Path.IStep>} steps
             * @memberof ml_metadata.Event.Path
             * @instance
             */
            Path.prototype.steps = $util.emptyArray;

            /**
             * Creates a new Path instance using the specified properties.
             * @function create
             * @memberof ml_metadata.Event.Path
             * @static
             * @param {ml_metadata.Event.IPath=} [properties] Properties to set
             * @returns {ml_metadata.Event.Path} Path instance
             */
            Path.create = function create(properties) {
                return new Path(properties);
            };

            /**
             * Encodes the specified Path message. Does not implicitly {@link ml_metadata.Event.Path.verify|verify} messages.
             * @function encode
             * @memberof ml_metadata.Event.Path
             * @static
             * @param {ml_metadata.Event.IPath} message Path message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Path.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.steps != null && message.steps.length)
                    for (var i = 0; i < message.steps.length; ++i)
                        $root.ml_metadata.Event.Path.Step.encode(message.steps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Path message, length delimited. Does not implicitly {@link ml_metadata.Event.Path.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ml_metadata.Event.Path
             * @static
             * @param {ml_metadata.Event.IPath} message Path message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Path.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Path message from the specified reader or buffer.
             * @function decode
             * @memberof ml_metadata.Event.Path
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ml_metadata.Event.Path} Path
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Path.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.Event.Path();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.steps && message.steps.length))
                            message.steps = [];
                        message.steps.push($root.ml_metadata.Event.Path.Step.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Path message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ml_metadata.Event.Path
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ml_metadata.Event.Path} Path
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Path.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Path message.
             * @function verify
             * @memberof ml_metadata.Event.Path
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Path.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.steps != null && message.hasOwnProperty("steps")) {
                    if (!Array.isArray(message.steps))
                        return "steps: array expected";
                    for (var i = 0; i < message.steps.length; ++i) {
                        var error = $root.ml_metadata.Event.Path.Step.verify(message.steps[i]);
                        if (error)
                            return "steps." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Path message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ml_metadata.Event.Path
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ml_metadata.Event.Path} Path
             */
            Path.fromObject = function fromObject(object) {
                if (object instanceof $root.ml_metadata.Event.Path)
                    return object;
                var message = new $root.ml_metadata.Event.Path();
                if (object.steps) {
                    if (!Array.isArray(object.steps))
                        throw TypeError(".ml_metadata.Event.Path.steps: array expected");
                    message.steps = [];
                    for (var i = 0; i < object.steps.length; ++i) {
                        if (typeof object.steps[i] !== "object")
                            throw TypeError(".ml_metadata.Event.Path.steps: object expected");
                        message.steps[i] = $root.ml_metadata.Event.Path.Step.fromObject(object.steps[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Path message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ml_metadata.Event.Path
             * @static
             * @param {ml_metadata.Event.Path} message Path
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Path.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.steps = [];
                if (message.steps && message.steps.length) {
                    object.steps = [];
                    for (var j = 0; j < message.steps.length; ++j)
                        object.steps[j] = $root.ml_metadata.Event.Path.Step.toObject(message.steps[j], options);
                }
                return object;
            };

            /**
             * Converts this Path to JSON.
             * @function toJSON
             * @memberof ml_metadata.Event.Path
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Path.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Path.Step = (function() {

                /**
                 * Properties of a Step.
                 * @memberof ml_metadata.Event.Path
                 * @interface IStep
                 * @property {number|Long|null} [index] Step index
                 * @property {string|null} [key] Step key
                 */

                /**
                 * Constructs a new Step.
                 * @memberof ml_metadata.Event.Path
                 * @classdesc Represents a Step.
                 * @implements IStep
                 * @constructor
                 * @param {ml_metadata.Event.Path.IStep=} [properties] Properties to set
                 */
                function Step(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Step index.
                 * @member {number|Long|null|undefined} index
                 * @memberof ml_metadata.Event.Path.Step
                 * @instance
                 */
                Step.prototype.index = null;

                /**
                 * Step key.
                 * @member {string|null|undefined} key
                 * @memberof ml_metadata.Event.Path.Step
                 * @instance
                 */
                Step.prototype.key = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * Step value.
                 * @member {"index"|"key"|undefined} value
                 * @memberof ml_metadata.Event.Path.Step
                 * @instance
                 */
                Object.defineProperty(Step.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["index", "key"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Step instance using the specified properties.
                 * @function create
                 * @memberof ml_metadata.Event.Path.Step
                 * @static
                 * @param {ml_metadata.Event.Path.IStep=} [properties] Properties to set
                 * @returns {ml_metadata.Event.Path.Step} Step instance
                 */
                Step.create = function create(properties) {
                    return new Step(properties);
                };

                /**
                 * Encodes the specified Step message. Does not implicitly {@link ml_metadata.Event.Path.Step.verify|verify} messages.
                 * @function encode
                 * @memberof ml_metadata.Event.Path.Step
                 * @static
                 * @param {ml_metadata.Event.Path.IStep} message Step message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Step.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.index);
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                    return writer;
                };

                /**
                 * Encodes the specified Step message, length delimited. Does not implicitly {@link ml_metadata.Event.Path.Step.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ml_metadata.Event.Path.Step
                 * @static
                 * @param {ml_metadata.Event.Path.IStep} message Step message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Step.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Step message from the specified reader or buffer.
                 * @function decode
                 * @memberof ml_metadata.Event.Path.Step
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ml_metadata.Event.Path.Step} Step
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Step.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.Event.Path.Step();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.int64();
                            break;
                        case 2:
                            message.key = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Step message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ml_metadata.Event.Path.Step
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ml_metadata.Event.Path.Step} Step
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Step.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Step message.
                 * @function verify
                 * @memberof ml_metadata.Event.Path.Step
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Step.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.index != null && message.hasOwnProperty("index")) {
                        properties.value = 1;
                        if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                            return "index: integer|Long expected";
                    }
                    if (message.key != null && message.hasOwnProperty("key")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    }
                    return null;
                };

                /**
                 * Creates a Step message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ml_metadata.Event.Path.Step
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ml_metadata.Event.Path.Step} Step
                 */
                Step.fromObject = function fromObject(object) {
                    if (object instanceof $root.ml_metadata.Event.Path.Step)
                        return object;
                    var message = new $root.ml_metadata.Event.Path.Step();
                    if (object.index != null)
                        if ($util.Long)
                            (message.index = $util.Long.fromValue(object.index)).unsigned = false;
                        else if (typeof object.index === "string")
                            message.index = parseInt(object.index, 10);
                        else if (typeof object.index === "number")
                            message.index = object.index;
                        else if (typeof object.index === "object")
                            message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber();
                    if (object.key != null)
                        message.key = String(object.key);
                    return message;
                };

                /**
                 * Creates a plain object from a Step message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ml_metadata.Event.Path.Step
                 * @static
                 * @param {ml_metadata.Event.Path.Step} message Step
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Step.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.index != null && message.hasOwnProperty("index")) {
                        if (typeof message.index === "number")
                            object.index = options.longs === String ? String(message.index) : message.index;
                        else
                            object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber() : message.index;
                        if (options.oneofs)
                            object.value = "index";
                    }
                    if (message.key != null && message.hasOwnProperty("key")) {
                        object.key = message.key;
                        if (options.oneofs)
                            object.value = "key";
                    }
                    return object;
                };

                /**
                 * Converts this Step to JSON.
                 * @function toJSON
                 * @memberof ml_metadata.Event.Path.Step
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Step.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Step;
            })();

            return Path;
        })();

        /**
         * Type enum.
         * @name ml_metadata.Event.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} DECLARED_OUTPUT=1 DECLARED_OUTPUT value
         * @property {number} DECLARED_INPUT=2 DECLARED_INPUT value
         * @property {number} INPUT=3 INPUT value
         * @property {number} OUTPUT=4 OUTPUT value
         * @property {number} INTERNAL_INPUT=5 INTERNAL_INPUT value
         * @property {number} INTERNAL_OUTPUT=6 INTERNAL_OUTPUT value
         */
        Event.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "DECLARED_OUTPUT"] = 1;
            values[valuesById[2] = "DECLARED_INPUT"] = 2;
            values[valuesById[3] = "INPUT"] = 3;
            values[valuesById[4] = "OUTPUT"] = 4;
            values[valuesById[5] = "INTERNAL_INPUT"] = 5;
            values[valuesById[6] = "INTERNAL_OUTPUT"] = 6;
            return values;
        })();

        return Event;
    })();

    ml_metadata.Execution = (function() {

        /**
         * Properties of an Execution.
         * @memberof ml_metadata
         * @interface IExecution
         * @property {number|Long|null} [id] Execution id
         * @property {string|null} [name] Execution name
         * @property {number|Long|null} [typeId] Execution typeId
         * @property {string|null} [type] Execution type
         * @property {ml_metadata.Execution.State|null} [lastKnownState] Execution lastKnownState
         * @property {Object.<string,ml_metadata.IValue>|null} [properties] Execution properties
         * @property {Object.<string,ml_metadata.IValue>|null} [customProperties] Execution customProperties
         * @property {number|Long|null} [createTimeSinceEpoch] Execution createTimeSinceEpoch
         * @property {number|Long|null} [lastUpdateTimeSinceEpoch] Execution lastUpdateTimeSinceEpoch
         */

        /**
         * Constructs a new Execution.
         * @memberof ml_metadata
         * @classdesc Represents an Execution.
         * @implements IExecution
         * @constructor
         * @param {ml_metadata.IExecution=} [properties] Properties to set
         */
        function Execution(properties) {
            this.properties = {};
            this.customProperties = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Execution id.
         * @member {number|Long} id
         * @memberof ml_metadata.Execution
         * @instance
         */
        Execution.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Execution name.
         * @member {string} name
         * @memberof ml_metadata.Execution
         * @instance
         */
        Execution.prototype.name = "";

        /**
         * Execution typeId.
         * @member {number|Long} typeId
         * @memberof ml_metadata.Execution
         * @instance
         */
        Execution.prototype.typeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Execution type.
         * @member {string} type
         * @memberof ml_metadata.Execution
         * @instance
         */
        Execution.prototype.type = "";

        /**
         * Execution lastKnownState.
         * @member {ml_metadata.Execution.State} lastKnownState
         * @memberof ml_metadata.Execution
         * @instance
         */
        Execution.prototype.lastKnownState = 0;

        /**
         * Execution properties.
         * @member {Object.<string,ml_metadata.IValue>} properties
         * @memberof ml_metadata.Execution
         * @instance
         */
        Execution.prototype.properties = $util.emptyObject;

        /**
         * Execution customProperties.
         * @member {Object.<string,ml_metadata.IValue>} customProperties
         * @memberof ml_metadata.Execution
         * @instance
         */
        Execution.prototype.customProperties = $util.emptyObject;

        /**
         * Execution createTimeSinceEpoch.
         * @member {number|Long} createTimeSinceEpoch
         * @memberof ml_metadata.Execution
         * @instance
         */
        Execution.prototype.createTimeSinceEpoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Execution lastUpdateTimeSinceEpoch.
         * @member {number|Long} lastUpdateTimeSinceEpoch
         * @memberof ml_metadata.Execution
         * @instance
         */
        Execution.prototype.lastUpdateTimeSinceEpoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Execution instance using the specified properties.
         * @function create
         * @memberof ml_metadata.Execution
         * @static
         * @param {ml_metadata.IExecution=} [properties] Properties to set
         * @returns {ml_metadata.Execution} Execution instance
         */
        Execution.create = function create(properties) {
            return new Execution(properties);
        };

        /**
         * Encodes the specified Execution message. Does not implicitly {@link ml_metadata.Execution.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.Execution
         * @static
         * @param {ml_metadata.IExecution} message Execution message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Execution.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.typeId != null && Object.hasOwnProperty.call(message, "typeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.typeId);
            if (message.lastKnownState != null && Object.hasOwnProperty.call(message, "lastKnownState"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lastKnownState);
            if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ml_metadata.Value.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.customProperties != null && Object.hasOwnProperty.call(message, "customProperties"))
                for (var keys = Object.keys(message.customProperties), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ml_metadata.Value.encode(message.customProperties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.type);
            if (message.createTimeSinceEpoch != null && Object.hasOwnProperty.call(message, "createTimeSinceEpoch"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.createTimeSinceEpoch);
            if (message.lastUpdateTimeSinceEpoch != null && Object.hasOwnProperty.call(message, "lastUpdateTimeSinceEpoch"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.lastUpdateTimeSinceEpoch);
            return writer;
        };

        /**
         * Encodes the specified Execution message, length delimited. Does not implicitly {@link ml_metadata.Execution.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.Execution
         * @static
         * @param {ml_metadata.IExecution} message Execution message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Execution.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Execution message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.Execution
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.Execution} Execution
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Execution.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.Execution(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 6:
                    message.name = reader.string();
                    break;
                case 2:
                    message.typeId = reader.int64();
                    break;
                case 7:
                    message.type = reader.string();
                    break;
                case 3:
                    message.lastKnownState = reader.int32();
                    break;
                case 4:
                    if (message.properties === $util.emptyObject)
                        message.properties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.ml_metadata.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.properties[key] = value;
                    break;
                case 5:
                    if (message.customProperties === $util.emptyObject)
                        message.customProperties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.ml_metadata.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.customProperties[key] = value;
                    break;
                case 8:
                    message.createTimeSinceEpoch = reader.int64();
                    break;
                case 9:
                    message.lastUpdateTimeSinceEpoch = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Execution message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.Execution
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.Execution} Execution
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Execution.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Execution message.
         * @function verify
         * @memberof ml_metadata.Execution
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Execution.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (!$util.isInteger(message.typeId) && !(message.typeId && $util.isInteger(message.typeId.low) && $util.isInteger(message.typeId.high)))
                    return "typeId: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.lastKnownState != null && message.hasOwnProperty("lastKnownState"))
                switch (message.lastKnownState) {
                default:
                    return "lastKnownState: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!$util.isObject(message.properties))
                    return "properties: object expected";
                var key = Object.keys(message.properties);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.ml_metadata.Value.verify(message.properties[key[i]]);
                    if (error)
                        return "properties." + error;
                }
            }
            if (message.customProperties != null && message.hasOwnProperty("customProperties")) {
                if (!$util.isObject(message.customProperties))
                    return "customProperties: object expected";
                var key = Object.keys(message.customProperties);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.ml_metadata.Value.verify(message.customProperties[key[i]]);
                    if (error)
                        return "customProperties." + error;
                }
            }
            if (message.createTimeSinceEpoch != null && message.hasOwnProperty("createTimeSinceEpoch"))
                if (!$util.isInteger(message.createTimeSinceEpoch) && !(message.createTimeSinceEpoch && $util.isInteger(message.createTimeSinceEpoch.low) && $util.isInteger(message.createTimeSinceEpoch.high)))
                    return "createTimeSinceEpoch: integer|Long expected";
            if (message.lastUpdateTimeSinceEpoch != null && message.hasOwnProperty("lastUpdateTimeSinceEpoch"))
                if (!$util.isInteger(message.lastUpdateTimeSinceEpoch) && !(message.lastUpdateTimeSinceEpoch && $util.isInteger(message.lastUpdateTimeSinceEpoch.low) && $util.isInteger(message.lastUpdateTimeSinceEpoch.high)))
                    return "lastUpdateTimeSinceEpoch: integer|Long expected";
            return null;
        };

        /**
         * Creates an Execution message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.Execution
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.Execution} Execution
         */
        Execution.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.Execution)
                return object;
            var message = new $root.ml_metadata.Execution();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.typeId != null)
                if ($util.Long)
                    (message.typeId = $util.Long.fromValue(object.typeId)).unsigned = false;
                else if (typeof object.typeId === "string")
                    message.typeId = parseInt(object.typeId, 10);
                else if (typeof object.typeId === "number")
                    message.typeId = object.typeId;
                else if (typeof object.typeId === "object")
                    message.typeId = new $util.LongBits(object.typeId.low >>> 0, object.typeId.high >>> 0).toNumber();
            if (object.type != null)
                message.type = String(object.type);
            switch (object.lastKnownState) {
            case "UNKNOWN":
            case 0:
                message.lastKnownState = 0;
                break;
            case "NEW":
            case 1:
                message.lastKnownState = 1;
                break;
            case "RUNNING":
            case 2:
                message.lastKnownState = 2;
                break;
            case "COMPLETE":
            case 3:
                message.lastKnownState = 3;
                break;
            case "FAILED":
            case 4:
                message.lastKnownState = 4;
                break;
            case "CACHED":
            case 5:
                message.lastKnownState = 5;
                break;
            case "CANCELED":
            case 6:
                message.lastKnownState = 6;
                break;
            }
            if (object.properties) {
                if (typeof object.properties !== "object")
                    throw TypeError(".ml_metadata.Execution.properties: object expected");
                message.properties = {};
                for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                    if (typeof object.properties[keys[i]] !== "object")
                        throw TypeError(".ml_metadata.Execution.properties: object expected");
                    message.properties[keys[i]] = $root.ml_metadata.Value.fromObject(object.properties[keys[i]]);
                }
            }
            if (object.customProperties) {
                if (typeof object.customProperties !== "object")
                    throw TypeError(".ml_metadata.Execution.customProperties: object expected");
                message.customProperties = {};
                for (var keys = Object.keys(object.customProperties), i = 0; i < keys.length; ++i) {
                    if (typeof object.customProperties[keys[i]] !== "object")
                        throw TypeError(".ml_metadata.Execution.customProperties: object expected");
                    message.customProperties[keys[i]] = $root.ml_metadata.Value.fromObject(object.customProperties[keys[i]]);
                }
            }
            if (object.createTimeSinceEpoch != null)
                if ($util.Long)
                    (message.createTimeSinceEpoch = $util.Long.fromValue(object.createTimeSinceEpoch)).unsigned = false;
                else if (typeof object.createTimeSinceEpoch === "string")
                    message.createTimeSinceEpoch = parseInt(object.createTimeSinceEpoch, 10);
                else if (typeof object.createTimeSinceEpoch === "number")
                    message.createTimeSinceEpoch = object.createTimeSinceEpoch;
                else if (typeof object.createTimeSinceEpoch === "object")
                    message.createTimeSinceEpoch = new $util.LongBits(object.createTimeSinceEpoch.low >>> 0, object.createTimeSinceEpoch.high >>> 0).toNumber();
            if (object.lastUpdateTimeSinceEpoch != null)
                if ($util.Long)
                    (message.lastUpdateTimeSinceEpoch = $util.Long.fromValue(object.lastUpdateTimeSinceEpoch)).unsigned = false;
                else if (typeof object.lastUpdateTimeSinceEpoch === "string")
                    message.lastUpdateTimeSinceEpoch = parseInt(object.lastUpdateTimeSinceEpoch, 10);
                else if (typeof object.lastUpdateTimeSinceEpoch === "number")
                    message.lastUpdateTimeSinceEpoch = object.lastUpdateTimeSinceEpoch;
                else if (typeof object.lastUpdateTimeSinceEpoch === "object")
                    message.lastUpdateTimeSinceEpoch = new $util.LongBits(object.lastUpdateTimeSinceEpoch.low >>> 0, object.lastUpdateTimeSinceEpoch.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Execution message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.Execution
         * @static
         * @param {ml_metadata.Execution} message Execution
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Execution.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.properties = {};
                object.customProperties = {};
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.typeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.typeId = options.longs === String ? "0" : 0;
                object.lastKnownState = options.enums === String ? "UNKNOWN" : 0;
                object.name = "";
                object.type = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTimeSinceEpoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTimeSinceEpoch = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (typeof message.typeId === "number")
                    object.typeId = options.longs === String ? String(message.typeId) : message.typeId;
                else
                    object.typeId = options.longs === String ? $util.Long.prototype.toString.call(message.typeId) : options.longs === Number ? new $util.LongBits(message.typeId.low >>> 0, message.typeId.high >>> 0).toNumber() : message.typeId;
            if (message.lastKnownState != null && message.hasOwnProperty("lastKnownState"))
                object.lastKnownState = options.enums === String ? $root.ml_metadata.Execution.State[message.lastKnownState] : message.lastKnownState;
            var keys2;
            if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                object.properties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.properties[keys2[j]] = $root.ml_metadata.Value.toObject(message.properties[keys2[j]], options);
            }
            if (message.customProperties && (keys2 = Object.keys(message.customProperties)).length) {
                object.customProperties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.customProperties[keys2[j]] = $root.ml_metadata.Value.toObject(message.customProperties[keys2[j]], options);
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.createTimeSinceEpoch != null && message.hasOwnProperty("createTimeSinceEpoch"))
                if (typeof message.createTimeSinceEpoch === "number")
                    object.createTimeSinceEpoch = options.longs === String ? String(message.createTimeSinceEpoch) : message.createTimeSinceEpoch;
                else
                    object.createTimeSinceEpoch = options.longs === String ? $util.Long.prototype.toString.call(message.createTimeSinceEpoch) : options.longs === Number ? new $util.LongBits(message.createTimeSinceEpoch.low >>> 0, message.createTimeSinceEpoch.high >>> 0).toNumber() : message.createTimeSinceEpoch;
            if (message.lastUpdateTimeSinceEpoch != null && message.hasOwnProperty("lastUpdateTimeSinceEpoch"))
                if (typeof message.lastUpdateTimeSinceEpoch === "number")
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? String(message.lastUpdateTimeSinceEpoch) : message.lastUpdateTimeSinceEpoch;
                else
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdateTimeSinceEpoch) : options.longs === Number ? new $util.LongBits(message.lastUpdateTimeSinceEpoch.low >>> 0, message.lastUpdateTimeSinceEpoch.high >>> 0).toNumber() : message.lastUpdateTimeSinceEpoch;
            return object;
        };

        /**
         * Converts this Execution to JSON.
         * @function toJSON
         * @memberof ml_metadata.Execution
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Execution.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * State enum.
         * @name ml_metadata.Execution.State
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} NEW=1 NEW value
         * @property {number} RUNNING=2 RUNNING value
         * @property {number} COMPLETE=3 COMPLETE value
         * @property {number} FAILED=4 FAILED value
         * @property {number} CACHED=5 CACHED value
         * @property {number} CANCELED=6 CANCELED value
         */
        Execution.State = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "NEW"] = 1;
            values[valuesById[2] = "RUNNING"] = 2;
            values[valuesById[3] = "COMPLETE"] = 3;
            values[valuesById[4] = "FAILED"] = 4;
            values[valuesById[5] = "CACHED"] = 5;
            values[valuesById[6] = "CANCELED"] = 6;
            return values;
        })();

        return Execution;
    })();

    ml_metadata.ExecutionType = (function() {

        /**
         * Properties of an ExecutionType.
         * @memberof ml_metadata
         * @interface IExecutionType
         * @property {number|Long|null} [id] ExecutionType id
         * @property {string|null} [name] ExecutionType name
         * @property {string|null} [version] ExecutionType version
         * @property {string|null} [description] ExecutionType description
         * @property {Object.<string,ml_metadata.PropertyType>|null} [properties] ExecutionType properties
         * @property {ml_metadata.IArtifactStructType|null} [inputType] ExecutionType inputType
         * @property {ml_metadata.IArtifactStructType|null} [outputType] ExecutionType outputType
         */

        /**
         * Constructs a new ExecutionType.
         * @memberof ml_metadata
         * @classdesc Represents an ExecutionType.
         * @implements IExecutionType
         * @constructor
         * @param {ml_metadata.IExecutionType=} [properties] Properties to set
         */
        function ExecutionType(properties) {
            this.properties = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionType id.
         * @member {number|Long} id
         * @memberof ml_metadata.ExecutionType
         * @instance
         */
        ExecutionType.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExecutionType name.
         * @member {string} name
         * @memberof ml_metadata.ExecutionType
         * @instance
         */
        ExecutionType.prototype.name = "";

        /**
         * ExecutionType version.
         * @member {string} version
         * @memberof ml_metadata.ExecutionType
         * @instance
         */
        ExecutionType.prototype.version = "";

        /**
         * ExecutionType description.
         * @member {string} description
         * @memberof ml_metadata.ExecutionType
         * @instance
         */
        ExecutionType.prototype.description = "";

        /**
         * ExecutionType properties.
         * @member {Object.<string,ml_metadata.PropertyType>} properties
         * @memberof ml_metadata.ExecutionType
         * @instance
         */
        ExecutionType.prototype.properties = $util.emptyObject;

        /**
         * ExecutionType inputType.
         * @member {ml_metadata.IArtifactStructType|null|undefined} inputType
         * @memberof ml_metadata.ExecutionType
         * @instance
         */
        ExecutionType.prototype.inputType = null;

        /**
         * ExecutionType outputType.
         * @member {ml_metadata.IArtifactStructType|null|undefined} outputType
         * @memberof ml_metadata.ExecutionType
         * @instance
         */
        ExecutionType.prototype.outputType = null;

        /**
         * Creates a new ExecutionType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ExecutionType
         * @static
         * @param {ml_metadata.IExecutionType=} [properties] Properties to set
         * @returns {ml_metadata.ExecutionType} ExecutionType instance
         */
        ExecutionType.create = function create(properties) {
            return new ExecutionType(properties);
        };

        /**
         * Encodes the specified ExecutionType message. Does not implicitly {@link ml_metadata.ExecutionType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ExecutionType
         * @static
         * @param {ml_metadata.IExecutionType} message ExecutionType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int32(message.properties[keys[i]]).ldelim();
            if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                $root.ml_metadata.ArtifactStructType.encode(message.inputType, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                $root.ml_metadata.ArtifactStructType.encode(message.outputType, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.version);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified ExecutionType message, length delimited. Does not implicitly {@link ml_metadata.ExecutionType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ExecutionType
         * @static
         * @param {ml_metadata.IExecutionType} message ExecutionType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ExecutionType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ExecutionType} ExecutionType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ExecutionType(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 6:
                    message.version = reader.string();
                    break;
                case 7:
                    message.description = reader.string();
                    break;
                case 3:
                    if (message.properties === $util.emptyObject)
                        message.properties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = 0;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.int32();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.properties[key] = value;
                    break;
                case 4:
                    message.inputType = $root.ml_metadata.ArtifactStructType.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.outputType = $root.ml_metadata.ArtifactStructType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ExecutionType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ExecutionType} ExecutionType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionType message.
         * @function verify
         * @memberof ml_metadata.ExecutionType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!$util.isObject(message.properties))
                    return "properties: object expected";
                var key = Object.keys(message.properties);
                for (var i = 0; i < key.length; ++i)
                    switch (message.properties[key[i]]) {
                    default:
                        return "properties: enum value{k:string} expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
            }
            if (message.inputType != null && message.hasOwnProperty("inputType")) {
                var error = $root.ml_metadata.ArtifactStructType.verify(message.inputType);
                if (error)
                    return "inputType." + error;
            }
            if (message.outputType != null && message.hasOwnProperty("outputType")) {
                var error = $root.ml_metadata.ArtifactStructType.verify(message.outputType);
                if (error)
                    return "outputType." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutionType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ExecutionType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ExecutionType} ExecutionType
         */
        ExecutionType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ExecutionType)
                return object;
            var message = new $root.ml_metadata.ExecutionType();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.version != null)
                message.version = String(object.version);
            if (object.description != null)
                message.description = String(object.description);
            if (object.properties) {
                if (typeof object.properties !== "object")
                    throw TypeError(".ml_metadata.ExecutionType.properties: object expected");
                message.properties = {};
                for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i)
                    switch (object.properties[keys[i]]) {
                    case "UNKNOWN":
                    case 0:
                        message.properties[keys[i]] = 0;
                        break;
                    case "INT":
                    case 1:
                        message.properties[keys[i]] = 1;
                        break;
                    case "DOUBLE":
                    case 2:
                        message.properties[keys[i]] = 2;
                        break;
                    case "STRING":
                    case 3:
                        message.properties[keys[i]] = 3;
                        break;
                    case "STRUCT":
                    case 4:
                        message.properties[keys[i]] = 4;
                        break;
                    }
            }
            if (object.inputType != null) {
                if (typeof object.inputType !== "object")
                    throw TypeError(".ml_metadata.ExecutionType.inputType: object expected");
                message.inputType = $root.ml_metadata.ArtifactStructType.fromObject(object.inputType);
            }
            if (object.outputType != null) {
                if (typeof object.outputType !== "object")
                    throw TypeError(".ml_metadata.ExecutionType.outputType: object expected");
                message.outputType = $root.ml_metadata.ArtifactStructType.fromObject(object.outputType);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ExecutionType
         * @static
         * @param {ml_metadata.ExecutionType} message ExecutionType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.properties = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.name = "";
                object.inputType = null;
                object.outputType = null;
                object.version = "";
                object.description = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            var keys2;
            if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                object.properties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.properties[keys2[j]] = options.enums === String ? $root.ml_metadata.PropertyType[message.properties[keys2[j]]] : message.properties[keys2[j]];
            }
            if (message.inputType != null && message.hasOwnProperty("inputType"))
                object.inputType = $root.ml_metadata.ArtifactStructType.toObject(message.inputType, options);
            if (message.outputType != null && message.hasOwnProperty("outputType"))
                object.outputType = $root.ml_metadata.ArtifactStructType.toObject(message.outputType, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this ExecutionType to JSON.
         * @function toJSON
         * @memberof ml_metadata.ExecutionType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutionType;
    })();

    ml_metadata.ContextType = (function() {

        /**
         * Properties of a ContextType.
         * @memberof ml_metadata
         * @interface IContextType
         * @property {number|Long|null} [id] ContextType id
         * @property {string|null} [name] ContextType name
         * @property {string|null} [version] ContextType version
         * @property {string|null} [description] ContextType description
         * @property {Object.<string,ml_metadata.PropertyType>|null} [properties] ContextType properties
         */

        /**
         * Constructs a new ContextType.
         * @memberof ml_metadata
         * @classdesc Represents a ContextType.
         * @implements IContextType
         * @constructor
         * @param {ml_metadata.IContextType=} [properties] Properties to set
         */
        function ContextType(properties) {
            this.properties = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContextType id.
         * @member {number|Long} id
         * @memberof ml_metadata.ContextType
         * @instance
         */
        ContextType.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContextType name.
         * @member {string} name
         * @memberof ml_metadata.ContextType
         * @instance
         */
        ContextType.prototype.name = "";

        /**
         * ContextType version.
         * @member {string} version
         * @memberof ml_metadata.ContextType
         * @instance
         */
        ContextType.prototype.version = "";

        /**
         * ContextType description.
         * @member {string} description
         * @memberof ml_metadata.ContextType
         * @instance
         */
        ContextType.prototype.description = "";

        /**
         * ContextType properties.
         * @member {Object.<string,ml_metadata.PropertyType>} properties
         * @memberof ml_metadata.ContextType
         * @instance
         */
        ContextType.prototype.properties = $util.emptyObject;

        /**
         * Creates a new ContextType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ContextType
         * @static
         * @param {ml_metadata.IContextType=} [properties] Properties to set
         * @returns {ml_metadata.ContextType} ContextType instance
         */
        ContextType.create = function create(properties) {
            return new ContextType(properties);
        };

        /**
         * Encodes the specified ContextType message. Does not implicitly {@link ml_metadata.ContextType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ContextType
         * @static
         * @param {ml_metadata.IContextType} message ContextType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContextType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int32(message.properties[keys[i]]).ldelim();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.version);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified ContextType message, length delimited. Does not implicitly {@link ml_metadata.ContextType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ContextType
         * @static
         * @param {ml_metadata.IContextType} message ContextType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContextType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContextType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ContextType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ContextType} ContextType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContextType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ContextType(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 4:
                    message.version = reader.string();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                case 3:
                    if (message.properties === $util.emptyObject)
                        message.properties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = 0;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.int32();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.properties[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContextType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ContextType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ContextType} ContextType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContextType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContextType message.
         * @function verify
         * @memberof ml_metadata.ContextType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContextType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!$util.isObject(message.properties))
                    return "properties: object expected";
                var key = Object.keys(message.properties);
                for (var i = 0; i < key.length; ++i)
                    switch (message.properties[key[i]]) {
                    default:
                        return "properties: enum value{k:string} expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a ContextType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ContextType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ContextType} ContextType
         */
        ContextType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ContextType)
                return object;
            var message = new $root.ml_metadata.ContextType();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.version != null)
                message.version = String(object.version);
            if (object.description != null)
                message.description = String(object.description);
            if (object.properties) {
                if (typeof object.properties !== "object")
                    throw TypeError(".ml_metadata.ContextType.properties: object expected");
                message.properties = {};
                for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i)
                    switch (object.properties[keys[i]]) {
                    case "UNKNOWN":
                    case 0:
                        message.properties[keys[i]] = 0;
                        break;
                    case "INT":
                    case 1:
                        message.properties[keys[i]] = 1;
                        break;
                    case "DOUBLE":
                    case 2:
                        message.properties[keys[i]] = 2;
                        break;
                    case "STRING":
                    case 3:
                        message.properties[keys[i]] = 3;
                        break;
                    case "STRUCT":
                    case 4:
                        message.properties[keys[i]] = 4;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a ContextType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ContextType
         * @static
         * @param {ml_metadata.ContextType} message ContextType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContextType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.properties = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.name = "";
                object.version = "";
                object.description = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            var keys2;
            if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                object.properties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.properties[keys2[j]] = options.enums === String ? $root.ml_metadata.PropertyType[message.properties[keys2[j]]] : message.properties[keys2[j]];
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this ContextType to JSON.
         * @function toJSON
         * @memberof ml_metadata.ContextType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContextType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContextType;
    })();

    ml_metadata.Context = (function() {

        /**
         * Properties of a Context.
         * @memberof ml_metadata
         * @interface IContext
         * @property {number|Long|null} [id] Context id
         * @property {string|null} [name] Context name
         * @property {number|Long|null} [typeId] Context typeId
         * @property {string|null} [type] Context type
         * @property {Object.<string,ml_metadata.IValue>|null} [properties] Context properties
         * @property {Object.<string,ml_metadata.IValue>|null} [customProperties] Context customProperties
         * @property {number|Long|null} [createTimeSinceEpoch] Context createTimeSinceEpoch
         * @property {number|Long|null} [lastUpdateTimeSinceEpoch] Context lastUpdateTimeSinceEpoch
         */

        /**
         * Constructs a new Context.
         * @memberof ml_metadata
         * @classdesc Represents a Context.
         * @implements IContext
         * @constructor
         * @param {ml_metadata.IContext=} [properties] Properties to set
         */
        function Context(properties) {
            this.properties = {};
            this.customProperties = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Context id.
         * @member {number|Long} id
         * @memberof ml_metadata.Context
         * @instance
         */
        Context.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Context name.
         * @member {string} name
         * @memberof ml_metadata.Context
         * @instance
         */
        Context.prototype.name = "";

        /**
         * Context typeId.
         * @member {number|Long} typeId
         * @memberof ml_metadata.Context
         * @instance
         */
        Context.prototype.typeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Context type.
         * @member {string} type
         * @memberof ml_metadata.Context
         * @instance
         */
        Context.prototype.type = "";

        /**
         * Context properties.
         * @member {Object.<string,ml_metadata.IValue>} properties
         * @memberof ml_metadata.Context
         * @instance
         */
        Context.prototype.properties = $util.emptyObject;

        /**
         * Context customProperties.
         * @member {Object.<string,ml_metadata.IValue>} customProperties
         * @memberof ml_metadata.Context
         * @instance
         */
        Context.prototype.customProperties = $util.emptyObject;

        /**
         * Context createTimeSinceEpoch.
         * @member {number|Long} createTimeSinceEpoch
         * @memberof ml_metadata.Context
         * @instance
         */
        Context.prototype.createTimeSinceEpoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Context lastUpdateTimeSinceEpoch.
         * @member {number|Long} lastUpdateTimeSinceEpoch
         * @memberof ml_metadata.Context
         * @instance
         */
        Context.prototype.lastUpdateTimeSinceEpoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Context instance using the specified properties.
         * @function create
         * @memberof ml_metadata.Context
         * @static
         * @param {ml_metadata.IContext=} [properties] Properties to set
         * @returns {ml_metadata.Context} Context instance
         */
        Context.create = function create(properties) {
            return new Context(properties);
        };

        /**
         * Encodes the specified Context message. Does not implicitly {@link ml_metadata.Context.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.Context
         * @static
         * @param {ml_metadata.IContext} message Context message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Context.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.typeId != null && Object.hasOwnProperty.call(message, "typeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.typeId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ml_metadata.Value.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.customProperties != null && Object.hasOwnProperty.call(message, "customProperties"))
                for (var keys = Object.keys(message.customProperties), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ml_metadata.Value.encode(message.customProperties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.type);
            if (message.createTimeSinceEpoch != null && Object.hasOwnProperty.call(message, "createTimeSinceEpoch"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.createTimeSinceEpoch);
            if (message.lastUpdateTimeSinceEpoch != null && Object.hasOwnProperty.call(message, "lastUpdateTimeSinceEpoch"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.lastUpdateTimeSinceEpoch);
            return writer;
        };

        /**
         * Encodes the specified Context message, length delimited. Does not implicitly {@link ml_metadata.Context.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.Context
         * @static
         * @param {ml_metadata.IContext} message Context message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Context.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Context message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.Context
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.Context} Context
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Context.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.Context(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 2:
                    message.typeId = reader.int64();
                    break;
                case 6:
                    message.type = reader.string();
                    break;
                case 4:
                    if (message.properties === $util.emptyObject)
                        message.properties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.ml_metadata.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.properties[key] = value;
                    break;
                case 5:
                    if (message.customProperties === $util.emptyObject)
                        message.customProperties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.ml_metadata.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.customProperties[key] = value;
                    break;
                case 7:
                    message.createTimeSinceEpoch = reader.int64();
                    break;
                case 8:
                    message.lastUpdateTimeSinceEpoch = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Context message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.Context
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.Context} Context
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Context.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Context message.
         * @function verify
         * @memberof ml_metadata.Context
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Context.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (!$util.isInteger(message.typeId) && !(message.typeId && $util.isInteger(message.typeId.low) && $util.isInteger(message.typeId.high)))
                    return "typeId: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!$util.isObject(message.properties))
                    return "properties: object expected";
                var key = Object.keys(message.properties);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.ml_metadata.Value.verify(message.properties[key[i]]);
                    if (error)
                        return "properties." + error;
                }
            }
            if (message.customProperties != null && message.hasOwnProperty("customProperties")) {
                if (!$util.isObject(message.customProperties))
                    return "customProperties: object expected";
                var key = Object.keys(message.customProperties);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.ml_metadata.Value.verify(message.customProperties[key[i]]);
                    if (error)
                        return "customProperties." + error;
                }
            }
            if (message.createTimeSinceEpoch != null && message.hasOwnProperty("createTimeSinceEpoch"))
                if (!$util.isInteger(message.createTimeSinceEpoch) && !(message.createTimeSinceEpoch && $util.isInteger(message.createTimeSinceEpoch.low) && $util.isInteger(message.createTimeSinceEpoch.high)))
                    return "createTimeSinceEpoch: integer|Long expected";
            if (message.lastUpdateTimeSinceEpoch != null && message.hasOwnProperty("lastUpdateTimeSinceEpoch"))
                if (!$util.isInteger(message.lastUpdateTimeSinceEpoch) && !(message.lastUpdateTimeSinceEpoch && $util.isInteger(message.lastUpdateTimeSinceEpoch.low) && $util.isInteger(message.lastUpdateTimeSinceEpoch.high)))
                    return "lastUpdateTimeSinceEpoch: integer|Long expected";
            return null;
        };

        /**
         * Creates a Context message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.Context
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.Context} Context
         */
        Context.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.Context)
                return object;
            var message = new $root.ml_metadata.Context();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.typeId != null)
                if ($util.Long)
                    (message.typeId = $util.Long.fromValue(object.typeId)).unsigned = false;
                else if (typeof object.typeId === "string")
                    message.typeId = parseInt(object.typeId, 10);
                else if (typeof object.typeId === "number")
                    message.typeId = object.typeId;
                else if (typeof object.typeId === "object")
                    message.typeId = new $util.LongBits(object.typeId.low >>> 0, object.typeId.high >>> 0).toNumber();
            if (object.type != null)
                message.type = String(object.type);
            if (object.properties) {
                if (typeof object.properties !== "object")
                    throw TypeError(".ml_metadata.Context.properties: object expected");
                message.properties = {};
                for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                    if (typeof object.properties[keys[i]] !== "object")
                        throw TypeError(".ml_metadata.Context.properties: object expected");
                    message.properties[keys[i]] = $root.ml_metadata.Value.fromObject(object.properties[keys[i]]);
                }
            }
            if (object.customProperties) {
                if (typeof object.customProperties !== "object")
                    throw TypeError(".ml_metadata.Context.customProperties: object expected");
                message.customProperties = {};
                for (var keys = Object.keys(object.customProperties), i = 0; i < keys.length; ++i) {
                    if (typeof object.customProperties[keys[i]] !== "object")
                        throw TypeError(".ml_metadata.Context.customProperties: object expected");
                    message.customProperties[keys[i]] = $root.ml_metadata.Value.fromObject(object.customProperties[keys[i]]);
                }
            }
            if (object.createTimeSinceEpoch != null)
                if ($util.Long)
                    (message.createTimeSinceEpoch = $util.Long.fromValue(object.createTimeSinceEpoch)).unsigned = false;
                else if (typeof object.createTimeSinceEpoch === "string")
                    message.createTimeSinceEpoch = parseInt(object.createTimeSinceEpoch, 10);
                else if (typeof object.createTimeSinceEpoch === "number")
                    message.createTimeSinceEpoch = object.createTimeSinceEpoch;
                else if (typeof object.createTimeSinceEpoch === "object")
                    message.createTimeSinceEpoch = new $util.LongBits(object.createTimeSinceEpoch.low >>> 0, object.createTimeSinceEpoch.high >>> 0).toNumber();
            if (object.lastUpdateTimeSinceEpoch != null)
                if ($util.Long)
                    (message.lastUpdateTimeSinceEpoch = $util.Long.fromValue(object.lastUpdateTimeSinceEpoch)).unsigned = false;
                else if (typeof object.lastUpdateTimeSinceEpoch === "string")
                    message.lastUpdateTimeSinceEpoch = parseInt(object.lastUpdateTimeSinceEpoch, 10);
                else if (typeof object.lastUpdateTimeSinceEpoch === "number")
                    message.lastUpdateTimeSinceEpoch = object.lastUpdateTimeSinceEpoch;
                else if (typeof object.lastUpdateTimeSinceEpoch === "object")
                    message.lastUpdateTimeSinceEpoch = new $util.LongBits(object.lastUpdateTimeSinceEpoch.low >>> 0, object.lastUpdateTimeSinceEpoch.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Context message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.Context
         * @static
         * @param {ml_metadata.Context} message Context
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Context.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.properties = {};
                object.customProperties = {};
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.typeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.typeId = options.longs === String ? "0" : 0;
                object.name = "";
                object.type = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTimeSinceEpoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTimeSinceEpoch = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (typeof message.typeId === "number")
                    object.typeId = options.longs === String ? String(message.typeId) : message.typeId;
                else
                    object.typeId = options.longs === String ? $util.Long.prototype.toString.call(message.typeId) : options.longs === Number ? new $util.LongBits(message.typeId.low >>> 0, message.typeId.high >>> 0).toNumber() : message.typeId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            var keys2;
            if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                object.properties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.properties[keys2[j]] = $root.ml_metadata.Value.toObject(message.properties[keys2[j]], options);
            }
            if (message.customProperties && (keys2 = Object.keys(message.customProperties)).length) {
                object.customProperties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.customProperties[keys2[j]] = $root.ml_metadata.Value.toObject(message.customProperties[keys2[j]], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.createTimeSinceEpoch != null && message.hasOwnProperty("createTimeSinceEpoch"))
                if (typeof message.createTimeSinceEpoch === "number")
                    object.createTimeSinceEpoch = options.longs === String ? String(message.createTimeSinceEpoch) : message.createTimeSinceEpoch;
                else
                    object.createTimeSinceEpoch = options.longs === String ? $util.Long.prototype.toString.call(message.createTimeSinceEpoch) : options.longs === Number ? new $util.LongBits(message.createTimeSinceEpoch.low >>> 0, message.createTimeSinceEpoch.high >>> 0).toNumber() : message.createTimeSinceEpoch;
            if (message.lastUpdateTimeSinceEpoch != null && message.hasOwnProperty("lastUpdateTimeSinceEpoch"))
                if (typeof message.lastUpdateTimeSinceEpoch === "number")
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? String(message.lastUpdateTimeSinceEpoch) : message.lastUpdateTimeSinceEpoch;
                else
                    object.lastUpdateTimeSinceEpoch = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdateTimeSinceEpoch) : options.longs === Number ? new $util.LongBits(message.lastUpdateTimeSinceEpoch.low >>> 0, message.lastUpdateTimeSinceEpoch.high >>> 0).toNumber() : message.lastUpdateTimeSinceEpoch;
            return object;
        };

        /**
         * Converts this Context to JSON.
         * @function toJSON
         * @memberof ml_metadata.Context
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Context.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Context;
    })();

    ml_metadata.Attribution = (function() {

        /**
         * Properties of an Attribution.
         * @memberof ml_metadata
         * @interface IAttribution
         * @property {number|Long|null} [artifactId] Attribution artifactId
         * @property {number|Long|null} [contextId] Attribution contextId
         */

        /**
         * Constructs a new Attribution.
         * @memberof ml_metadata
         * @classdesc Represents an Attribution.
         * @implements IAttribution
         * @constructor
         * @param {ml_metadata.IAttribution=} [properties] Properties to set
         */
        function Attribution(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Attribution artifactId.
         * @member {number|Long} artifactId
         * @memberof ml_metadata.Attribution
         * @instance
         */
        Attribution.prototype.artifactId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Attribution contextId.
         * @member {number|Long} contextId
         * @memberof ml_metadata.Attribution
         * @instance
         */
        Attribution.prototype.contextId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Attribution instance using the specified properties.
         * @function create
         * @memberof ml_metadata.Attribution
         * @static
         * @param {ml_metadata.IAttribution=} [properties] Properties to set
         * @returns {ml_metadata.Attribution} Attribution instance
         */
        Attribution.create = function create(properties) {
            return new Attribution(properties);
        };

        /**
         * Encodes the specified Attribution message. Does not implicitly {@link ml_metadata.Attribution.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.Attribution
         * @static
         * @param {ml_metadata.IAttribution} message Attribution message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Attribution.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactId != null && Object.hasOwnProperty.call(message, "artifactId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.artifactId);
            if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.contextId);
            return writer;
        };

        /**
         * Encodes the specified Attribution message, length delimited. Does not implicitly {@link ml_metadata.Attribution.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.Attribution
         * @static
         * @param {ml_metadata.IAttribution} message Attribution message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Attribution.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Attribution message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.Attribution
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.Attribution} Attribution
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Attribution.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.Attribution();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.artifactId = reader.int64();
                    break;
                case 2:
                    message.contextId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Attribution message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.Attribution
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.Attribution} Attribution
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Attribution.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Attribution message.
         * @function verify
         * @memberof ml_metadata.Attribution
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Attribution.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactId != null && message.hasOwnProperty("artifactId"))
                if (!$util.isInteger(message.artifactId) && !(message.artifactId && $util.isInteger(message.artifactId.low) && $util.isInteger(message.artifactId.high)))
                    return "artifactId: integer|Long expected";
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (!$util.isInteger(message.contextId) && !(message.contextId && $util.isInteger(message.contextId.low) && $util.isInteger(message.contextId.high)))
                    return "contextId: integer|Long expected";
            return null;
        };

        /**
         * Creates an Attribution message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.Attribution
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.Attribution} Attribution
         */
        Attribution.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.Attribution)
                return object;
            var message = new $root.ml_metadata.Attribution();
            if (object.artifactId != null)
                if ($util.Long)
                    (message.artifactId = $util.Long.fromValue(object.artifactId)).unsigned = false;
                else if (typeof object.artifactId === "string")
                    message.artifactId = parseInt(object.artifactId, 10);
                else if (typeof object.artifactId === "number")
                    message.artifactId = object.artifactId;
                else if (typeof object.artifactId === "object")
                    message.artifactId = new $util.LongBits(object.artifactId.low >>> 0, object.artifactId.high >>> 0).toNumber();
            if (object.contextId != null)
                if ($util.Long)
                    (message.contextId = $util.Long.fromValue(object.contextId)).unsigned = false;
                else if (typeof object.contextId === "string")
                    message.contextId = parseInt(object.contextId, 10);
                else if (typeof object.contextId === "number")
                    message.contextId = object.contextId;
                else if (typeof object.contextId === "object")
                    message.contextId = new $util.LongBits(object.contextId.low >>> 0, object.contextId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Attribution message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.Attribution
         * @static
         * @param {ml_metadata.Attribution} message Attribution
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Attribution.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.artifactId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.artifactId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.contextId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.contextId = options.longs === String ? "0" : 0;
            }
            if (message.artifactId != null && message.hasOwnProperty("artifactId"))
                if (typeof message.artifactId === "number")
                    object.artifactId = options.longs === String ? String(message.artifactId) : message.artifactId;
                else
                    object.artifactId = options.longs === String ? $util.Long.prototype.toString.call(message.artifactId) : options.longs === Number ? new $util.LongBits(message.artifactId.low >>> 0, message.artifactId.high >>> 0).toNumber() : message.artifactId;
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (typeof message.contextId === "number")
                    object.contextId = options.longs === String ? String(message.contextId) : message.contextId;
                else
                    object.contextId = options.longs === String ? $util.Long.prototype.toString.call(message.contextId) : options.longs === Number ? new $util.LongBits(message.contextId.low >>> 0, message.contextId.high >>> 0).toNumber() : message.contextId;
            return object;
        };

        /**
         * Converts this Attribution to JSON.
         * @function toJSON
         * @memberof ml_metadata.Attribution
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Attribution.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Attribution;
    })();

    ml_metadata.Association = (function() {

        /**
         * Properties of an Association.
         * @memberof ml_metadata
         * @interface IAssociation
         * @property {number|Long|null} [executionId] Association executionId
         * @property {number|Long|null} [contextId] Association contextId
         */

        /**
         * Constructs a new Association.
         * @memberof ml_metadata
         * @classdesc Represents an Association.
         * @implements IAssociation
         * @constructor
         * @param {ml_metadata.IAssociation=} [properties] Properties to set
         */
        function Association(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Association executionId.
         * @member {number|Long} executionId
         * @memberof ml_metadata.Association
         * @instance
         */
        Association.prototype.executionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Association contextId.
         * @member {number|Long} contextId
         * @memberof ml_metadata.Association
         * @instance
         */
        Association.prototype.contextId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Association instance using the specified properties.
         * @function create
         * @memberof ml_metadata.Association
         * @static
         * @param {ml_metadata.IAssociation=} [properties] Properties to set
         * @returns {ml_metadata.Association} Association instance
         */
        Association.create = function create(properties) {
            return new Association(properties);
        };

        /**
         * Encodes the specified Association message. Does not implicitly {@link ml_metadata.Association.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.Association
         * @static
         * @param {ml_metadata.IAssociation} message Association message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Association.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executionId != null && Object.hasOwnProperty.call(message, "executionId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.executionId);
            if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.contextId);
            return writer;
        };

        /**
         * Encodes the specified Association message, length delimited. Does not implicitly {@link ml_metadata.Association.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.Association
         * @static
         * @param {ml_metadata.IAssociation} message Association message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Association.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Association message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.Association
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.Association} Association
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Association.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.Association();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.executionId = reader.int64();
                    break;
                case 2:
                    message.contextId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Association message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.Association
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.Association} Association
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Association.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Association message.
         * @function verify
         * @memberof ml_metadata.Association
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Association.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executionId != null && message.hasOwnProperty("executionId"))
                if (!$util.isInteger(message.executionId) && !(message.executionId && $util.isInteger(message.executionId.low) && $util.isInteger(message.executionId.high)))
                    return "executionId: integer|Long expected";
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (!$util.isInteger(message.contextId) && !(message.contextId && $util.isInteger(message.contextId.low) && $util.isInteger(message.contextId.high)))
                    return "contextId: integer|Long expected";
            return null;
        };

        /**
         * Creates an Association message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.Association
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.Association} Association
         */
        Association.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.Association)
                return object;
            var message = new $root.ml_metadata.Association();
            if (object.executionId != null)
                if ($util.Long)
                    (message.executionId = $util.Long.fromValue(object.executionId)).unsigned = false;
                else if (typeof object.executionId === "string")
                    message.executionId = parseInt(object.executionId, 10);
                else if (typeof object.executionId === "number")
                    message.executionId = object.executionId;
                else if (typeof object.executionId === "object")
                    message.executionId = new $util.LongBits(object.executionId.low >>> 0, object.executionId.high >>> 0).toNumber();
            if (object.contextId != null)
                if ($util.Long)
                    (message.contextId = $util.Long.fromValue(object.contextId)).unsigned = false;
                else if (typeof object.contextId === "string")
                    message.contextId = parseInt(object.contextId, 10);
                else if (typeof object.contextId === "number")
                    message.contextId = object.contextId;
                else if (typeof object.contextId === "object")
                    message.contextId = new $util.LongBits(object.contextId.low >>> 0, object.contextId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Association message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.Association
         * @static
         * @param {ml_metadata.Association} message Association
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Association.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.executionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.executionId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.contextId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.contextId = options.longs === String ? "0" : 0;
            }
            if (message.executionId != null && message.hasOwnProperty("executionId"))
                if (typeof message.executionId === "number")
                    object.executionId = options.longs === String ? String(message.executionId) : message.executionId;
                else
                    object.executionId = options.longs === String ? $util.Long.prototype.toString.call(message.executionId) : options.longs === Number ? new $util.LongBits(message.executionId.low >>> 0, message.executionId.high >>> 0).toNumber() : message.executionId;
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (typeof message.contextId === "number")
                    object.contextId = options.longs === String ? String(message.contextId) : message.contextId;
                else
                    object.contextId = options.longs === String ? $util.Long.prototype.toString.call(message.contextId) : options.longs === Number ? new $util.LongBits(message.contextId.low >>> 0, message.contextId.high >>> 0).toNumber() : message.contextId;
            return object;
        };

        /**
         * Converts this Association to JSON.
         * @function toJSON
         * @memberof ml_metadata.Association
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Association.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Association;
    })();

    ml_metadata.ParentContext = (function() {

        /**
         * Properties of a ParentContext.
         * @memberof ml_metadata
         * @interface IParentContext
         * @property {number|Long|null} [childId] ParentContext childId
         * @property {number|Long|null} [parentId] ParentContext parentId
         */

        /**
         * Constructs a new ParentContext.
         * @memberof ml_metadata
         * @classdesc Represents a ParentContext.
         * @implements IParentContext
         * @constructor
         * @param {ml_metadata.IParentContext=} [properties] Properties to set
         */
        function ParentContext(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ParentContext childId.
         * @member {number|Long} childId
         * @memberof ml_metadata.ParentContext
         * @instance
         */
        ParentContext.prototype.childId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ParentContext parentId.
         * @member {number|Long} parentId
         * @memberof ml_metadata.ParentContext
         * @instance
         */
        ParentContext.prototype.parentId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ParentContext instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ParentContext
         * @static
         * @param {ml_metadata.IParentContext=} [properties] Properties to set
         * @returns {ml_metadata.ParentContext} ParentContext instance
         */
        ParentContext.create = function create(properties) {
            return new ParentContext(properties);
        };

        /**
         * Encodes the specified ParentContext message. Does not implicitly {@link ml_metadata.ParentContext.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ParentContext
         * @static
         * @param {ml_metadata.IParentContext} message ParentContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ParentContext.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.childId != null && Object.hasOwnProperty.call(message, "childId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.childId);
            if (message.parentId != null && Object.hasOwnProperty.call(message, "parentId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.parentId);
            return writer;
        };

        /**
         * Encodes the specified ParentContext message, length delimited. Does not implicitly {@link ml_metadata.ParentContext.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ParentContext
         * @static
         * @param {ml_metadata.IParentContext} message ParentContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ParentContext.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ParentContext message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ParentContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ParentContext} ParentContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ParentContext.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ParentContext();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.childId = reader.int64();
                    break;
                case 2:
                    message.parentId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ParentContext message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ParentContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ParentContext} ParentContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ParentContext.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ParentContext message.
         * @function verify
         * @memberof ml_metadata.ParentContext
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ParentContext.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.childId != null && message.hasOwnProperty("childId"))
                if (!$util.isInteger(message.childId) && !(message.childId && $util.isInteger(message.childId.low) && $util.isInteger(message.childId.high)))
                    return "childId: integer|Long expected";
            if (message.parentId != null && message.hasOwnProperty("parentId"))
                if (!$util.isInteger(message.parentId) && !(message.parentId && $util.isInteger(message.parentId.low) && $util.isInteger(message.parentId.high)))
                    return "parentId: integer|Long expected";
            return null;
        };

        /**
         * Creates a ParentContext message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ParentContext
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ParentContext} ParentContext
         */
        ParentContext.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ParentContext)
                return object;
            var message = new $root.ml_metadata.ParentContext();
            if (object.childId != null)
                if ($util.Long)
                    (message.childId = $util.Long.fromValue(object.childId)).unsigned = false;
                else if (typeof object.childId === "string")
                    message.childId = parseInt(object.childId, 10);
                else if (typeof object.childId === "number")
                    message.childId = object.childId;
                else if (typeof object.childId === "object")
                    message.childId = new $util.LongBits(object.childId.low >>> 0, object.childId.high >>> 0).toNumber();
            if (object.parentId != null)
                if ($util.Long)
                    (message.parentId = $util.Long.fromValue(object.parentId)).unsigned = false;
                else if (typeof object.parentId === "string")
                    message.parentId = parseInt(object.parentId, 10);
                else if (typeof object.parentId === "number")
                    message.parentId = object.parentId;
                else if (typeof object.parentId === "object")
                    message.parentId = new $util.LongBits(object.parentId.low >>> 0, object.parentId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ParentContext message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ParentContext
         * @static
         * @param {ml_metadata.ParentContext} message ParentContext
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ParentContext.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.childId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.childId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.parentId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.parentId = options.longs === String ? "0" : 0;
            }
            if (message.childId != null && message.hasOwnProperty("childId"))
                if (typeof message.childId === "number")
                    object.childId = options.longs === String ? String(message.childId) : message.childId;
                else
                    object.childId = options.longs === String ? $util.Long.prototype.toString.call(message.childId) : options.longs === Number ? new $util.LongBits(message.childId.low >>> 0, message.childId.high >>> 0).toNumber() : message.childId;
            if (message.parentId != null && message.hasOwnProperty("parentId"))
                if (typeof message.parentId === "number")
                    object.parentId = options.longs === String ? String(message.parentId) : message.parentId;
                else
                    object.parentId = options.longs === String ? $util.Long.prototype.toString.call(message.parentId) : options.longs === Number ? new $util.LongBits(message.parentId.low >>> 0, message.parentId.high >>> 0).toNumber() : message.parentId;
            return object;
        };

        /**
         * Converts this ParentContext to JSON.
         * @function toJSON
         * @memberof ml_metadata.ParentContext
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ParentContext.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ParentContext;
    })();

    ml_metadata.LineageGraph = (function() {

        /**
         * Properties of a LineageGraph.
         * @memberof ml_metadata
         * @interface ILineageGraph
         * @property {Array.<ml_metadata.IArtifactType>|null} [artifactTypes] LineageGraph artifactTypes
         * @property {Array.<ml_metadata.IExecutionType>|null} [executionTypes] LineageGraph executionTypes
         * @property {Array.<ml_metadata.IContextType>|null} [contextTypes] LineageGraph contextTypes
         * @property {Array.<ml_metadata.IArtifact>|null} [artifacts] LineageGraph artifacts
         * @property {Array.<ml_metadata.IExecution>|null} [executions] LineageGraph executions
         * @property {Array.<ml_metadata.IContext>|null} [contexts] LineageGraph contexts
         * @property {Array.<ml_metadata.IEvent>|null} [events] LineageGraph events
         * @property {Array.<ml_metadata.IAttribution>|null} [attributions] LineageGraph attributions
         * @property {Array.<ml_metadata.IAssociation>|null} [associations] LineageGraph associations
         */

        /**
         * Constructs a new LineageGraph.
         * @memberof ml_metadata
         * @classdesc Represents a LineageGraph.
         * @implements ILineageGraph
         * @constructor
         * @param {ml_metadata.ILineageGraph=} [properties] Properties to set
         */
        function LineageGraph(properties) {
            this.artifactTypes = [];
            this.executionTypes = [];
            this.contextTypes = [];
            this.artifacts = [];
            this.executions = [];
            this.contexts = [];
            this.events = [];
            this.attributions = [];
            this.associations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LineageGraph artifactTypes.
         * @member {Array.<ml_metadata.IArtifactType>} artifactTypes
         * @memberof ml_metadata.LineageGraph
         * @instance
         */
        LineageGraph.prototype.artifactTypes = $util.emptyArray;

        /**
         * LineageGraph executionTypes.
         * @member {Array.<ml_metadata.IExecutionType>} executionTypes
         * @memberof ml_metadata.LineageGraph
         * @instance
         */
        LineageGraph.prototype.executionTypes = $util.emptyArray;

        /**
         * LineageGraph contextTypes.
         * @member {Array.<ml_metadata.IContextType>} contextTypes
         * @memberof ml_metadata.LineageGraph
         * @instance
         */
        LineageGraph.prototype.contextTypes = $util.emptyArray;

        /**
         * LineageGraph artifacts.
         * @member {Array.<ml_metadata.IArtifact>} artifacts
         * @memberof ml_metadata.LineageGraph
         * @instance
         */
        LineageGraph.prototype.artifacts = $util.emptyArray;

        /**
         * LineageGraph executions.
         * @member {Array.<ml_metadata.IExecution>} executions
         * @memberof ml_metadata.LineageGraph
         * @instance
         */
        LineageGraph.prototype.executions = $util.emptyArray;

        /**
         * LineageGraph contexts.
         * @member {Array.<ml_metadata.IContext>} contexts
         * @memberof ml_metadata.LineageGraph
         * @instance
         */
        LineageGraph.prototype.contexts = $util.emptyArray;

        /**
         * LineageGraph events.
         * @member {Array.<ml_metadata.IEvent>} events
         * @memberof ml_metadata.LineageGraph
         * @instance
         */
        LineageGraph.prototype.events = $util.emptyArray;

        /**
         * LineageGraph attributions.
         * @member {Array.<ml_metadata.IAttribution>} attributions
         * @memberof ml_metadata.LineageGraph
         * @instance
         */
        LineageGraph.prototype.attributions = $util.emptyArray;

        /**
         * LineageGraph associations.
         * @member {Array.<ml_metadata.IAssociation>} associations
         * @memberof ml_metadata.LineageGraph
         * @instance
         */
        LineageGraph.prototype.associations = $util.emptyArray;

        /**
         * Creates a new LineageGraph instance using the specified properties.
         * @function create
         * @memberof ml_metadata.LineageGraph
         * @static
         * @param {ml_metadata.ILineageGraph=} [properties] Properties to set
         * @returns {ml_metadata.LineageGraph} LineageGraph instance
         */
        LineageGraph.create = function create(properties) {
            return new LineageGraph(properties);
        };

        /**
         * Encodes the specified LineageGraph message. Does not implicitly {@link ml_metadata.LineageGraph.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.LineageGraph
         * @static
         * @param {ml_metadata.ILineageGraph} message LineageGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LineageGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.artifactTypes != null && message.artifactTypes.length)
                for (var i = 0; i < message.artifactTypes.length; ++i)
                    $root.ml_metadata.ArtifactType.encode(message.artifactTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.executionTypes != null && message.executionTypes.length)
                for (var i = 0; i < message.executionTypes.length; ++i)
                    $root.ml_metadata.ExecutionType.encode(message.executionTypes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.contextTypes != null && message.contextTypes.length)
                for (var i = 0; i < message.contextTypes.length; ++i)
                    $root.ml_metadata.ContextType.encode(message.contextTypes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.artifacts != null && message.artifacts.length)
                for (var i = 0; i < message.artifacts.length; ++i)
                    $root.ml_metadata.Artifact.encode(message.artifacts[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.executions != null && message.executions.length)
                for (var i = 0; i < message.executions.length; ++i)
                    $root.ml_metadata.Execution.encode(message.executions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.contexts != null && message.contexts.length)
                for (var i = 0; i < message.contexts.length; ++i)
                    $root.ml_metadata.Context.encode(message.contexts[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.ml_metadata.Event.encode(message.events[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.attributions != null && message.attributions.length)
                for (var i = 0; i < message.attributions.length; ++i)
                    $root.ml_metadata.Attribution.encode(message.attributions[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.associations != null && message.associations.length)
                for (var i = 0; i < message.associations.length; ++i)
                    $root.ml_metadata.Association.encode(message.associations[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LineageGraph message, length delimited. Does not implicitly {@link ml_metadata.LineageGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.LineageGraph
         * @static
         * @param {ml_metadata.ILineageGraph} message LineageGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LineageGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LineageGraph message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.LineageGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.LineageGraph} LineageGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LineageGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.LineageGraph();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.artifactTypes && message.artifactTypes.length))
                        message.artifactTypes = [];
                    message.artifactTypes.push($root.ml_metadata.ArtifactType.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.executionTypes && message.executionTypes.length))
                        message.executionTypes = [];
                    message.executionTypes.push($root.ml_metadata.ExecutionType.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.contextTypes && message.contextTypes.length))
                        message.contextTypes = [];
                    message.contextTypes.push($root.ml_metadata.ContextType.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.artifacts && message.artifacts.length))
                        message.artifacts = [];
                    message.artifacts.push($root.ml_metadata.Artifact.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.executions && message.executions.length))
                        message.executions = [];
                    message.executions.push($root.ml_metadata.Execution.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.contexts && message.contexts.length))
                        message.contexts = [];
                    message.contexts.push($root.ml_metadata.Context.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.ml_metadata.Event.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.attributions && message.attributions.length))
                        message.attributions = [];
                    message.attributions.push($root.ml_metadata.Attribution.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.associations && message.associations.length))
                        message.associations = [];
                    message.associations.push($root.ml_metadata.Association.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LineageGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.LineageGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.LineageGraph} LineageGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LineageGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LineageGraph message.
         * @function verify
         * @memberof ml_metadata.LineageGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LineageGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.artifactTypes != null && message.hasOwnProperty("artifactTypes")) {
                if (!Array.isArray(message.artifactTypes))
                    return "artifactTypes: array expected";
                for (var i = 0; i < message.artifactTypes.length; ++i) {
                    var error = $root.ml_metadata.ArtifactType.verify(message.artifactTypes[i]);
                    if (error)
                        return "artifactTypes." + error;
                }
            }
            if (message.executionTypes != null && message.hasOwnProperty("executionTypes")) {
                if (!Array.isArray(message.executionTypes))
                    return "executionTypes: array expected";
                for (var i = 0; i < message.executionTypes.length; ++i) {
                    var error = $root.ml_metadata.ExecutionType.verify(message.executionTypes[i]);
                    if (error)
                        return "executionTypes." + error;
                }
            }
            if (message.contextTypes != null && message.hasOwnProperty("contextTypes")) {
                if (!Array.isArray(message.contextTypes))
                    return "contextTypes: array expected";
                for (var i = 0; i < message.contextTypes.length; ++i) {
                    var error = $root.ml_metadata.ContextType.verify(message.contextTypes[i]);
                    if (error)
                        return "contextTypes." + error;
                }
            }
            if (message.artifacts != null && message.hasOwnProperty("artifacts")) {
                if (!Array.isArray(message.artifacts))
                    return "artifacts: array expected";
                for (var i = 0; i < message.artifacts.length; ++i) {
                    var error = $root.ml_metadata.Artifact.verify(message.artifacts[i]);
                    if (error)
                        return "artifacts." + error;
                }
            }
            if (message.executions != null && message.hasOwnProperty("executions")) {
                if (!Array.isArray(message.executions))
                    return "executions: array expected";
                for (var i = 0; i < message.executions.length; ++i) {
                    var error = $root.ml_metadata.Execution.verify(message.executions[i]);
                    if (error)
                        return "executions." + error;
                }
            }
            if (message.contexts != null && message.hasOwnProperty("contexts")) {
                if (!Array.isArray(message.contexts))
                    return "contexts: array expected";
                for (var i = 0; i < message.contexts.length; ++i) {
                    var error = $root.ml_metadata.Context.verify(message.contexts[i]);
                    if (error)
                        return "contexts." + error;
                }
            }
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.ml_metadata.Event.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            if (message.attributions != null && message.hasOwnProperty("attributions")) {
                if (!Array.isArray(message.attributions))
                    return "attributions: array expected";
                for (var i = 0; i < message.attributions.length; ++i) {
                    var error = $root.ml_metadata.Attribution.verify(message.attributions[i]);
                    if (error)
                        return "attributions." + error;
                }
            }
            if (message.associations != null && message.hasOwnProperty("associations")) {
                if (!Array.isArray(message.associations))
                    return "associations: array expected";
                for (var i = 0; i < message.associations.length; ++i) {
                    var error = $root.ml_metadata.Association.verify(message.associations[i]);
                    if (error)
                        return "associations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LineageGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.LineageGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.LineageGraph} LineageGraph
         */
        LineageGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.LineageGraph)
                return object;
            var message = new $root.ml_metadata.LineageGraph();
            if (object.artifactTypes) {
                if (!Array.isArray(object.artifactTypes))
                    throw TypeError(".ml_metadata.LineageGraph.artifactTypes: array expected");
                message.artifactTypes = [];
                for (var i = 0; i < object.artifactTypes.length; ++i) {
                    if (typeof object.artifactTypes[i] !== "object")
                        throw TypeError(".ml_metadata.LineageGraph.artifactTypes: object expected");
                    message.artifactTypes[i] = $root.ml_metadata.ArtifactType.fromObject(object.artifactTypes[i]);
                }
            }
            if (object.executionTypes) {
                if (!Array.isArray(object.executionTypes))
                    throw TypeError(".ml_metadata.LineageGraph.executionTypes: array expected");
                message.executionTypes = [];
                for (var i = 0; i < object.executionTypes.length; ++i) {
                    if (typeof object.executionTypes[i] !== "object")
                        throw TypeError(".ml_metadata.LineageGraph.executionTypes: object expected");
                    message.executionTypes[i] = $root.ml_metadata.ExecutionType.fromObject(object.executionTypes[i]);
                }
            }
            if (object.contextTypes) {
                if (!Array.isArray(object.contextTypes))
                    throw TypeError(".ml_metadata.LineageGraph.contextTypes: array expected");
                message.contextTypes = [];
                for (var i = 0; i < object.contextTypes.length; ++i) {
                    if (typeof object.contextTypes[i] !== "object")
                        throw TypeError(".ml_metadata.LineageGraph.contextTypes: object expected");
                    message.contextTypes[i] = $root.ml_metadata.ContextType.fromObject(object.contextTypes[i]);
                }
            }
            if (object.artifacts) {
                if (!Array.isArray(object.artifacts))
                    throw TypeError(".ml_metadata.LineageGraph.artifacts: array expected");
                message.artifacts = [];
                for (var i = 0; i < object.artifacts.length; ++i) {
                    if (typeof object.artifacts[i] !== "object")
                        throw TypeError(".ml_metadata.LineageGraph.artifacts: object expected");
                    message.artifacts[i] = $root.ml_metadata.Artifact.fromObject(object.artifacts[i]);
                }
            }
            if (object.executions) {
                if (!Array.isArray(object.executions))
                    throw TypeError(".ml_metadata.LineageGraph.executions: array expected");
                message.executions = [];
                for (var i = 0; i < object.executions.length; ++i) {
                    if (typeof object.executions[i] !== "object")
                        throw TypeError(".ml_metadata.LineageGraph.executions: object expected");
                    message.executions[i] = $root.ml_metadata.Execution.fromObject(object.executions[i]);
                }
            }
            if (object.contexts) {
                if (!Array.isArray(object.contexts))
                    throw TypeError(".ml_metadata.LineageGraph.contexts: array expected");
                message.contexts = [];
                for (var i = 0; i < object.contexts.length; ++i) {
                    if (typeof object.contexts[i] !== "object")
                        throw TypeError(".ml_metadata.LineageGraph.contexts: object expected");
                    message.contexts[i] = $root.ml_metadata.Context.fromObject(object.contexts[i]);
                }
            }
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".ml_metadata.LineageGraph.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".ml_metadata.LineageGraph.events: object expected");
                    message.events[i] = $root.ml_metadata.Event.fromObject(object.events[i]);
                }
            }
            if (object.attributions) {
                if (!Array.isArray(object.attributions))
                    throw TypeError(".ml_metadata.LineageGraph.attributions: array expected");
                message.attributions = [];
                for (var i = 0; i < object.attributions.length; ++i) {
                    if (typeof object.attributions[i] !== "object")
                        throw TypeError(".ml_metadata.LineageGraph.attributions: object expected");
                    message.attributions[i] = $root.ml_metadata.Attribution.fromObject(object.attributions[i]);
                }
            }
            if (object.associations) {
                if (!Array.isArray(object.associations))
                    throw TypeError(".ml_metadata.LineageGraph.associations: array expected");
                message.associations = [];
                for (var i = 0; i < object.associations.length; ++i) {
                    if (typeof object.associations[i] !== "object")
                        throw TypeError(".ml_metadata.LineageGraph.associations: object expected");
                    message.associations[i] = $root.ml_metadata.Association.fromObject(object.associations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LineageGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.LineageGraph
         * @static
         * @param {ml_metadata.LineageGraph} message LineageGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LineageGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.artifactTypes = [];
                object.executionTypes = [];
                object.contextTypes = [];
                object.artifacts = [];
                object.executions = [];
                object.contexts = [];
                object.events = [];
                object.attributions = [];
                object.associations = [];
            }
            if (message.artifactTypes && message.artifactTypes.length) {
                object.artifactTypes = [];
                for (var j = 0; j < message.artifactTypes.length; ++j)
                    object.artifactTypes[j] = $root.ml_metadata.ArtifactType.toObject(message.artifactTypes[j], options);
            }
            if (message.executionTypes && message.executionTypes.length) {
                object.executionTypes = [];
                for (var j = 0; j < message.executionTypes.length; ++j)
                    object.executionTypes[j] = $root.ml_metadata.ExecutionType.toObject(message.executionTypes[j], options);
            }
            if (message.contextTypes && message.contextTypes.length) {
                object.contextTypes = [];
                for (var j = 0; j < message.contextTypes.length; ++j)
                    object.contextTypes[j] = $root.ml_metadata.ContextType.toObject(message.contextTypes[j], options);
            }
            if (message.artifacts && message.artifacts.length) {
                object.artifacts = [];
                for (var j = 0; j < message.artifacts.length; ++j)
                    object.artifacts[j] = $root.ml_metadata.Artifact.toObject(message.artifacts[j], options);
            }
            if (message.executions && message.executions.length) {
                object.executions = [];
                for (var j = 0; j < message.executions.length; ++j)
                    object.executions[j] = $root.ml_metadata.Execution.toObject(message.executions[j], options);
            }
            if (message.contexts && message.contexts.length) {
                object.contexts = [];
                for (var j = 0; j < message.contexts.length; ++j)
                    object.contexts[j] = $root.ml_metadata.Context.toObject(message.contexts[j], options);
            }
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.ml_metadata.Event.toObject(message.events[j], options);
            }
            if (message.attributions && message.attributions.length) {
                object.attributions = [];
                for (var j = 0; j < message.attributions.length; ++j)
                    object.attributions[j] = $root.ml_metadata.Attribution.toObject(message.attributions[j], options);
            }
            if (message.associations && message.associations.length) {
                object.associations = [];
                for (var j = 0; j < message.associations.length; ++j)
                    object.associations[j] = $root.ml_metadata.Association.toObject(message.associations[j], options);
            }
            return object;
        };

        /**
         * Converts this LineageGraph to JSON.
         * @function toJSON
         * @memberof ml_metadata.LineageGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LineageGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LineageGraph;
    })();

    ml_metadata.ArtifactStructType = (function() {

        /**
         * Properties of an ArtifactStructType.
         * @memberof ml_metadata
         * @interface IArtifactStructType
         * @property {ml_metadata.IArtifactType|null} [simple] ArtifactStructType simple
         * @property {ml_metadata.IUnionArtifactStructType|null} [unionType] ArtifactStructType unionType
         * @property {ml_metadata.IIntersectionArtifactStructType|null} [intersection] ArtifactStructType intersection
         * @property {ml_metadata.IListArtifactStructType|null} [list] ArtifactStructType list
         * @property {ml_metadata.INoneArtifactStructType|null} [none] ArtifactStructType none
         * @property {ml_metadata.IAnyArtifactStructType|null} [any] ArtifactStructType any
         * @property {ml_metadata.ITupleArtifactStructType|null} [tuple] ArtifactStructType tuple
         * @property {ml_metadata.IDictArtifactStructType|null} [dict] ArtifactStructType dict
         */

        /**
         * Constructs a new ArtifactStructType.
         * @memberof ml_metadata
         * @classdesc Represents an ArtifactStructType.
         * @implements IArtifactStructType
         * @constructor
         * @param {ml_metadata.IArtifactStructType=} [properties] Properties to set
         */
        function ArtifactStructType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtifactStructType simple.
         * @member {ml_metadata.IArtifactType|null|undefined} simple
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         */
        ArtifactStructType.prototype.simple = null;

        /**
         * ArtifactStructType unionType.
         * @member {ml_metadata.IUnionArtifactStructType|null|undefined} unionType
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         */
        ArtifactStructType.prototype.unionType = null;

        /**
         * ArtifactStructType intersection.
         * @member {ml_metadata.IIntersectionArtifactStructType|null|undefined} intersection
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         */
        ArtifactStructType.prototype.intersection = null;

        /**
         * ArtifactStructType list.
         * @member {ml_metadata.IListArtifactStructType|null|undefined} list
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         */
        ArtifactStructType.prototype.list = null;

        /**
         * ArtifactStructType none.
         * @member {ml_metadata.INoneArtifactStructType|null|undefined} none
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         */
        ArtifactStructType.prototype.none = null;

        /**
         * ArtifactStructType any.
         * @member {ml_metadata.IAnyArtifactStructType|null|undefined} any
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         */
        ArtifactStructType.prototype.any = null;

        /**
         * ArtifactStructType tuple.
         * @member {ml_metadata.ITupleArtifactStructType|null|undefined} tuple
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         */
        ArtifactStructType.prototype.tuple = null;

        /**
         * ArtifactStructType dict.
         * @member {ml_metadata.IDictArtifactStructType|null|undefined} dict
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         */
        ArtifactStructType.prototype.dict = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ArtifactStructType kind.
         * @member {"simple"|"unionType"|"intersection"|"list"|"none"|"any"|"tuple"|"dict"|undefined} kind
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         */
        Object.defineProperty(ArtifactStructType.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["simple", "unionType", "intersection", "list", "none", "any", "tuple", "dict"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ArtifactStructType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ArtifactStructType
         * @static
         * @param {ml_metadata.IArtifactStructType=} [properties] Properties to set
         * @returns {ml_metadata.ArtifactStructType} ArtifactStructType instance
         */
        ArtifactStructType.create = function create(properties) {
            return new ArtifactStructType(properties);
        };

        /**
         * Encodes the specified ArtifactStructType message. Does not implicitly {@link ml_metadata.ArtifactStructType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ArtifactStructType
         * @static
         * @param {ml_metadata.IArtifactStructType} message ArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactStructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.simple != null && Object.hasOwnProperty.call(message, "simple"))
                $root.ml_metadata.ArtifactType.encode(message.simple, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.unionType != null && Object.hasOwnProperty.call(message, "unionType"))
                $root.ml_metadata.UnionArtifactStructType.encode(message.unionType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.intersection != null && Object.hasOwnProperty.call(message, "intersection"))
                $root.ml_metadata.IntersectionArtifactStructType.encode(message.intersection, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.list != null && Object.hasOwnProperty.call(message, "list"))
                $root.ml_metadata.ListArtifactStructType.encode(message.list, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.none != null && Object.hasOwnProperty.call(message, "none"))
                $root.ml_metadata.NoneArtifactStructType.encode(message.none, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.any != null && Object.hasOwnProperty.call(message, "any"))
                $root.ml_metadata.AnyArtifactStructType.encode(message.any, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.tuple != null && Object.hasOwnProperty.call(message, "tuple"))
                $root.ml_metadata.TupleArtifactStructType.encode(message.tuple, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.dict != null && Object.hasOwnProperty.call(message, "dict"))
                $root.ml_metadata.DictArtifactStructType.encode(message.dict, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArtifactStructType message, length delimited. Does not implicitly {@link ml_metadata.ArtifactStructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ArtifactStructType
         * @static
         * @param {ml_metadata.IArtifactStructType} message ArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtifactStructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtifactStructType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ArtifactStructType} ArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactStructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ArtifactStructType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.simple = $root.ml_metadata.ArtifactType.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.unionType = $root.ml_metadata.UnionArtifactStructType.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.intersection = $root.ml_metadata.IntersectionArtifactStructType.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.list = $root.ml_metadata.ListArtifactStructType.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.none = $root.ml_metadata.NoneArtifactStructType.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.any = $root.ml_metadata.AnyArtifactStructType.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.tuple = $root.ml_metadata.TupleArtifactStructType.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.dict = $root.ml_metadata.DictArtifactStructType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtifactStructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ArtifactStructType} ArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtifactStructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtifactStructType message.
         * @function verify
         * @memberof ml_metadata.ArtifactStructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtifactStructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.simple != null && message.hasOwnProperty("simple")) {
                properties.kind = 1;
                {
                    var error = $root.ml_metadata.ArtifactType.verify(message.simple);
                    if (error)
                        return "simple." + error;
                }
            }
            if (message.unionType != null && message.hasOwnProperty("unionType")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.ml_metadata.UnionArtifactStructType.verify(message.unionType);
                    if (error)
                        return "unionType." + error;
                }
            }
            if (message.intersection != null && message.hasOwnProperty("intersection")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.ml_metadata.IntersectionArtifactStructType.verify(message.intersection);
                    if (error)
                        return "intersection." + error;
                }
            }
            if (message.list != null && message.hasOwnProperty("list")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.ml_metadata.ListArtifactStructType.verify(message.list);
                    if (error)
                        return "list." + error;
                }
            }
            if (message.none != null && message.hasOwnProperty("none")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.ml_metadata.NoneArtifactStructType.verify(message.none);
                    if (error)
                        return "none." + error;
                }
            }
            if (message.any != null && message.hasOwnProperty("any")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.ml_metadata.AnyArtifactStructType.verify(message.any);
                    if (error)
                        return "any." + error;
                }
            }
            if (message.tuple != null && message.hasOwnProperty("tuple")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.ml_metadata.TupleArtifactStructType.verify(message.tuple);
                    if (error)
                        return "tuple." + error;
                }
            }
            if (message.dict != null && message.hasOwnProperty("dict")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.ml_metadata.DictArtifactStructType.verify(message.dict);
                    if (error)
                        return "dict." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArtifactStructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ArtifactStructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ArtifactStructType} ArtifactStructType
         */
        ArtifactStructType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ArtifactStructType)
                return object;
            var message = new $root.ml_metadata.ArtifactStructType();
            if (object.simple != null) {
                if (typeof object.simple !== "object")
                    throw TypeError(".ml_metadata.ArtifactStructType.simple: object expected");
                message.simple = $root.ml_metadata.ArtifactType.fromObject(object.simple);
            }
            if (object.unionType != null) {
                if (typeof object.unionType !== "object")
                    throw TypeError(".ml_metadata.ArtifactStructType.unionType: object expected");
                message.unionType = $root.ml_metadata.UnionArtifactStructType.fromObject(object.unionType);
            }
            if (object.intersection != null) {
                if (typeof object.intersection !== "object")
                    throw TypeError(".ml_metadata.ArtifactStructType.intersection: object expected");
                message.intersection = $root.ml_metadata.IntersectionArtifactStructType.fromObject(object.intersection);
            }
            if (object.list != null) {
                if (typeof object.list !== "object")
                    throw TypeError(".ml_metadata.ArtifactStructType.list: object expected");
                message.list = $root.ml_metadata.ListArtifactStructType.fromObject(object.list);
            }
            if (object.none != null) {
                if (typeof object.none !== "object")
                    throw TypeError(".ml_metadata.ArtifactStructType.none: object expected");
                message.none = $root.ml_metadata.NoneArtifactStructType.fromObject(object.none);
            }
            if (object.any != null) {
                if (typeof object.any !== "object")
                    throw TypeError(".ml_metadata.ArtifactStructType.any: object expected");
                message.any = $root.ml_metadata.AnyArtifactStructType.fromObject(object.any);
            }
            if (object.tuple != null) {
                if (typeof object.tuple !== "object")
                    throw TypeError(".ml_metadata.ArtifactStructType.tuple: object expected");
                message.tuple = $root.ml_metadata.TupleArtifactStructType.fromObject(object.tuple);
            }
            if (object.dict != null) {
                if (typeof object.dict !== "object")
                    throw TypeError(".ml_metadata.ArtifactStructType.dict: object expected");
                message.dict = $root.ml_metadata.DictArtifactStructType.fromObject(object.dict);
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtifactStructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ArtifactStructType
         * @static
         * @param {ml_metadata.ArtifactStructType} message ArtifactStructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtifactStructType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.simple != null && message.hasOwnProperty("simple")) {
                object.simple = $root.ml_metadata.ArtifactType.toObject(message.simple, options);
                if (options.oneofs)
                    object.kind = "simple";
            }
            if (message.unionType != null && message.hasOwnProperty("unionType")) {
                object.unionType = $root.ml_metadata.UnionArtifactStructType.toObject(message.unionType, options);
                if (options.oneofs)
                    object.kind = "unionType";
            }
            if (message.intersection != null && message.hasOwnProperty("intersection")) {
                object.intersection = $root.ml_metadata.IntersectionArtifactStructType.toObject(message.intersection, options);
                if (options.oneofs)
                    object.kind = "intersection";
            }
            if (message.list != null && message.hasOwnProperty("list")) {
                object.list = $root.ml_metadata.ListArtifactStructType.toObject(message.list, options);
                if (options.oneofs)
                    object.kind = "list";
            }
            if (message.none != null && message.hasOwnProperty("none")) {
                object.none = $root.ml_metadata.NoneArtifactStructType.toObject(message.none, options);
                if (options.oneofs)
                    object.kind = "none";
            }
            if (message.any != null && message.hasOwnProperty("any")) {
                object.any = $root.ml_metadata.AnyArtifactStructType.toObject(message.any, options);
                if (options.oneofs)
                    object.kind = "any";
            }
            if (message.tuple != null && message.hasOwnProperty("tuple")) {
                object.tuple = $root.ml_metadata.TupleArtifactStructType.toObject(message.tuple, options);
                if (options.oneofs)
                    object.kind = "tuple";
            }
            if (message.dict != null && message.hasOwnProperty("dict")) {
                object.dict = $root.ml_metadata.DictArtifactStructType.toObject(message.dict, options);
                if (options.oneofs)
                    object.kind = "dict";
            }
            return object;
        };

        /**
         * Converts this ArtifactStructType to JSON.
         * @function toJSON
         * @memberof ml_metadata.ArtifactStructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtifactStructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtifactStructType;
    })();

    ml_metadata.UnionArtifactStructType = (function() {

        /**
         * Properties of an UnionArtifactStructType.
         * @memberof ml_metadata
         * @interface IUnionArtifactStructType
         * @property {Array.<ml_metadata.IArtifactStructType>|null} [candidates] UnionArtifactStructType candidates
         */

        /**
         * Constructs a new UnionArtifactStructType.
         * @memberof ml_metadata
         * @classdesc Represents an UnionArtifactStructType.
         * @implements IUnionArtifactStructType
         * @constructor
         * @param {ml_metadata.IUnionArtifactStructType=} [properties] Properties to set
         */
        function UnionArtifactStructType(properties) {
            this.candidates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnionArtifactStructType candidates.
         * @member {Array.<ml_metadata.IArtifactStructType>} candidates
         * @memberof ml_metadata.UnionArtifactStructType
         * @instance
         */
        UnionArtifactStructType.prototype.candidates = $util.emptyArray;

        /**
         * Creates a new UnionArtifactStructType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.UnionArtifactStructType
         * @static
         * @param {ml_metadata.IUnionArtifactStructType=} [properties] Properties to set
         * @returns {ml_metadata.UnionArtifactStructType} UnionArtifactStructType instance
         */
        UnionArtifactStructType.create = function create(properties) {
            return new UnionArtifactStructType(properties);
        };

        /**
         * Encodes the specified UnionArtifactStructType message. Does not implicitly {@link ml_metadata.UnionArtifactStructType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.UnionArtifactStructType
         * @static
         * @param {ml_metadata.IUnionArtifactStructType} message UnionArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnionArtifactStructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.candidates != null && message.candidates.length)
                for (var i = 0; i < message.candidates.length; ++i)
                    $root.ml_metadata.ArtifactStructType.encode(message.candidates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnionArtifactStructType message, length delimited. Does not implicitly {@link ml_metadata.UnionArtifactStructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.UnionArtifactStructType
         * @static
         * @param {ml_metadata.IUnionArtifactStructType} message UnionArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnionArtifactStructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnionArtifactStructType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.UnionArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.UnionArtifactStructType} UnionArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnionArtifactStructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.UnionArtifactStructType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.candidates && message.candidates.length))
                        message.candidates = [];
                    message.candidates.push($root.ml_metadata.ArtifactStructType.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnionArtifactStructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.UnionArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.UnionArtifactStructType} UnionArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnionArtifactStructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnionArtifactStructType message.
         * @function verify
         * @memberof ml_metadata.UnionArtifactStructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnionArtifactStructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.candidates != null && message.hasOwnProperty("candidates")) {
                if (!Array.isArray(message.candidates))
                    return "candidates: array expected";
                for (var i = 0; i < message.candidates.length; ++i) {
                    var error = $root.ml_metadata.ArtifactStructType.verify(message.candidates[i]);
                    if (error)
                        return "candidates." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UnionArtifactStructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.UnionArtifactStructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.UnionArtifactStructType} UnionArtifactStructType
         */
        UnionArtifactStructType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.UnionArtifactStructType)
                return object;
            var message = new $root.ml_metadata.UnionArtifactStructType();
            if (object.candidates) {
                if (!Array.isArray(object.candidates))
                    throw TypeError(".ml_metadata.UnionArtifactStructType.candidates: array expected");
                message.candidates = [];
                for (var i = 0; i < object.candidates.length; ++i) {
                    if (typeof object.candidates[i] !== "object")
                        throw TypeError(".ml_metadata.UnionArtifactStructType.candidates: object expected");
                    message.candidates[i] = $root.ml_metadata.ArtifactStructType.fromObject(object.candidates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UnionArtifactStructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.UnionArtifactStructType
         * @static
         * @param {ml_metadata.UnionArtifactStructType} message UnionArtifactStructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnionArtifactStructType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.candidates = [];
            if (message.candidates && message.candidates.length) {
                object.candidates = [];
                for (var j = 0; j < message.candidates.length; ++j)
                    object.candidates[j] = $root.ml_metadata.ArtifactStructType.toObject(message.candidates[j], options);
            }
            return object;
        };

        /**
         * Converts this UnionArtifactStructType to JSON.
         * @function toJSON
         * @memberof ml_metadata.UnionArtifactStructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnionArtifactStructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnionArtifactStructType;
    })();

    ml_metadata.IntersectionArtifactStructType = (function() {

        /**
         * Properties of an IntersectionArtifactStructType.
         * @memberof ml_metadata
         * @interface IIntersectionArtifactStructType
         * @property {Array.<ml_metadata.IArtifactStructType>|null} [constraints] IntersectionArtifactStructType constraints
         */

        /**
         * Constructs a new IntersectionArtifactStructType.
         * @memberof ml_metadata
         * @classdesc Represents an IntersectionArtifactStructType.
         * @implements IIntersectionArtifactStructType
         * @constructor
         * @param {ml_metadata.IIntersectionArtifactStructType=} [properties] Properties to set
         */
        function IntersectionArtifactStructType(properties) {
            this.constraints = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IntersectionArtifactStructType constraints.
         * @member {Array.<ml_metadata.IArtifactStructType>} constraints
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @instance
         */
        IntersectionArtifactStructType.prototype.constraints = $util.emptyArray;

        /**
         * Creates a new IntersectionArtifactStructType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @static
         * @param {ml_metadata.IIntersectionArtifactStructType=} [properties] Properties to set
         * @returns {ml_metadata.IntersectionArtifactStructType} IntersectionArtifactStructType instance
         */
        IntersectionArtifactStructType.create = function create(properties) {
            return new IntersectionArtifactStructType(properties);
        };

        /**
         * Encodes the specified IntersectionArtifactStructType message. Does not implicitly {@link ml_metadata.IntersectionArtifactStructType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @static
         * @param {ml_metadata.IIntersectionArtifactStructType} message IntersectionArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntersectionArtifactStructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.constraints != null && message.constraints.length)
                for (var i = 0; i < message.constraints.length; ++i)
                    $root.ml_metadata.ArtifactStructType.encode(message.constraints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IntersectionArtifactStructType message, length delimited. Does not implicitly {@link ml_metadata.IntersectionArtifactStructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @static
         * @param {ml_metadata.IIntersectionArtifactStructType} message IntersectionArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntersectionArtifactStructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IntersectionArtifactStructType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.IntersectionArtifactStructType} IntersectionArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntersectionArtifactStructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.IntersectionArtifactStructType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.constraints && message.constraints.length))
                        message.constraints = [];
                    message.constraints.push($root.ml_metadata.ArtifactStructType.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IntersectionArtifactStructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.IntersectionArtifactStructType} IntersectionArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntersectionArtifactStructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IntersectionArtifactStructType message.
         * @function verify
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IntersectionArtifactStructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.constraints != null && message.hasOwnProperty("constraints")) {
                if (!Array.isArray(message.constraints))
                    return "constraints: array expected";
                for (var i = 0; i < message.constraints.length; ++i) {
                    var error = $root.ml_metadata.ArtifactStructType.verify(message.constraints[i]);
                    if (error)
                        return "constraints." + error;
                }
            }
            return null;
        };

        /**
         * Creates an IntersectionArtifactStructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.IntersectionArtifactStructType} IntersectionArtifactStructType
         */
        IntersectionArtifactStructType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.IntersectionArtifactStructType)
                return object;
            var message = new $root.ml_metadata.IntersectionArtifactStructType();
            if (object.constraints) {
                if (!Array.isArray(object.constraints))
                    throw TypeError(".ml_metadata.IntersectionArtifactStructType.constraints: array expected");
                message.constraints = [];
                for (var i = 0; i < object.constraints.length; ++i) {
                    if (typeof object.constraints[i] !== "object")
                        throw TypeError(".ml_metadata.IntersectionArtifactStructType.constraints: object expected");
                    message.constraints[i] = $root.ml_metadata.ArtifactStructType.fromObject(object.constraints[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an IntersectionArtifactStructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @static
         * @param {ml_metadata.IntersectionArtifactStructType} message IntersectionArtifactStructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IntersectionArtifactStructType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.constraints = [];
            if (message.constraints && message.constraints.length) {
                object.constraints = [];
                for (var j = 0; j < message.constraints.length; ++j)
                    object.constraints[j] = $root.ml_metadata.ArtifactStructType.toObject(message.constraints[j], options);
            }
            return object;
        };

        /**
         * Converts this IntersectionArtifactStructType to JSON.
         * @function toJSON
         * @memberof ml_metadata.IntersectionArtifactStructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IntersectionArtifactStructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IntersectionArtifactStructType;
    })();

    ml_metadata.ListArtifactStructType = (function() {

        /**
         * Properties of a ListArtifactStructType.
         * @memberof ml_metadata
         * @interface IListArtifactStructType
         * @property {ml_metadata.IArtifactStructType|null} [element] ListArtifactStructType element
         */

        /**
         * Constructs a new ListArtifactStructType.
         * @memberof ml_metadata
         * @classdesc Represents a ListArtifactStructType.
         * @implements IListArtifactStructType
         * @constructor
         * @param {ml_metadata.IListArtifactStructType=} [properties] Properties to set
         */
        function ListArtifactStructType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListArtifactStructType element.
         * @member {ml_metadata.IArtifactStructType|null|undefined} element
         * @memberof ml_metadata.ListArtifactStructType
         * @instance
         */
        ListArtifactStructType.prototype.element = null;

        /**
         * Creates a new ListArtifactStructType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ListArtifactStructType
         * @static
         * @param {ml_metadata.IListArtifactStructType=} [properties] Properties to set
         * @returns {ml_metadata.ListArtifactStructType} ListArtifactStructType instance
         */
        ListArtifactStructType.create = function create(properties) {
            return new ListArtifactStructType(properties);
        };

        /**
         * Encodes the specified ListArtifactStructType message. Does not implicitly {@link ml_metadata.ListArtifactStructType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ListArtifactStructType
         * @static
         * @param {ml_metadata.IListArtifactStructType} message ListArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListArtifactStructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.element != null && Object.hasOwnProperty.call(message, "element"))
                $root.ml_metadata.ArtifactStructType.encode(message.element, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListArtifactStructType message, length delimited. Does not implicitly {@link ml_metadata.ListArtifactStructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ListArtifactStructType
         * @static
         * @param {ml_metadata.IListArtifactStructType} message ListArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListArtifactStructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListArtifactStructType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ListArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ListArtifactStructType} ListArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListArtifactStructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ListArtifactStructType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.element = $root.ml_metadata.ArtifactStructType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListArtifactStructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ListArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ListArtifactStructType} ListArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListArtifactStructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListArtifactStructType message.
         * @function verify
         * @memberof ml_metadata.ListArtifactStructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListArtifactStructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.element != null && message.hasOwnProperty("element")) {
                var error = $root.ml_metadata.ArtifactStructType.verify(message.element);
                if (error)
                    return "element." + error;
            }
            return null;
        };

        /**
         * Creates a ListArtifactStructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ListArtifactStructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ListArtifactStructType} ListArtifactStructType
         */
        ListArtifactStructType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ListArtifactStructType)
                return object;
            var message = new $root.ml_metadata.ListArtifactStructType();
            if (object.element != null) {
                if (typeof object.element !== "object")
                    throw TypeError(".ml_metadata.ListArtifactStructType.element: object expected");
                message.element = $root.ml_metadata.ArtifactStructType.fromObject(object.element);
            }
            return message;
        };

        /**
         * Creates a plain object from a ListArtifactStructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ListArtifactStructType
         * @static
         * @param {ml_metadata.ListArtifactStructType} message ListArtifactStructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListArtifactStructType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.element = null;
            if (message.element != null && message.hasOwnProperty("element"))
                object.element = $root.ml_metadata.ArtifactStructType.toObject(message.element, options);
            return object;
        };

        /**
         * Converts this ListArtifactStructType to JSON.
         * @function toJSON
         * @memberof ml_metadata.ListArtifactStructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListArtifactStructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListArtifactStructType;
    })();

    ml_metadata.NoneArtifactStructType = (function() {

        /**
         * Properties of a NoneArtifactStructType.
         * @memberof ml_metadata
         * @interface INoneArtifactStructType
         */

        /**
         * Constructs a new NoneArtifactStructType.
         * @memberof ml_metadata
         * @classdesc Represents a NoneArtifactStructType.
         * @implements INoneArtifactStructType
         * @constructor
         * @param {ml_metadata.INoneArtifactStructType=} [properties] Properties to set
         */
        function NoneArtifactStructType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NoneArtifactStructType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.NoneArtifactStructType
         * @static
         * @param {ml_metadata.INoneArtifactStructType=} [properties] Properties to set
         * @returns {ml_metadata.NoneArtifactStructType} NoneArtifactStructType instance
         */
        NoneArtifactStructType.create = function create(properties) {
            return new NoneArtifactStructType(properties);
        };

        /**
         * Encodes the specified NoneArtifactStructType message. Does not implicitly {@link ml_metadata.NoneArtifactStructType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.NoneArtifactStructType
         * @static
         * @param {ml_metadata.INoneArtifactStructType} message NoneArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoneArtifactStructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NoneArtifactStructType message, length delimited. Does not implicitly {@link ml_metadata.NoneArtifactStructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.NoneArtifactStructType
         * @static
         * @param {ml_metadata.INoneArtifactStructType} message NoneArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoneArtifactStructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoneArtifactStructType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.NoneArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.NoneArtifactStructType} NoneArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoneArtifactStructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.NoneArtifactStructType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoneArtifactStructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.NoneArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.NoneArtifactStructType} NoneArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoneArtifactStructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoneArtifactStructType message.
         * @function verify
         * @memberof ml_metadata.NoneArtifactStructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoneArtifactStructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a NoneArtifactStructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.NoneArtifactStructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.NoneArtifactStructType} NoneArtifactStructType
         */
        NoneArtifactStructType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.NoneArtifactStructType)
                return object;
            return new $root.ml_metadata.NoneArtifactStructType();
        };

        /**
         * Creates a plain object from a NoneArtifactStructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.NoneArtifactStructType
         * @static
         * @param {ml_metadata.NoneArtifactStructType} message NoneArtifactStructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoneArtifactStructType.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this NoneArtifactStructType to JSON.
         * @function toJSON
         * @memberof ml_metadata.NoneArtifactStructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoneArtifactStructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NoneArtifactStructType;
    })();

    ml_metadata.AnyArtifactStructType = (function() {

        /**
         * Properties of an AnyArtifactStructType.
         * @memberof ml_metadata
         * @interface IAnyArtifactStructType
         */

        /**
         * Constructs a new AnyArtifactStructType.
         * @memberof ml_metadata
         * @classdesc Represents an AnyArtifactStructType.
         * @implements IAnyArtifactStructType
         * @constructor
         * @param {ml_metadata.IAnyArtifactStructType=} [properties] Properties to set
         */
        function AnyArtifactStructType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AnyArtifactStructType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.AnyArtifactStructType
         * @static
         * @param {ml_metadata.IAnyArtifactStructType=} [properties] Properties to set
         * @returns {ml_metadata.AnyArtifactStructType} AnyArtifactStructType instance
         */
        AnyArtifactStructType.create = function create(properties) {
            return new AnyArtifactStructType(properties);
        };

        /**
         * Encodes the specified AnyArtifactStructType message. Does not implicitly {@link ml_metadata.AnyArtifactStructType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.AnyArtifactStructType
         * @static
         * @param {ml_metadata.IAnyArtifactStructType} message AnyArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnyArtifactStructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AnyArtifactStructType message, length delimited. Does not implicitly {@link ml_metadata.AnyArtifactStructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.AnyArtifactStructType
         * @static
         * @param {ml_metadata.IAnyArtifactStructType} message AnyArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnyArtifactStructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AnyArtifactStructType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.AnyArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.AnyArtifactStructType} AnyArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnyArtifactStructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.AnyArtifactStructType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AnyArtifactStructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.AnyArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.AnyArtifactStructType} AnyArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnyArtifactStructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AnyArtifactStructType message.
         * @function verify
         * @memberof ml_metadata.AnyArtifactStructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnyArtifactStructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an AnyArtifactStructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.AnyArtifactStructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.AnyArtifactStructType} AnyArtifactStructType
         */
        AnyArtifactStructType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.AnyArtifactStructType)
                return object;
            return new $root.ml_metadata.AnyArtifactStructType();
        };

        /**
         * Creates a plain object from an AnyArtifactStructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.AnyArtifactStructType
         * @static
         * @param {ml_metadata.AnyArtifactStructType} message AnyArtifactStructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnyArtifactStructType.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AnyArtifactStructType to JSON.
         * @function toJSON
         * @memberof ml_metadata.AnyArtifactStructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnyArtifactStructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnyArtifactStructType;
    })();

    ml_metadata.TupleArtifactStructType = (function() {

        /**
         * Properties of a TupleArtifactStructType.
         * @memberof ml_metadata
         * @interface ITupleArtifactStructType
         * @property {Array.<ml_metadata.IArtifactStructType>|null} [elements] TupleArtifactStructType elements
         */

        /**
         * Constructs a new TupleArtifactStructType.
         * @memberof ml_metadata
         * @classdesc Represents a TupleArtifactStructType.
         * @implements ITupleArtifactStructType
         * @constructor
         * @param {ml_metadata.ITupleArtifactStructType=} [properties] Properties to set
         */
        function TupleArtifactStructType(properties) {
            this.elements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TupleArtifactStructType elements.
         * @member {Array.<ml_metadata.IArtifactStructType>} elements
         * @memberof ml_metadata.TupleArtifactStructType
         * @instance
         */
        TupleArtifactStructType.prototype.elements = $util.emptyArray;

        /**
         * Creates a new TupleArtifactStructType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.TupleArtifactStructType
         * @static
         * @param {ml_metadata.ITupleArtifactStructType=} [properties] Properties to set
         * @returns {ml_metadata.TupleArtifactStructType} TupleArtifactStructType instance
         */
        TupleArtifactStructType.create = function create(properties) {
            return new TupleArtifactStructType(properties);
        };

        /**
         * Encodes the specified TupleArtifactStructType message. Does not implicitly {@link ml_metadata.TupleArtifactStructType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.TupleArtifactStructType
         * @static
         * @param {ml_metadata.ITupleArtifactStructType} message TupleArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TupleArtifactStructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elements != null && message.elements.length)
                for (var i = 0; i < message.elements.length; ++i)
                    $root.ml_metadata.ArtifactStructType.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TupleArtifactStructType message, length delimited. Does not implicitly {@link ml_metadata.TupleArtifactStructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.TupleArtifactStructType
         * @static
         * @param {ml_metadata.ITupleArtifactStructType} message TupleArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TupleArtifactStructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TupleArtifactStructType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.TupleArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.TupleArtifactStructType} TupleArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TupleArtifactStructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.TupleArtifactStructType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.elements && message.elements.length))
                        message.elements = [];
                    message.elements.push($root.ml_metadata.ArtifactStructType.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TupleArtifactStructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.TupleArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.TupleArtifactStructType} TupleArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TupleArtifactStructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TupleArtifactStructType message.
         * @function verify
         * @memberof ml_metadata.TupleArtifactStructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TupleArtifactStructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elements != null && message.hasOwnProperty("elements")) {
                if (!Array.isArray(message.elements))
                    return "elements: array expected";
                for (var i = 0; i < message.elements.length; ++i) {
                    var error = $root.ml_metadata.ArtifactStructType.verify(message.elements[i]);
                    if (error)
                        return "elements." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TupleArtifactStructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.TupleArtifactStructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.TupleArtifactStructType} TupleArtifactStructType
         */
        TupleArtifactStructType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.TupleArtifactStructType)
                return object;
            var message = new $root.ml_metadata.TupleArtifactStructType();
            if (object.elements) {
                if (!Array.isArray(object.elements))
                    throw TypeError(".ml_metadata.TupleArtifactStructType.elements: array expected");
                message.elements = [];
                for (var i = 0; i < object.elements.length; ++i) {
                    if (typeof object.elements[i] !== "object")
                        throw TypeError(".ml_metadata.TupleArtifactStructType.elements: object expected");
                    message.elements[i] = $root.ml_metadata.ArtifactStructType.fromObject(object.elements[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TupleArtifactStructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.TupleArtifactStructType
         * @static
         * @param {ml_metadata.TupleArtifactStructType} message TupleArtifactStructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TupleArtifactStructType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.elements = [];
            if (message.elements && message.elements.length) {
                object.elements = [];
                for (var j = 0; j < message.elements.length; ++j)
                    object.elements[j] = $root.ml_metadata.ArtifactStructType.toObject(message.elements[j], options);
            }
            return object;
        };

        /**
         * Converts this TupleArtifactStructType to JSON.
         * @function toJSON
         * @memberof ml_metadata.TupleArtifactStructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TupleArtifactStructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TupleArtifactStructType;
    })();

    ml_metadata.DictArtifactStructType = (function() {

        /**
         * Properties of a DictArtifactStructType.
         * @memberof ml_metadata
         * @interface IDictArtifactStructType
         * @property {Object.<string,ml_metadata.IArtifactStructType>|null} [properties] DictArtifactStructType properties
         * @property {boolean|null} [noneTypeNotRequired] DictArtifactStructType noneTypeNotRequired
         * @property {ml_metadata.IArtifactStructType|null} [extraPropertiesType] DictArtifactStructType extraPropertiesType
         */

        /**
         * Constructs a new DictArtifactStructType.
         * @memberof ml_metadata
         * @classdesc Represents a DictArtifactStructType.
         * @implements IDictArtifactStructType
         * @constructor
         * @param {ml_metadata.IDictArtifactStructType=} [properties] Properties to set
         */
        function DictArtifactStructType(properties) {
            this.properties = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DictArtifactStructType properties.
         * @member {Object.<string,ml_metadata.IArtifactStructType>} properties
         * @memberof ml_metadata.DictArtifactStructType
         * @instance
         */
        DictArtifactStructType.prototype.properties = $util.emptyObject;

        /**
         * DictArtifactStructType noneTypeNotRequired.
         * @member {boolean} noneTypeNotRequired
         * @memberof ml_metadata.DictArtifactStructType
         * @instance
         */
        DictArtifactStructType.prototype.noneTypeNotRequired = false;

        /**
         * DictArtifactStructType extraPropertiesType.
         * @member {ml_metadata.IArtifactStructType|null|undefined} extraPropertiesType
         * @memberof ml_metadata.DictArtifactStructType
         * @instance
         */
        DictArtifactStructType.prototype.extraPropertiesType = null;

        /**
         * Creates a new DictArtifactStructType instance using the specified properties.
         * @function create
         * @memberof ml_metadata.DictArtifactStructType
         * @static
         * @param {ml_metadata.IDictArtifactStructType=} [properties] Properties to set
         * @returns {ml_metadata.DictArtifactStructType} DictArtifactStructType instance
         */
        DictArtifactStructType.create = function create(properties) {
            return new DictArtifactStructType(properties);
        };

        /**
         * Encodes the specified DictArtifactStructType message. Does not implicitly {@link ml_metadata.DictArtifactStructType.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.DictArtifactStructType
         * @static
         * @param {ml_metadata.IDictArtifactStructType} message DictArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DictArtifactStructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.ml_metadata.ArtifactStructType.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.noneTypeNotRequired != null && Object.hasOwnProperty.call(message, "noneTypeNotRequired"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noneTypeNotRequired);
            if (message.extraPropertiesType != null && Object.hasOwnProperty.call(message, "extraPropertiesType"))
                $root.ml_metadata.ArtifactStructType.encode(message.extraPropertiesType, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DictArtifactStructType message, length delimited. Does not implicitly {@link ml_metadata.DictArtifactStructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.DictArtifactStructType
         * @static
         * @param {ml_metadata.IDictArtifactStructType} message DictArtifactStructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DictArtifactStructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DictArtifactStructType message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.DictArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.DictArtifactStructType} DictArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DictArtifactStructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.DictArtifactStructType(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.properties === $util.emptyObject)
                        message.properties = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.ml_metadata.ArtifactStructType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.properties[key] = value;
                    break;
                case 2:
                    message.noneTypeNotRequired = reader.bool();
                    break;
                case 3:
                    message.extraPropertiesType = $root.ml_metadata.ArtifactStructType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DictArtifactStructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.DictArtifactStructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.DictArtifactStructType} DictArtifactStructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DictArtifactStructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DictArtifactStructType message.
         * @function verify
         * @memberof ml_metadata.DictArtifactStructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DictArtifactStructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!$util.isObject(message.properties))
                    return "properties: object expected";
                var key = Object.keys(message.properties);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.ml_metadata.ArtifactStructType.verify(message.properties[key[i]]);
                    if (error)
                        return "properties." + error;
                }
            }
            if (message.noneTypeNotRequired != null && message.hasOwnProperty("noneTypeNotRequired"))
                if (typeof message.noneTypeNotRequired !== "boolean")
                    return "noneTypeNotRequired: boolean expected";
            if (message.extraPropertiesType != null && message.hasOwnProperty("extraPropertiesType")) {
                var error = $root.ml_metadata.ArtifactStructType.verify(message.extraPropertiesType);
                if (error)
                    return "extraPropertiesType." + error;
            }
            return null;
        };

        /**
         * Creates a DictArtifactStructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.DictArtifactStructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.DictArtifactStructType} DictArtifactStructType
         */
        DictArtifactStructType.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.DictArtifactStructType)
                return object;
            var message = new $root.ml_metadata.DictArtifactStructType();
            if (object.properties) {
                if (typeof object.properties !== "object")
                    throw TypeError(".ml_metadata.DictArtifactStructType.properties: object expected");
                message.properties = {};
                for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                    if (typeof object.properties[keys[i]] !== "object")
                        throw TypeError(".ml_metadata.DictArtifactStructType.properties: object expected");
                    message.properties[keys[i]] = $root.ml_metadata.ArtifactStructType.fromObject(object.properties[keys[i]]);
                }
            }
            if (object.noneTypeNotRequired != null)
                message.noneTypeNotRequired = Boolean(object.noneTypeNotRequired);
            if (object.extraPropertiesType != null) {
                if (typeof object.extraPropertiesType !== "object")
                    throw TypeError(".ml_metadata.DictArtifactStructType.extraPropertiesType: object expected");
                message.extraPropertiesType = $root.ml_metadata.ArtifactStructType.fromObject(object.extraPropertiesType);
            }
            return message;
        };

        /**
         * Creates a plain object from a DictArtifactStructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.DictArtifactStructType
         * @static
         * @param {ml_metadata.DictArtifactStructType} message DictArtifactStructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DictArtifactStructType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.properties = {};
            if (options.defaults) {
                object.noneTypeNotRequired = false;
                object.extraPropertiesType = null;
            }
            var keys2;
            if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                object.properties = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.properties[keys2[j]] = $root.ml_metadata.ArtifactStructType.toObject(message.properties[keys2[j]], options);
            }
            if (message.noneTypeNotRequired != null && message.hasOwnProperty("noneTypeNotRequired"))
                object.noneTypeNotRequired = message.noneTypeNotRequired;
            if (message.extraPropertiesType != null && message.hasOwnProperty("extraPropertiesType"))
                object.extraPropertiesType = $root.ml_metadata.ArtifactStructType.toObject(message.extraPropertiesType, options);
            return object;
        };

        /**
         * Converts this DictArtifactStructType to JSON.
         * @function toJSON
         * @memberof ml_metadata.DictArtifactStructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DictArtifactStructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DictArtifactStructType;
    })();

    ml_metadata.FakeDatabaseConfig = (function() {

        /**
         * Properties of a FakeDatabaseConfig.
         * @memberof ml_metadata
         * @interface IFakeDatabaseConfig
         */

        /**
         * Constructs a new FakeDatabaseConfig.
         * @memberof ml_metadata
         * @classdesc Represents a FakeDatabaseConfig.
         * @implements IFakeDatabaseConfig
         * @constructor
         * @param {ml_metadata.IFakeDatabaseConfig=} [properties] Properties to set
         */
        function FakeDatabaseConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FakeDatabaseConfig instance using the specified properties.
         * @function create
         * @memberof ml_metadata.FakeDatabaseConfig
         * @static
         * @param {ml_metadata.IFakeDatabaseConfig=} [properties] Properties to set
         * @returns {ml_metadata.FakeDatabaseConfig} FakeDatabaseConfig instance
         */
        FakeDatabaseConfig.create = function create(properties) {
            return new FakeDatabaseConfig(properties);
        };

        /**
         * Encodes the specified FakeDatabaseConfig message. Does not implicitly {@link ml_metadata.FakeDatabaseConfig.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.FakeDatabaseConfig
         * @static
         * @param {ml_metadata.IFakeDatabaseConfig} message FakeDatabaseConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FakeDatabaseConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FakeDatabaseConfig message, length delimited. Does not implicitly {@link ml_metadata.FakeDatabaseConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.FakeDatabaseConfig
         * @static
         * @param {ml_metadata.IFakeDatabaseConfig} message FakeDatabaseConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FakeDatabaseConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FakeDatabaseConfig message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.FakeDatabaseConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.FakeDatabaseConfig} FakeDatabaseConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FakeDatabaseConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.FakeDatabaseConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FakeDatabaseConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.FakeDatabaseConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.FakeDatabaseConfig} FakeDatabaseConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FakeDatabaseConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FakeDatabaseConfig message.
         * @function verify
         * @memberof ml_metadata.FakeDatabaseConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FakeDatabaseConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a FakeDatabaseConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.FakeDatabaseConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.FakeDatabaseConfig} FakeDatabaseConfig
         */
        FakeDatabaseConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.FakeDatabaseConfig)
                return object;
            return new $root.ml_metadata.FakeDatabaseConfig();
        };

        /**
         * Creates a plain object from a FakeDatabaseConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.FakeDatabaseConfig
         * @static
         * @param {ml_metadata.FakeDatabaseConfig} message FakeDatabaseConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FakeDatabaseConfig.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FakeDatabaseConfig to JSON.
         * @function toJSON
         * @memberof ml_metadata.FakeDatabaseConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FakeDatabaseConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FakeDatabaseConfig;
    })();

    ml_metadata.MySQLDatabaseConfig = (function() {

        /**
         * Properties of a MySQLDatabaseConfig.
         * @memberof ml_metadata
         * @interface IMySQLDatabaseConfig
         * @property {string|null} [host] MySQLDatabaseConfig host
         * @property {number|null} [port] MySQLDatabaseConfig port
         * @property {string|null} [database] MySQLDatabaseConfig database
         * @property {string|null} [user] MySQLDatabaseConfig user
         * @property {string|null} [password] MySQLDatabaseConfig password
         * @property {string|null} [socket] MySQLDatabaseConfig socket
         * @property {ml_metadata.MySQLDatabaseConfig.ISSLOptions|null} [sslOptions] MySQLDatabaseConfig sslOptions
         * @property {boolean|null} [skipDbCreation] MySQLDatabaseConfig skipDbCreation
         */

        /**
         * Constructs a new MySQLDatabaseConfig.
         * @memberof ml_metadata
         * @classdesc Represents a MySQLDatabaseConfig.
         * @implements IMySQLDatabaseConfig
         * @constructor
         * @param {ml_metadata.IMySQLDatabaseConfig=} [properties] Properties to set
         */
        function MySQLDatabaseConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MySQLDatabaseConfig host.
         * @member {string} host
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @instance
         */
        MySQLDatabaseConfig.prototype.host = "";

        /**
         * MySQLDatabaseConfig port.
         * @member {number} port
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @instance
         */
        MySQLDatabaseConfig.prototype.port = 0;

        /**
         * MySQLDatabaseConfig database.
         * @member {string} database
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @instance
         */
        MySQLDatabaseConfig.prototype.database = "";

        /**
         * MySQLDatabaseConfig user.
         * @member {string} user
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @instance
         */
        MySQLDatabaseConfig.prototype.user = "";

        /**
         * MySQLDatabaseConfig password.
         * @member {string} password
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @instance
         */
        MySQLDatabaseConfig.prototype.password = "";

        /**
         * MySQLDatabaseConfig socket.
         * @member {string} socket
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @instance
         */
        MySQLDatabaseConfig.prototype.socket = "";

        /**
         * MySQLDatabaseConfig sslOptions.
         * @member {ml_metadata.MySQLDatabaseConfig.ISSLOptions|null|undefined} sslOptions
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @instance
         */
        MySQLDatabaseConfig.prototype.sslOptions = null;

        /**
         * MySQLDatabaseConfig skipDbCreation.
         * @member {boolean} skipDbCreation
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @instance
         */
        MySQLDatabaseConfig.prototype.skipDbCreation = false;

        /**
         * Creates a new MySQLDatabaseConfig instance using the specified properties.
         * @function create
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @static
         * @param {ml_metadata.IMySQLDatabaseConfig=} [properties] Properties to set
         * @returns {ml_metadata.MySQLDatabaseConfig} MySQLDatabaseConfig instance
         */
        MySQLDatabaseConfig.create = function create(properties) {
            return new MySQLDatabaseConfig(properties);
        };

        /**
         * Encodes the specified MySQLDatabaseConfig message. Does not implicitly {@link ml_metadata.MySQLDatabaseConfig.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @static
         * @param {ml_metadata.IMySQLDatabaseConfig} message MySQLDatabaseConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MySQLDatabaseConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.database);
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.user);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
            if (message.socket != null && Object.hasOwnProperty.call(message, "socket"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.socket);
            if (message.sslOptions != null && Object.hasOwnProperty.call(message, "sslOptions"))
                $root.ml_metadata.MySQLDatabaseConfig.SSLOptions.encode(message.sslOptions, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.skipDbCreation != null && Object.hasOwnProperty.call(message, "skipDbCreation"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.skipDbCreation);
            return writer;
        };

        /**
         * Encodes the specified MySQLDatabaseConfig message, length delimited. Does not implicitly {@link ml_metadata.MySQLDatabaseConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @static
         * @param {ml_metadata.IMySQLDatabaseConfig} message MySQLDatabaseConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MySQLDatabaseConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MySQLDatabaseConfig message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.MySQLDatabaseConfig} MySQLDatabaseConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MySQLDatabaseConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.MySQLDatabaseConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.port = reader.uint32();
                    break;
                case 3:
                    message.database = reader.string();
                    break;
                case 4:
                    message.user = reader.string();
                    break;
                case 5:
                    message.password = reader.string();
                    break;
                case 6:
                    message.socket = reader.string();
                    break;
                case 7:
                    message.sslOptions = $root.ml_metadata.MySQLDatabaseConfig.SSLOptions.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.skipDbCreation = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MySQLDatabaseConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.MySQLDatabaseConfig} MySQLDatabaseConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MySQLDatabaseConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MySQLDatabaseConfig message.
         * @function verify
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MySQLDatabaseConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.database != null && message.hasOwnProperty("database"))
                if (!$util.isString(message.database))
                    return "database: string expected";
            if (message.user != null && message.hasOwnProperty("user"))
                if (!$util.isString(message.user))
                    return "user: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.socket != null && message.hasOwnProperty("socket"))
                if (!$util.isString(message.socket))
                    return "socket: string expected";
            if (message.sslOptions != null && message.hasOwnProperty("sslOptions")) {
                var error = $root.ml_metadata.MySQLDatabaseConfig.SSLOptions.verify(message.sslOptions);
                if (error)
                    return "sslOptions." + error;
            }
            if (message.skipDbCreation != null && message.hasOwnProperty("skipDbCreation"))
                if (typeof message.skipDbCreation !== "boolean")
                    return "skipDbCreation: boolean expected";
            return null;
        };

        /**
         * Creates a MySQLDatabaseConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.MySQLDatabaseConfig} MySQLDatabaseConfig
         */
        MySQLDatabaseConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.MySQLDatabaseConfig)
                return object;
            var message = new $root.ml_metadata.MySQLDatabaseConfig();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.database != null)
                message.database = String(object.database);
            if (object.user != null)
                message.user = String(object.user);
            if (object.password != null)
                message.password = String(object.password);
            if (object.socket != null)
                message.socket = String(object.socket);
            if (object.sslOptions != null) {
                if (typeof object.sslOptions !== "object")
                    throw TypeError(".ml_metadata.MySQLDatabaseConfig.sslOptions: object expected");
                message.sslOptions = $root.ml_metadata.MySQLDatabaseConfig.SSLOptions.fromObject(object.sslOptions);
            }
            if (object.skipDbCreation != null)
                message.skipDbCreation = Boolean(object.skipDbCreation);
            return message;
        };

        /**
         * Creates a plain object from a MySQLDatabaseConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @static
         * @param {ml_metadata.MySQLDatabaseConfig} message MySQLDatabaseConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MySQLDatabaseConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.database = "";
                object.user = "";
                object.password = "";
                object.socket = "";
                object.sslOptions = null;
                object.skipDbCreation = false;
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.database != null && message.hasOwnProperty("database"))
                object.database = message.database;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.socket != null && message.hasOwnProperty("socket"))
                object.socket = message.socket;
            if (message.sslOptions != null && message.hasOwnProperty("sslOptions"))
                object.sslOptions = $root.ml_metadata.MySQLDatabaseConfig.SSLOptions.toObject(message.sslOptions, options);
            if (message.skipDbCreation != null && message.hasOwnProperty("skipDbCreation"))
                object.skipDbCreation = message.skipDbCreation;
            return object;
        };

        /**
         * Converts this MySQLDatabaseConfig to JSON.
         * @function toJSON
         * @memberof ml_metadata.MySQLDatabaseConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MySQLDatabaseConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        MySQLDatabaseConfig.SSLOptions = (function() {

            /**
             * Properties of a SSLOptions.
             * @memberof ml_metadata.MySQLDatabaseConfig
             * @interface ISSLOptions
             * @property {string|null} [key] SSLOptions key
             * @property {string|null} [cert] SSLOptions cert
             * @property {string|null} [ca] SSLOptions ca
             * @property {string|null} [capath] SSLOptions capath
             * @property {string|null} [cipher] SSLOptions cipher
             * @property {boolean|null} [verifyServerCert] SSLOptions verifyServerCert
             */

            /**
             * Constructs a new SSLOptions.
             * @memberof ml_metadata.MySQLDatabaseConfig
             * @classdesc Represents a SSLOptions.
             * @implements ISSLOptions
             * @constructor
             * @param {ml_metadata.MySQLDatabaseConfig.ISSLOptions=} [properties] Properties to set
             */
            function SSLOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SSLOptions key.
             * @member {string} key
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @instance
             */
            SSLOptions.prototype.key = "";

            /**
             * SSLOptions cert.
             * @member {string} cert
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @instance
             */
            SSLOptions.prototype.cert = "";

            /**
             * SSLOptions ca.
             * @member {string} ca
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @instance
             */
            SSLOptions.prototype.ca = "";

            /**
             * SSLOptions capath.
             * @member {string} capath
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @instance
             */
            SSLOptions.prototype.capath = "";

            /**
             * SSLOptions cipher.
             * @member {string} cipher
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @instance
             */
            SSLOptions.prototype.cipher = "";

            /**
             * SSLOptions verifyServerCert.
             * @member {boolean} verifyServerCert
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @instance
             */
            SSLOptions.prototype.verifyServerCert = false;

            /**
             * Creates a new SSLOptions instance using the specified properties.
             * @function create
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @static
             * @param {ml_metadata.MySQLDatabaseConfig.ISSLOptions=} [properties] Properties to set
             * @returns {ml_metadata.MySQLDatabaseConfig.SSLOptions} SSLOptions instance
             */
            SSLOptions.create = function create(properties) {
                return new SSLOptions(properties);
            };

            /**
             * Encodes the specified SSLOptions message. Does not implicitly {@link ml_metadata.MySQLDatabaseConfig.SSLOptions.verify|verify} messages.
             * @function encode
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @static
             * @param {ml_metadata.MySQLDatabaseConfig.ISSLOptions} message SSLOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SSLOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.cert != null && Object.hasOwnProperty.call(message, "cert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cert);
                if (message.ca != null && Object.hasOwnProperty.call(message, "ca"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ca);
                if (message.capath != null && Object.hasOwnProperty.call(message, "capath"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.capath);
                if (message.cipher != null && Object.hasOwnProperty.call(message, "cipher"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.cipher);
                if (message.verifyServerCert != null && Object.hasOwnProperty.call(message, "verifyServerCert"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.verifyServerCert);
                return writer;
            };

            /**
             * Encodes the specified SSLOptions message, length delimited. Does not implicitly {@link ml_metadata.MySQLDatabaseConfig.SSLOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @static
             * @param {ml_metadata.MySQLDatabaseConfig.ISSLOptions} message SSLOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SSLOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SSLOptions message from the specified reader or buffer.
             * @function decode
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ml_metadata.MySQLDatabaseConfig.SSLOptions} SSLOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SSLOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.MySQLDatabaseConfig.SSLOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.cert = reader.string();
                        break;
                    case 3:
                        message.ca = reader.string();
                        break;
                    case 4:
                        message.capath = reader.string();
                        break;
                    case 5:
                        message.cipher = reader.string();
                        break;
                    case 6:
                        message.verifyServerCert = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SSLOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ml_metadata.MySQLDatabaseConfig.SSLOptions} SSLOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SSLOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SSLOptions message.
             * @function verify
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SSLOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.cert != null && message.hasOwnProperty("cert"))
                    if (!$util.isString(message.cert))
                        return "cert: string expected";
                if (message.ca != null && message.hasOwnProperty("ca"))
                    if (!$util.isString(message.ca))
                        return "ca: string expected";
                if (message.capath != null && message.hasOwnProperty("capath"))
                    if (!$util.isString(message.capath))
                        return "capath: string expected";
                if (message.cipher != null && message.hasOwnProperty("cipher"))
                    if (!$util.isString(message.cipher))
                        return "cipher: string expected";
                if (message.verifyServerCert != null && message.hasOwnProperty("verifyServerCert"))
                    if (typeof message.verifyServerCert !== "boolean")
                        return "verifyServerCert: boolean expected";
                return null;
            };

            /**
             * Creates a SSLOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ml_metadata.MySQLDatabaseConfig.SSLOptions} SSLOptions
             */
            SSLOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.ml_metadata.MySQLDatabaseConfig.SSLOptions)
                    return object;
                var message = new $root.ml_metadata.MySQLDatabaseConfig.SSLOptions();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.cert != null)
                    message.cert = String(object.cert);
                if (object.ca != null)
                    message.ca = String(object.ca);
                if (object.capath != null)
                    message.capath = String(object.capath);
                if (object.cipher != null)
                    message.cipher = String(object.cipher);
                if (object.verifyServerCert != null)
                    message.verifyServerCert = Boolean(object.verifyServerCert);
                return message;
            };

            /**
             * Creates a plain object from a SSLOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @static
             * @param {ml_metadata.MySQLDatabaseConfig.SSLOptions} message SSLOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SSLOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.cert = "";
                    object.ca = "";
                    object.capath = "";
                    object.cipher = "";
                    object.verifyServerCert = false;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.cert != null && message.hasOwnProperty("cert"))
                    object.cert = message.cert;
                if (message.ca != null && message.hasOwnProperty("ca"))
                    object.ca = message.ca;
                if (message.capath != null && message.hasOwnProperty("capath"))
                    object.capath = message.capath;
                if (message.cipher != null && message.hasOwnProperty("cipher"))
                    object.cipher = message.cipher;
                if (message.verifyServerCert != null && message.hasOwnProperty("verifyServerCert"))
                    object.verifyServerCert = message.verifyServerCert;
                return object;
            };

            /**
             * Converts this SSLOptions to JSON.
             * @function toJSON
             * @memberof ml_metadata.MySQLDatabaseConfig.SSLOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SSLOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SSLOptions;
        })();

        return MySQLDatabaseConfig;
    })();

    ml_metadata.SqliteMetadataSourceConfig = (function() {

        /**
         * Properties of a SqliteMetadataSourceConfig.
         * @memberof ml_metadata
         * @interface ISqliteMetadataSourceConfig
         * @property {string|null} [filenameUri] SqliteMetadataSourceConfig filenameUri
         * @property {ml_metadata.SqliteMetadataSourceConfig.ConnectionMode|null} [connectionMode] SqliteMetadataSourceConfig connectionMode
         */

        /**
         * Constructs a new SqliteMetadataSourceConfig.
         * @memberof ml_metadata
         * @classdesc Represents a SqliteMetadataSourceConfig.
         * @implements ISqliteMetadataSourceConfig
         * @constructor
         * @param {ml_metadata.ISqliteMetadataSourceConfig=} [properties] Properties to set
         */
        function SqliteMetadataSourceConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SqliteMetadataSourceConfig filenameUri.
         * @member {string} filenameUri
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @instance
         */
        SqliteMetadataSourceConfig.prototype.filenameUri = "";

        /**
         * SqliteMetadataSourceConfig connectionMode.
         * @member {ml_metadata.SqliteMetadataSourceConfig.ConnectionMode} connectionMode
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @instance
         */
        SqliteMetadataSourceConfig.prototype.connectionMode = 0;

        /**
         * Creates a new SqliteMetadataSourceConfig instance using the specified properties.
         * @function create
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @static
         * @param {ml_metadata.ISqliteMetadataSourceConfig=} [properties] Properties to set
         * @returns {ml_metadata.SqliteMetadataSourceConfig} SqliteMetadataSourceConfig instance
         */
        SqliteMetadataSourceConfig.create = function create(properties) {
            return new SqliteMetadataSourceConfig(properties);
        };

        /**
         * Encodes the specified SqliteMetadataSourceConfig message. Does not implicitly {@link ml_metadata.SqliteMetadataSourceConfig.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @static
         * @param {ml_metadata.ISqliteMetadataSourceConfig} message SqliteMetadataSourceConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SqliteMetadataSourceConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filenameUri != null && Object.hasOwnProperty.call(message, "filenameUri"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.filenameUri);
            if (message.connectionMode != null && Object.hasOwnProperty.call(message, "connectionMode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.connectionMode);
            return writer;
        };

        /**
         * Encodes the specified SqliteMetadataSourceConfig message, length delimited. Does not implicitly {@link ml_metadata.SqliteMetadataSourceConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @static
         * @param {ml_metadata.ISqliteMetadataSourceConfig} message SqliteMetadataSourceConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SqliteMetadataSourceConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SqliteMetadataSourceConfig message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.SqliteMetadataSourceConfig} SqliteMetadataSourceConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SqliteMetadataSourceConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.SqliteMetadataSourceConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.filenameUri = reader.string();
                    break;
                case 2:
                    message.connectionMode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SqliteMetadataSourceConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.SqliteMetadataSourceConfig} SqliteMetadataSourceConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SqliteMetadataSourceConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SqliteMetadataSourceConfig message.
         * @function verify
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SqliteMetadataSourceConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filenameUri != null && message.hasOwnProperty("filenameUri"))
                if (!$util.isString(message.filenameUri))
                    return "filenameUri: string expected";
            if (message.connectionMode != null && message.hasOwnProperty("connectionMode"))
                switch (message.connectionMode) {
                default:
                    return "connectionMode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a SqliteMetadataSourceConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.SqliteMetadataSourceConfig} SqliteMetadataSourceConfig
         */
        SqliteMetadataSourceConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.SqliteMetadataSourceConfig)
                return object;
            var message = new $root.ml_metadata.SqliteMetadataSourceConfig();
            if (object.filenameUri != null)
                message.filenameUri = String(object.filenameUri);
            switch (object.connectionMode) {
            case "UNKNOWN":
            case 0:
                message.connectionMode = 0;
                break;
            case "READONLY":
            case 1:
                message.connectionMode = 1;
                break;
            case "READWRITE":
            case 2:
                message.connectionMode = 2;
                break;
            case "READWRITE_OPENCREATE":
            case 3:
                message.connectionMode = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SqliteMetadataSourceConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @static
         * @param {ml_metadata.SqliteMetadataSourceConfig} message SqliteMetadataSourceConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SqliteMetadataSourceConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.filenameUri = "";
                object.connectionMode = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.filenameUri != null && message.hasOwnProperty("filenameUri"))
                object.filenameUri = message.filenameUri;
            if (message.connectionMode != null && message.hasOwnProperty("connectionMode"))
                object.connectionMode = options.enums === String ? $root.ml_metadata.SqliteMetadataSourceConfig.ConnectionMode[message.connectionMode] : message.connectionMode;
            return object;
        };

        /**
         * Converts this SqliteMetadataSourceConfig to JSON.
         * @function toJSON
         * @memberof ml_metadata.SqliteMetadataSourceConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SqliteMetadataSourceConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ConnectionMode enum.
         * @name ml_metadata.SqliteMetadataSourceConfig.ConnectionMode
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} READONLY=1 READONLY value
         * @property {number} READWRITE=2 READWRITE value
         * @property {number} READWRITE_OPENCREATE=3 READWRITE_OPENCREATE value
         */
        SqliteMetadataSourceConfig.ConnectionMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "READONLY"] = 1;
            values[valuesById[2] = "READWRITE"] = 2;
            values[valuesById[3] = "READWRITE_OPENCREATE"] = 3;
            return values;
        })();

        return SqliteMetadataSourceConfig;
    })();

    ml_metadata.MigrationOptions = (function() {

        /**
         * Properties of a MigrationOptions.
         * @memberof ml_metadata
         * @interface IMigrationOptions
         * @property {boolean|null} [enableUpgradeMigration] MigrationOptions enableUpgradeMigration
         * @property {number|Long|null} [downgradeToSchemaVersion] MigrationOptions downgradeToSchemaVersion
         */

        /**
         * Constructs a new MigrationOptions.
         * @memberof ml_metadata
         * @classdesc Represents a MigrationOptions.
         * @implements IMigrationOptions
         * @constructor
         * @param {ml_metadata.IMigrationOptions=} [properties] Properties to set
         */
        function MigrationOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MigrationOptions enableUpgradeMigration.
         * @member {boolean} enableUpgradeMigration
         * @memberof ml_metadata.MigrationOptions
         * @instance
         */
        MigrationOptions.prototype.enableUpgradeMigration = false;

        /**
         * MigrationOptions downgradeToSchemaVersion.
         * @member {number|Long} downgradeToSchemaVersion
         * @memberof ml_metadata.MigrationOptions
         * @instance
         */
        MigrationOptions.prototype.downgradeToSchemaVersion = $util.Long ? $util.Long.fromBits(-1,-1,false) : -1;

        /**
         * Creates a new MigrationOptions instance using the specified properties.
         * @function create
         * @memberof ml_metadata.MigrationOptions
         * @static
         * @param {ml_metadata.IMigrationOptions=} [properties] Properties to set
         * @returns {ml_metadata.MigrationOptions} MigrationOptions instance
         */
        MigrationOptions.create = function create(properties) {
            return new MigrationOptions(properties);
        };

        /**
         * Encodes the specified MigrationOptions message. Does not implicitly {@link ml_metadata.MigrationOptions.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.MigrationOptions
         * @static
         * @param {ml_metadata.IMigrationOptions} message MigrationOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MigrationOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.downgradeToSchemaVersion != null && Object.hasOwnProperty.call(message, "downgradeToSchemaVersion"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.downgradeToSchemaVersion);
            if (message.enableUpgradeMigration != null && Object.hasOwnProperty.call(message, "enableUpgradeMigration"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.enableUpgradeMigration);
            return writer;
        };

        /**
         * Encodes the specified MigrationOptions message, length delimited. Does not implicitly {@link ml_metadata.MigrationOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.MigrationOptions
         * @static
         * @param {ml_metadata.IMigrationOptions} message MigrationOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MigrationOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MigrationOptions message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.MigrationOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.MigrationOptions} MigrationOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MigrationOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.MigrationOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.enableUpgradeMigration = reader.bool();
                    break;
                case 2:
                    message.downgradeToSchemaVersion = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MigrationOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.MigrationOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.MigrationOptions} MigrationOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MigrationOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MigrationOptions message.
         * @function verify
         * @memberof ml_metadata.MigrationOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MigrationOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enableUpgradeMigration != null && message.hasOwnProperty("enableUpgradeMigration"))
                if (typeof message.enableUpgradeMigration !== "boolean")
                    return "enableUpgradeMigration: boolean expected";
            if (message.downgradeToSchemaVersion != null && message.hasOwnProperty("downgradeToSchemaVersion"))
                if (!$util.isInteger(message.downgradeToSchemaVersion) && !(message.downgradeToSchemaVersion && $util.isInteger(message.downgradeToSchemaVersion.low) && $util.isInteger(message.downgradeToSchemaVersion.high)))
                    return "downgradeToSchemaVersion: integer|Long expected";
            return null;
        };

        /**
         * Creates a MigrationOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.MigrationOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.MigrationOptions} MigrationOptions
         */
        MigrationOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.MigrationOptions)
                return object;
            var message = new $root.ml_metadata.MigrationOptions();
            if (object.enableUpgradeMigration != null)
                message.enableUpgradeMigration = Boolean(object.enableUpgradeMigration);
            if (object.downgradeToSchemaVersion != null)
                if ($util.Long)
                    (message.downgradeToSchemaVersion = $util.Long.fromValue(object.downgradeToSchemaVersion)).unsigned = false;
                else if (typeof object.downgradeToSchemaVersion === "string")
                    message.downgradeToSchemaVersion = parseInt(object.downgradeToSchemaVersion, 10);
                else if (typeof object.downgradeToSchemaVersion === "number")
                    message.downgradeToSchemaVersion = object.downgradeToSchemaVersion;
                else if (typeof object.downgradeToSchemaVersion === "object")
                    message.downgradeToSchemaVersion = new $util.LongBits(object.downgradeToSchemaVersion.low >>> 0, object.downgradeToSchemaVersion.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a MigrationOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.MigrationOptions
         * @static
         * @param {ml_metadata.MigrationOptions} message MigrationOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MigrationOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(-1, -1, false);
                    object.downgradeToSchemaVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.downgradeToSchemaVersion = options.longs === String ? "-1" : -1;
                object.enableUpgradeMigration = false;
            }
            if (message.downgradeToSchemaVersion != null && message.hasOwnProperty("downgradeToSchemaVersion"))
                if (typeof message.downgradeToSchemaVersion === "number")
                    object.downgradeToSchemaVersion = options.longs === String ? String(message.downgradeToSchemaVersion) : message.downgradeToSchemaVersion;
                else
                    object.downgradeToSchemaVersion = options.longs === String ? $util.Long.prototype.toString.call(message.downgradeToSchemaVersion) : options.longs === Number ? new $util.LongBits(message.downgradeToSchemaVersion.low >>> 0, message.downgradeToSchemaVersion.high >>> 0).toNumber() : message.downgradeToSchemaVersion;
            if (message.enableUpgradeMigration != null && message.hasOwnProperty("enableUpgradeMigration"))
                object.enableUpgradeMigration = message.enableUpgradeMigration;
            return object;
        };

        /**
         * Converts this MigrationOptions to JSON.
         * @function toJSON
         * @memberof ml_metadata.MigrationOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MigrationOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MigrationOptions;
    })();

    ml_metadata.RetryOptions = (function() {

        /**
         * Properties of a RetryOptions.
         * @memberof ml_metadata
         * @interface IRetryOptions
         * @property {number|Long|null} [maxNumRetries] RetryOptions maxNumRetries
         */

        /**
         * Constructs a new RetryOptions.
         * @memberof ml_metadata
         * @classdesc Represents a RetryOptions.
         * @implements IRetryOptions
         * @constructor
         * @param {ml_metadata.IRetryOptions=} [properties] Properties to set
         */
        function RetryOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RetryOptions maxNumRetries.
         * @member {number|Long} maxNumRetries
         * @memberof ml_metadata.RetryOptions
         * @instance
         */
        RetryOptions.prototype.maxNumRetries = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RetryOptions instance using the specified properties.
         * @function create
         * @memberof ml_metadata.RetryOptions
         * @static
         * @param {ml_metadata.IRetryOptions=} [properties] Properties to set
         * @returns {ml_metadata.RetryOptions} RetryOptions instance
         */
        RetryOptions.create = function create(properties) {
            return new RetryOptions(properties);
        };

        /**
         * Encodes the specified RetryOptions message. Does not implicitly {@link ml_metadata.RetryOptions.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.RetryOptions
         * @static
         * @param {ml_metadata.IRetryOptions} message RetryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RetryOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.maxNumRetries != null && Object.hasOwnProperty.call(message, "maxNumRetries"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.maxNumRetries);
            return writer;
        };

        /**
         * Encodes the specified RetryOptions message, length delimited. Does not implicitly {@link ml_metadata.RetryOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.RetryOptions
         * @static
         * @param {ml_metadata.IRetryOptions} message RetryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RetryOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RetryOptions message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.RetryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.RetryOptions} RetryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RetryOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.RetryOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.maxNumRetries = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RetryOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.RetryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.RetryOptions} RetryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RetryOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RetryOptions message.
         * @function verify
         * @memberof ml_metadata.RetryOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RetryOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.maxNumRetries != null && message.hasOwnProperty("maxNumRetries"))
                if (!$util.isInteger(message.maxNumRetries) && !(message.maxNumRetries && $util.isInteger(message.maxNumRetries.low) && $util.isInteger(message.maxNumRetries.high)))
                    return "maxNumRetries: integer|Long expected";
            return null;
        };

        /**
         * Creates a RetryOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.RetryOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.RetryOptions} RetryOptions
         */
        RetryOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.RetryOptions)
                return object;
            var message = new $root.ml_metadata.RetryOptions();
            if (object.maxNumRetries != null)
                if ($util.Long)
                    (message.maxNumRetries = $util.Long.fromValue(object.maxNumRetries)).unsigned = false;
                else if (typeof object.maxNumRetries === "string")
                    message.maxNumRetries = parseInt(object.maxNumRetries, 10);
                else if (typeof object.maxNumRetries === "number")
                    message.maxNumRetries = object.maxNumRetries;
                else if (typeof object.maxNumRetries === "object")
                    message.maxNumRetries = new $util.LongBits(object.maxNumRetries.low >>> 0, object.maxNumRetries.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RetryOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.RetryOptions
         * @static
         * @param {ml_metadata.RetryOptions} message RetryOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RetryOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.maxNumRetries = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxNumRetries = options.longs === String ? "0" : 0;
            if (message.maxNumRetries != null && message.hasOwnProperty("maxNumRetries"))
                if (typeof message.maxNumRetries === "number")
                    object.maxNumRetries = options.longs === String ? String(message.maxNumRetries) : message.maxNumRetries;
                else
                    object.maxNumRetries = options.longs === String ? $util.Long.prototype.toString.call(message.maxNumRetries) : options.longs === Number ? new $util.LongBits(message.maxNumRetries.low >>> 0, message.maxNumRetries.high >>> 0).toNumber() : message.maxNumRetries;
            return object;
        };

        /**
         * Converts this RetryOptions to JSON.
         * @function toJSON
         * @memberof ml_metadata.RetryOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RetryOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RetryOptions;
    })();

    ml_metadata.ConnectionConfig = (function() {

        /**
         * Properties of a ConnectionConfig.
         * @memberof ml_metadata
         * @interface IConnectionConfig
         * @property {ml_metadata.IFakeDatabaseConfig|null} [fakeDatabase] ConnectionConfig fakeDatabase
         * @property {ml_metadata.IMySQLDatabaseConfig|null} [mysql] ConnectionConfig mysql
         * @property {ml_metadata.ISqliteMetadataSourceConfig|null} [sqlite] ConnectionConfig sqlite
         * @property {ml_metadata.IRetryOptions|null} [retryOptions] ConnectionConfig retryOptions
         */

        /**
         * Constructs a new ConnectionConfig.
         * @memberof ml_metadata
         * @classdesc Represents a ConnectionConfig.
         * @implements IConnectionConfig
         * @constructor
         * @param {ml_metadata.IConnectionConfig=} [properties] Properties to set
         */
        function ConnectionConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnectionConfig fakeDatabase.
         * @member {ml_metadata.IFakeDatabaseConfig|null|undefined} fakeDatabase
         * @memberof ml_metadata.ConnectionConfig
         * @instance
         */
        ConnectionConfig.prototype.fakeDatabase = null;

        /**
         * ConnectionConfig mysql.
         * @member {ml_metadata.IMySQLDatabaseConfig|null|undefined} mysql
         * @memberof ml_metadata.ConnectionConfig
         * @instance
         */
        ConnectionConfig.prototype.mysql = null;

        /**
         * ConnectionConfig sqlite.
         * @member {ml_metadata.ISqliteMetadataSourceConfig|null|undefined} sqlite
         * @memberof ml_metadata.ConnectionConfig
         * @instance
         */
        ConnectionConfig.prototype.sqlite = null;

        /**
         * ConnectionConfig retryOptions.
         * @member {ml_metadata.IRetryOptions|null|undefined} retryOptions
         * @memberof ml_metadata.ConnectionConfig
         * @instance
         */
        ConnectionConfig.prototype.retryOptions = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ConnectionConfig config.
         * @member {"fakeDatabase"|"mysql"|"sqlite"|undefined} config
         * @memberof ml_metadata.ConnectionConfig
         * @instance
         */
        Object.defineProperty(ConnectionConfig.prototype, "config", {
            get: $util.oneOfGetter($oneOfFields = ["fakeDatabase", "mysql", "sqlite"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ConnectionConfig instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ConnectionConfig
         * @static
         * @param {ml_metadata.IConnectionConfig=} [properties] Properties to set
         * @returns {ml_metadata.ConnectionConfig} ConnectionConfig instance
         */
        ConnectionConfig.create = function create(properties) {
            return new ConnectionConfig(properties);
        };

        /**
         * Encodes the specified ConnectionConfig message. Does not implicitly {@link ml_metadata.ConnectionConfig.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ConnectionConfig
         * @static
         * @param {ml_metadata.IConnectionConfig} message ConnectionConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectionConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fakeDatabase != null && Object.hasOwnProperty.call(message, "fakeDatabase"))
                $root.ml_metadata.FakeDatabaseConfig.encode(message.fakeDatabase, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mysql != null && Object.hasOwnProperty.call(message, "mysql"))
                $root.ml_metadata.MySQLDatabaseConfig.encode(message.mysql, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sqlite != null && Object.hasOwnProperty.call(message, "sqlite"))
                $root.ml_metadata.SqliteMetadataSourceConfig.encode(message.sqlite, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.retryOptions != null && Object.hasOwnProperty.call(message, "retryOptions"))
                $root.ml_metadata.RetryOptions.encode(message.retryOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ConnectionConfig message, length delimited. Does not implicitly {@link ml_metadata.ConnectionConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ConnectionConfig
         * @static
         * @param {ml_metadata.IConnectionConfig} message ConnectionConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectionConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectionConfig message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ConnectionConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ConnectionConfig} ConnectionConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectionConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ConnectionConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fakeDatabase = $root.ml_metadata.FakeDatabaseConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.mysql = $root.ml_metadata.MySQLDatabaseConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.sqlite = $root.ml_metadata.SqliteMetadataSourceConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.retryOptions = $root.ml_metadata.RetryOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectionConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ConnectionConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ConnectionConfig} ConnectionConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectionConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectionConfig message.
         * @function verify
         * @memberof ml_metadata.ConnectionConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectionConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.fakeDatabase != null && message.hasOwnProperty("fakeDatabase")) {
                properties.config = 1;
                {
                    var error = $root.ml_metadata.FakeDatabaseConfig.verify(message.fakeDatabase);
                    if (error)
                        return "fakeDatabase." + error;
                }
            }
            if (message.mysql != null && message.hasOwnProperty("mysql")) {
                if (properties.config === 1)
                    return "config: multiple values";
                properties.config = 1;
                {
                    var error = $root.ml_metadata.MySQLDatabaseConfig.verify(message.mysql);
                    if (error)
                        return "mysql." + error;
                }
            }
            if (message.sqlite != null && message.hasOwnProperty("sqlite")) {
                if (properties.config === 1)
                    return "config: multiple values";
                properties.config = 1;
                {
                    var error = $root.ml_metadata.SqliteMetadataSourceConfig.verify(message.sqlite);
                    if (error)
                        return "sqlite." + error;
                }
            }
            if (message.retryOptions != null && message.hasOwnProperty("retryOptions")) {
                var error = $root.ml_metadata.RetryOptions.verify(message.retryOptions);
                if (error)
                    return "retryOptions." + error;
            }
            return null;
        };

        /**
         * Creates a ConnectionConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ConnectionConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ConnectionConfig} ConnectionConfig
         */
        ConnectionConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ConnectionConfig)
                return object;
            var message = new $root.ml_metadata.ConnectionConfig();
            if (object.fakeDatabase != null) {
                if (typeof object.fakeDatabase !== "object")
                    throw TypeError(".ml_metadata.ConnectionConfig.fakeDatabase: object expected");
                message.fakeDatabase = $root.ml_metadata.FakeDatabaseConfig.fromObject(object.fakeDatabase);
            }
            if (object.mysql != null) {
                if (typeof object.mysql !== "object")
                    throw TypeError(".ml_metadata.ConnectionConfig.mysql: object expected");
                message.mysql = $root.ml_metadata.MySQLDatabaseConfig.fromObject(object.mysql);
            }
            if (object.sqlite != null) {
                if (typeof object.sqlite !== "object")
                    throw TypeError(".ml_metadata.ConnectionConfig.sqlite: object expected");
                message.sqlite = $root.ml_metadata.SqliteMetadataSourceConfig.fromObject(object.sqlite);
            }
            if (object.retryOptions != null) {
                if (typeof object.retryOptions !== "object")
                    throw TypeError(".ml_metadata.ConnectionConfig.retryOptions: object expected");
                message.retryOptions = $root.ml_metadata.RetryOptions.fromObject(object.retryOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from a ConnectionConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ConnectionConfig
         * @static
         * @param {ml_metadata.ConnectionConfig} message ConnectionConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectionConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.retryOptions = null;
            if (message.fakeDatabase != null && message.hasOwnProperty("fakeDatabase")) {
                object.fakeDatabase = $root.ml_metadata.FakeDatabaseConfig.toObject(message.fakeDatabase, options);
                if (options.oneofs)
                    object.config = "fakeDatabase";
            }
            if (message.mysql != null && message.hasOwnProperty("mysql")) {
                object.mysql = $root.ml_metadata.MySQLDatabaseConfig.toObject(message.mysql, options);
                if (options.oneofs)
                    object.config = "mysql";
            }
            if (message.sqlite != null && message.hasOwnProperty("sqlite")) {
                object.sqlite = $root.ml_metadata.SqliteMetadataSourceConfig.toObject(message.sqlite, options);
                if (options.oneofs)
                    object.config = "sqlite";
            }
            if (message.retryOptions != null && message.hasOwnProperty("retryOptions"))
                object.retryOptions = $root.ml_metadata.RetryOptions.toObject(message.retryOptions, options);
            return object;
        };

        /**
         * Converts this ConnectionConfig to JSON.
         * @function toJSON
         * @memberof ml_metadata.ConnectionConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectionConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnectionConfig;
    })();

    ml_metadata.GrpcChannelArguments = (function() {

        /**
         * Properties of a GrpcChannelArguments.
         * @memberof ml_metadata
         * @interface IGrpcChannelArguments
         * @property {number|Long|null} [maxReceiveMessageLength] GrpcChannelArguments maxReceiveMessageLength
         * @property {number|Long|null} [http2MaxPingStrikes] GrpcChannelArguments http2MaxPingStrikes
         */

        /**
         * Constructs a new GrpcChannelArguments.
         * @memberof ml_metadata
         * @classdesc Represents a GrpcChannelArguments.
         * @implements IGrpcChannelArguments
         * @constructor
         * @param {ml_metadata.IGrpcChannelArguments=} [properties] Properties to set
         */
        function GrpcChannelArguments(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GrpcChannelArguments maxReceiveMessageLength.
         * @member {number|Long} maxReceiveMessageLength
         * @memberof ml_metadata.GrpcChannelArguments
         * @instance
         */
        GrpcChannelArguments.prototype.maxReceiveMessageLength = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GrpcChannelArguments http2MaxPingStrikes.
         * @member {number|Long} http2MaxPingStrikes
         * @memberof ml_metadata.GrpcChannelArguments
         * @instance
         */
        GrpcChannelArguments.prototype.http2MaxPingStrikes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GrpcChannelArguments instance using the specified properties.
         * @function create
         * @memberof ml_metadata.GrpcChannelArguments
         * @static
         * @param {ml_metadata.IGrpcChannelArguments=} [properties] Properties to set
         * @returns {ml_metadata.GrpcChannelArguments} GrpcChannelArguments instance
         */
        GrpcChannelArguments.create = function create(properties) {
            return new GrpcChannelArguments(properties);
        };

        /**
         * Encodes the specified GrpcChannelArguments message. Does not implicitly {@link ml_metadata.GrpcChannelArguments.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.GrpcChannelArguments
         * @static
         * @param {ml_metadata.IGrpcChannelArguments} message GrpcChannelArguments message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrpcChannelArguments.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.maxReceiveMessageLength != null && Object.hasOwnProperty.call(message, "maxReceiveMessageLength"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.maxReceiveMessageLength);
            if (message.http2MaxPingStrikes != null && Object.hasOwnProperty.call(message, "http2MaxPingStrikes"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.http2MaxPingStrikes);
            return writer;
        };

        /**
         * Encodes the specified GrpcChannelArguments message, length delimited. Does not implicitly {@link ml_metadata.GrpcChannelArguments.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.GrpcChannelArguments
         * @static
         * @param {ml_metadata.IGrpcChannelArguments} message GrpcChannelArguments message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrpcChannelArguments.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GrpcChannelArguments message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.GrpcChannelArguments
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.GrpcChannelArguments} GrpcChannelArguments
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrpcChannelArguments.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.GrpcChannelArguments();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.maxReceiveMessageLength = reader.int64();
                    break;
                case 2:
                    message.http2MaxPingStrikes = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GrpcChannelArguments message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.GrpcChannelArguments
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.GrpcChannelArguments} GrpcChannelArguments
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrpcChannelArguments.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GrpcChannelArguments message.
         * @function verify
         * @memberof ml_metadata.GrpcChannelArguments
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GrpcChannelArguments.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.maxReceiveMessageLength != null && message.hasOwnProperty("maxReceiveMessageLength"))
                if (!$util.isInteger(message.maxReceiveMessageLength) && !(message.maxReceiveMessageLength && $util.isInteger(message.maxReceiveMessageLength.low) && $util.isInteger(message.maxReceiveMessageLength.high)))
                    return "maxReceiveMessageLength: integer|Long expected";
            if (message.http2MaxPingStrikes != null && message.hasOwnProperty("http2MaxPingStrikes"))
                if (!$util.isInteger(message.http2MaxPingStrikes) && !(message.http2MaxPingStrikes && $util.isInteger(message.http2MaxPingStrikes.low) && $util.isInteger(message.http2MaxPingStrikes.high)))
                    return "http2MaxPingStrikes: integer|Long expected";
            return null;
        };

        /**
         * Creates a GrpcChannelArguments message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.GrpcChannelArguments
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.GrpcChannelArguments} GrpcChannelArguments
         */
        GrpcChannelArguments.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.GrpcChannelArguments)
                return object;
            var message = new $root.ml_metadata.GrpcChannelArguments();
            if (object.maxReceiveMessageLength != null)
                if ($util.Long)
                    (message.maxReceiveMessageLength = $util.Long.fromValue(object.maxReceiveMessageLength)).unsigned = false;
                else if (typeof object.maxReceiveMessageLength === "string")
                    message.maxReceiveMessageLength = parseInt(object.maxReceiveMessageLength, 10);
                else if (typeof object.maxReceiveMessageLength === "number")
                    message.maxReceiveMessageLength = object.maxReceiveMessageLength;
                else if (typeof object.maxReceiveMessageLength === "object")
                    message.maxReceiveMessageLength = new $util.LongBits(object.maxReceiveMessageLength.low >>> 0, object.maxReceiveMessageLength.high >>> 0).toNumber();
            if (object.http2MaxPingStrikes != null)
                if ($util.Long)
                    (message.http2MaxPingStrikes = $util.Long.fromValue(object.http2MaxPingStrikes)).unsigned = false;
                else if (typeof object.http2MaxPingStrikes === "string")
                    message.http2MaxPingStrikes = parseInt(object.http2MaxPingStrikes, 10);
                else if (typeof object.http2MaxPingStrikes === "number")
                    message.http2MaxPingStrikes = object.http2MaxPingStrikes;
                else if (typeof object.http2MaxPingStrikes === "object")
                    message.http2MaxPingStrikes = new $util.LongBits(object.http2MaxPingStrikes.low >>> 0, object.http2MaxPingStrikes.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GrpcChannelArguments message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.GrpcChannelArguments
         * @static
         * @param {ml_metadata.GrpcChannelArguments} message GrpcChannelArguments
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GrpcChannelArguments.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.maxReceiveMessageLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxReceiveMessageLength = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.http2MaxPingStrikes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.http2MaxPingStrikes = options.longs === String ? "0" : 0;
            }
            if (message.maxReceiveMessageLength != null && message.hasOwnProperty("maxReceiveMessageLength"))
                if (typeof message.maxReceiveMessageLength === "number")
                    object.maxReceiveMessageLength = options.longs === String ? String(message.maxReceiveMessageLength) : message.maxReceiveMessageLength;
                else
                    object.maxReceiveMessageLength = options.longs === String ? $util.Long.prototype.toString.call(message.maxReceiveMessageLength) : options.longs === Number ? new $util.LongBits(message.maxReceiveMessageLength.low >>> 0, message.maxReceiveMessageLength.high >>> 0).toNumber() : message.maxReceiveMessageLength;
            if (message.http2MaxPingStrikes != null && message.hasOwnProperty("http2MaxPingStrikes"))
                if (typeof message.http2MaxPingStrikes === "number")
                    object.http2MaxPingStrikes = options.longs === String ? String(message.http2MaxPingStrikes) : message.http2MaxPingStrikes;
                else
                    object.http2MaxPingStrikes = options.longs === String ? $util.Long.prototype.toString.call(message.http2MaxPingStrikes) : options.longs === Number ? new $util.LongBits(message.http2MaxPingStrikes.low >>> 0, message.http2MaxPingStrikes.high >>> 0).toNumber() : message.http2MaxPingStrikes;
            return object;
        };

        /**
         * Converts this GrpcChannelArguments to JSON.
         * @function toJSON
         * @memberof ml_metadata.GrpcChannelArguments
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GrpcChannelArguments.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GrpcChannelArguments;
    })();

    ml_metadata.MetadataStoreClientConfig = (function() {

        /**
         * Properties of a MetadataStoreClientConfig.
         * @memberof ml_metadata
         * @interface IMetadataStoreClientConfig
         * @property {string|null} [host] MetadataStoreClientConfig host
         * @property {number|null} [port] MetadataStoreClientConfig port
         * @property {ml_metadata.MetadataStoreClientConfig.ISSLConfig|null} [sslConfig] MetadataStoreClientConfig sslConfig
         * @property {ml_metadata.IGrpcChannelArguments|null} [channelArguments] MetadataStoreClientConfig channelArguments
         * @property {number|null} [clientTimeoutSec] MetadataStoreClientConfig clientTimeoutSec
         */

        /**
         * Constructs a new MetadataStoreClientConfig.
         * @memberof ml_metadata
         * @classdesc Represents a MetadataStoreClientConfig.
         * @implements IMetadataStoreClientConfig
         * @constructor
         * @param {ml_metadata.IMetadataStoreClientConfig=} [properties] Properties to set
         */
        function MetadataStoreClientConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MetadataStoreClientConfig host.
         * @member {string} host
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @instance
         */
        MetadataStoreClientConfig.prototype.host = "";

        /**
         * MetadataStoreClientConfig port.
         * @member {number} port
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @instance
         */
        MetadataStoreClientConfig.prototype.port = 0;

        /**
         * MetadataStoreClientConfig sslConfig.
         * @member {ml_metadata.MetadataStoreClientConfig.ISSLConfig|null|undefined} sslConfig
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @instance
         */
        MetadataStoreClientConfig.prototype.sslConfig = null;

        /**
         * MetadataStoreClientConfig channelArguments.
         * @member {ml_metadata.IGrpcChannelArguments|null|undefined} channelArguments
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @instance
         */
        MetadataStoreClientConfig.prototype.channelArguments = null;

        /**
         * MetadataStoreClientConfig clientTimeoutSec.
         * @member {number} clientTimeoutSec
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @instance
         */
        MetadataStoreClientConfig.prototype.clientTimeoutSec = 0;

        /**
         * Creates a new MetadataStoreClientConfig instance using the specified properties.
         * @function create
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @static
         * @param {ml_metadata.IMetadataStoreClientConfig=} [properties] Properties to set
         * @returns {ml_metadata.MetadataStoreClientConfig} MetadataStoreClientConfig instance
         */
        MetadataStoreClientConfig.create = function create(properties) {
            return new MetadataStoreClientConfig(properties);
        };

        /**
         * Encodes the specified MetadataStoreClientConfig message. Does not implicitly {@link ml_metadata.MetadataStoreClientConfig.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @static
         * @param {ml_metadata.IMetadataStoreClientConfig} message MetadataStoreClientConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MetadataStoreClientConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            if (message.sslConfig != null && Object.hasOwnProperty.call(message, "sslConfig"))
                $root.ml_metadata.MetadataStoreClientConfig.SSLConfig.encode(message.sslConfig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.channelArguments != null && Object.hasOwnProperty.call(message, "channelArguments"))
                $root.ml_metadata.GrpcChannelArguments.encode(message.channelArguments, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.clientTimeoutSec != null && Object.hasOwnProperty.call(message, "clientTimeoutSec"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.clientTimeoutSec);
            return writer;
        };

        /**
         * Encodes the specified MetadataStoreClientConfig message, length delimited. Does not implicitly {@link ml_metadata.MetadataStoreClientConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @static
         * @param {ml_metadata.IMetadataStoreClientConfig} message MetadataStoreClientConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MetadataStoreClientConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MetadataStoreClientConfig message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.MetadataStoreClientConfig} MetadataStoreClientConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MetadataStoreClientConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.MetadataStoreClientConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.port = reader.uint32();
                    break;
                case 3:
                    message.sslConfig = $root.ml_metadata.MetadataStoreClientConfig.SSLConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.channelArguments = $root.ml_metadata.GrpcChannelArguments.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.clientTimeoutSec = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MetadataStoreClientConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.MetadataStoreClientConfig} MetadataStoreClientConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MetadataStoreClientConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MetadataStoreClientConfig message.
         * @function verify
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MetadataStoreClientConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.sslConfig != null && message.hasOwnProperty("sslConfig")) {
                var error = $root.ml_metadata.MetadataStoreClientConfig.SSLConfig.verify(message.sslConfig);
                if (error)
                    return "sslConfig." + error;
            }
            if (message.channelArguments != null && message.hasOwnProperty("channelArguments")) {
                var error = $root.ml_metadata.GrpcChannelArguments.verify(message.channelArguments);
                if (error)
                    return "channelArguments." + error;
            }
            if (message.clientTimeoutSec != null && message.hasOwnProperty("clientTimeoutSec"))
                if (typeof message.clientTimeoutSec !== "number")
                    return "clientTimeoutSec: number expected";
            return null;
        };

        /**
         * Creates a MetadataStoreClientConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.MetadataStoreClientConfig} MetadataStoreClientConfig
         */
        MetadataStoreClientConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.MetadataStoreClientConfig)
                return object;
            var message = new $root.ml_metadata.MetadataStoreClientConfig();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.sslConfig != null) {
                if (typeof object.sslConfig !== "object")
                    throw TypeError(".ml_metadata.MetadataStoreClientConfig.sslConfig: object expected");
                message.sslConfig = $root.ml_metadata.MetadataStoreClientConfig.SSLConfig.fromObject(object.sslConfig);
            }
            if (object.channelArguments != null) {
                if (typeof object.channelArguments !== "object")
                    throw TypeError(".ml_metadata.MetadataStoreClientConfig.channelArguments: object expected");
                message.channelArguments = $root.ml_metadata.GrpcChannelArguments.fromObject(object.channelArguments);
            }
            if (object.clientTimeoutSec != null)
                message.clientTimeoutSec = Number(object.clientTimeoutSec);
            return message;
        };

        /**
         * Creates a plain object from a MetadataStoreClientConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @static
         * @param {ml_metadata.MetadataStoreClientConfig} message MetadataStoreClientConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MetadataStoreClientConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.sslConfig = null;
                object.channelArguments = null;
                object.clientTimeoutSec = 0;
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.sslConfig != null && message.hasOwnProperty("sslConfig"))
                object.sslConfig = $root.ml_metadata.MetadataStoreClientConfig.SSLConfig.toObject(message.sslConfig, options);
            if (message.channelArguments != null && message.hasOwnProperty("channelArguments"))
                object.channelArguments = $root.ml_metadata.GrpcChannelArguments.toObject(message.channelArguments, options);
            if (message.clientTimeoutSec != null && message.hasOwnProperty("clientTimeoutSec"))
                object.clientTimeoutSec = options.json && !isFinite(message.clientTimeoutSec) ? String(message.clientTimeoutSec) : message.clientTimeoutSec;
            return object;
        };

        /**
         * Converts this MetadataStoreClientConfig to JSON.
         * @function toJSON
         * @memberof ml_metadata.MetadataStoreClientConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MetadataStoreClientConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        MetadataStoreClientConfig.SSLConfig = (function() {

            /**
             * Properties of a SSLConfig.
             * @memberof ml_metadata.MetadataStoreClientConfig
             * @interface ISSLConfig
             * @property {string|null} [clientKey] SSLConfig clientKey
             * @property {string|null} [serverCert] SSLConfig serverCert
             * @property {string|null} [customCa] SSLConfig customCa
             */

            /**
             * Constructs a new SSLConfig.
             * @memberof ml_metadata.MetadataStoreClientConfig
             * @classdesc Represents a SSLConfig.
             * @implements ISSLConfig
             * @constructor
             * @param {ml_metadata.MetadataStoreClientConfig.ISSLConfig=} [properties] Properties to set
             */
            function SSLConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SSLConfig clientKey.
             * @member {string} clientKey
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @instance
             */
            SSLConfig.prototype.clientKey = "";

            /**
             * SSLConfig serverCert.
             * @member {string} serverCert
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @instance
             */
            SSLConfig.prototype.serverCert = "";

            /**
             * SSLConfig customCa.
             * @member {string} customCa
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @instance
             */
            SSLConfig.prototype.customCa = "";

            /**
             * Creates a new SSLConfig instance using the specified properties.
             * @function create
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @static
             * @param {ml_metadata.MetadataStoreClientConfig.ISSLConfig=} [properties] Properties to set
             * @returns {ml_metadata.MetadataStoreClientConfig.SSLConfig} SSLConfig instance
             */
            SSLConfig.create = function create(properties) {
                return new SSLConfig(properties);
            };

            /**
             * Encodes the specified SSLConfig message. Does not implicitly {@link ml_metadata.MetadataStoreClientConfig.SSLConfig.verify|verify} messages.
             * @function encode
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @static
             * @param {ml_metadata.MetadataStoreClientConfig.ISSLConfig} message SSLConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SSLConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.clientKey != null && Object.hasOwnProperty.call(message, "clientKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientKey);
                if (message.serverCert != null && Object.hasOwnProperty.call(message, "serverCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.serverCert);
                if (message.customCa != null && Object.hasOwnProperty.call(message, "customCa"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.customCa);
                return writer;
            };

            /**
             * Encodes the specified SSLConfig message, length delimited. Does not implicitly {@link ml_metadata.MetadataStoreClientConfig.SSLConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @static
             * @param {ml_metadata.MetadataStoreClientConfig.ISSLConfig} message SSLConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SSLConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SSLConfig message from the specified reader or buffer.
             * @function decode
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ml_metadata.MetadataStoreClientConfig.SSLConfig} SSLConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SSLConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.MetadataStoreClientConfig.SSLConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.clientKey = reader.string();
                        break;
                    case 2:
                        message.serverCert = reader.string();
                        break;
                    case 3:
                        message.customCa = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SSLConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ml_metadata.MetadataStoreClientConfig.SSLConfig} SSLConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SSLConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SSLConfig message.
             * @function verify
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SSLConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                    if (!$util.isString(message.clientKey))
                        return "clientKey: string expected";
                if (message.serverCert != null && message.hasOwnProperty("serverCert"))
                    if (!$util.isString(message.serverCert))
                        return "serverCert: string expected";
                if (message.customCa != null && message.hasOwnProperty("customCa"))
                    if (!$util.isString(message.customCa))
                        return "customCa: string expected";
                return null;
            };

            /**
             * Creates a SSLConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ml_metadata.MetadataStoreClientConfig.SSLConfig} SSLConfig
             */
            SSLConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.ml_metadata.MetadataStoreClientConfig.SSLConfig)
                    return object;
                var message = new $root.ml_metadata.MetadataStoreClientConfig.SSLConfig();
                if (object.clientKey != null)
                    message.clientKey = String(object.clientKey);
                if (object.serverCert != null)
                    message.serverCert = String(object.serverCert);
                if (object.customCa != null)
                    message.customCa = String(object.customCa);
                return message;
            };

            /**
             * Creates a plain object from a SSLConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @static
             * @param {ml_metadata.MetadataStoreClientConfig.SSLConfig} message SSLConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SSLConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.clientKey = "";
                    object.serverCert = "";
                    object.customCa = "";
                }
                if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                    object.clientKey = message.clientKey;
                if (message.serverCert != null && message.hasOwnProperty("serverCert"))
                    object.serverCert = message.serverCert;
                if (message.customCa != null && message.hasOwnProperty("customCa"))
                    object.customCa = message.customCa;
                return object;
            };

            /**
             * Converts this SSLConfig to JSON.
             * @function toJSON
             * @memberof ml_metadata.MetadataStoreClientConfig.SSLConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SSLConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SSLConfig;
        })();

        return MetadataStoreClientConfig;
    })();

    ml_metadata.MetadataStoreServerConfig = (function() {

        /**
         * Properties of a MetadataStoreServerConfig.
         * @memberof ml_metadata
         * @interface IMetadataStoreServerConfig
         * @property {ml_metadata.IConnectionConfig|null} [connectionConfig] MetadataStoreServerConfig connectionConfig
         * @property {ml_metadata.IMigrationOptions|null} [migrationOptions] MetadataStoreServerConfig migrationOptions
         * @property {ml_metadata.MetadataStoreServerConfig.ISSLConfig|null} [sslConfig] MetadataStoreServerConfig sslConfig
         */

        /**
         * Constructs a new MetadataStoreServerConfig.
         * @memberof ml_metadata
         * @classdesc Represents a MetadataStoreServerConfig.
         * @implements IMetadataStoreServerConfig
         * @constructor
         * @param {ml_metadata.IMetadataStoreServerConfig=} [properties] Properties to set
         */
        function MetadataStoreServerConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MetadataStoreServerConfig connectionConfig.
         * @member {ml_metadata.IConnectionConfig|null|undefined} connectionConfig
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @instance
         */
        MetadataStoreServerConfig.prototype.connectionConfig = null;

        /**
         * MetadataStoreServerConfig migrationOptions.
         * @member {ml_metadata.IMigrationOptions|null|undefined} migrationOptions
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @instance
         */
        MetadataStoreServerConfig.prototype.migrationOptions = null;

        /**
         * MetadataStoreServerConfig sslConfig.
         * @member {ml_metadata.MetadataStoreServerConfig.ISSLConfig|null|undefined} sslConfig
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @instance
         */
        MetadataStoreServerConfig.prototype.sslConfig = null;

        /**
         * Creates a new MetadataStoreServerConfig instance using the specified properties.
         * @function create
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @static
         * @param {ml_metadata.IMetadataStoreServerConfig=} [properties] Properties to set
         * @returns {ml_metadata.MetadataStoreServerConfig} MetadataStoreServerConfig instance
         */
        MetadataStoreServerConfig.create = function create(properties) {
            return new MetadataStoreServerConfig(properties);
        };

        /**
         * Encodes the specified MetadataStoreServerConfig message. Does not implicitly {@link ml_metadata.MetadataStoreServerConfig.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @static
         * @param {ml_metadata.IMetadataStoreServerConfig} message MetadataStoreServerConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MetadataStoreServerConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionConfig != null && Object.hasOwnProperty.call(message, "connectionConfig"))
                $root.ml_metadata.ConnectionConfig.encode(message.connectionConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sslConfig != null && Object.hasOwnProperty.call(message, "sslConfig"))
                $root.ml_metadata.MetadataStoreServerConfig.SSLConfig.encode(message.sslConfig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.migrationOptions != null && Object.hasOwnProperty.call(message, "migrationOptions"))
                $root.ml_metadata.MigrationOptions.encode(message.migrationOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MetadataStoreServerConfig message, length delimited. Does not implicitly {@link ml_metadata.MetadataStoreServerConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @static
         * @param {ml_metadata.IMetadataStoreServerConfig} message MetadataStoreServerConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MetadataStoreServerConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MetadataStoreServerConfig message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.MetadataStoreServerConfig} MetadataStoreServerConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MetadataStoreServerConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.MetadataStoreServerConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.connectionConfig = $root.ml_metadata.ConnectionConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.migrationOptions = $root.ml_metadata.MigrationOptions.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sslConfig = $root.ml_metadata.MetadataStoreServerConfig.SSLConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MetadataStoreServerConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.MetadataStoreServerConfig} MetadataStoreServerConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MetadataStoreServerConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MetadataStoreServerConfig message.
         * @function verify
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MetadataStoreServerConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.connectionConfig != null && message.hasOwnProperty("connectionConfig")) {
                var error = $root.ml_metadata.ConnectionConfig.verify(message.connectionConfig);
                if (error)
                    return "connectionConfig." + error;
            }
            if (message.migrationOptions != null && message.hasOwnProperty("migrationOptions")) {
                var error = $root.ml_metadata.MigrationOptions.verify(message.migrationOptions);
                if (error)
                    return "migrationOptions." + error;
            }
            if (message.sslConfig != null && message.hasOwnProperty("sslConfig")) {
                var error = $root.ml_metadata.MetadataStoreServerConfig.SSLConfig.verify(message.sslConfig);
                if (error)
                    return "sslConfig." + error;
            }
            return null;
        };

        /**
         * Creates a MetadataStoreServerConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.MetadataStoreServerConfig} MetadataStoreServerConfig
         */
        MetadataStoreServerConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.MetadataStoreServerConfig)
                return object;
            var message = new $root.ml_metadata.MetadataStoreServerConfig();
            if (object.connectionConfig != null) {
                if (typeof object.connectionConfig !== "object")
                    throw TypeError(".ml_metadata.MetadataStoreServerConfig.connectionConfig: object expected");
                message.connectionConfig = $root.ml_metadata.ConnectionConfig.fromObject(object.connectionConfig);
            }
            if (object.migrationOptions != null) {
                if (typeof object.migrationOptions !== "object")
                    throw TypeError(".ml_metadata.MetadataStoreServerConfig.migrationOptions: object expected");
                message.migrationOptions = $root.ml_metadata.MigrationOptions.fromObject(object.migrationOptions);
            }
            if (object.sslConfig != null) {
                if (typeof object.sslConfig !== "object")
                    throw TypeError(".ml_metadata.MetadataStoreServerConfig.sslConfig: object expected");
                message.sslConfig = $root.ml_metadata.MetadataStoreServerConfig.SSLConfig.fromObject(object.sslConfig);
            }
            return message;
        };

        /**
         * Creates a plain object from a MetadataStoreServerConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @static
         * @param {ml_metadata.MetadataStoreServerConfig} message MetadataStoreServerConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MetadataStoreServerConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionConfig = null;
                object.sslConfig = null;
                object.migrationOptions = null;
            }
            if (message.connectionConfig != null && message.hasOwnProperty("connectionConfig"))
                object.connectionConfig = $root.ml_metadata.ConnectionConfig.toObject(message.connectionConfig, options);
            if (message.sslConfig != null && message.hasOwnProperty("sslConfig"))
                object.sslConfig = $root.ml_metadata.MetadataStoreServerConfig.SSLConfig.toObject(message.sslConfig, options);
            if (message.migrationOptions != null && message.hasOwnProperty("migrationOptions"))
                object.migrationOptions = $root.ml_metadata.MigrationOptions.toObject(message.migrationOptions, options);
            return object;
        };

        /**
         * Converts this MetadataStoreServerConfig to JSON.
         * @function toJSON
         * @memberof ml_metadata.MetadataStoreServerConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MetadataStoreServerConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        MetadataStoreServerConfig.SSLConfig = (function() {

            /**
             * Properties of a SSLConfig.
             * @memberof ml_metadata.MetadataStoreServerConfig
             * @interface ISSLConfig
             * @property {string|null} [serverKey] SSLConfig serverKey
             * @property {string|null} [serverCert] SSLConfig serverCert
             * @property {string|null} [customCa] SSLConfig customCa
             * @property {boolean|null} [clientVerify] SSLConfig clientVerify
             */

            /**
             * Constructs a new SSLConfig.
             * @memberof ml_metadata.MetadataStoreServerConfig
             * @classdesc Represents a SSLConfig.
             * @implements ISSLConfig
             * @constructor
             * @param {ml_metadata.MetadataStoreServerConfig.ISSLConfig=} [properties] Properties to set
             */
            function SSLConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SSLConfig serverKey.
             * @member {string} serverKey
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @instance
             */
            SSLConfig.prototype.serverKey = "";

            /**
             * SSLConfig serverCert.
             * @member {string} serverCert
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @instance
             */
            SSLConfig.prototype.serverCert = "";

            /**
             * SSLConfig customCa.
             * @member {string} customCa
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @instance
             */
            SSLConfig.prototype.customCa = "";

            /**
             * SSLConfig clientVerify.
             * @member {boolean} clientVerify
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @instance
             */
            SSLConfig.prototype.clientVerify = false;

            /**
             * Creates a new SSLConfig instance using the specified properties.
             * @function create
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @static
             * @param {ml_metadata.MetadataStoreServerConfig.ISSLConfig=} [properties] Properties to set
             * @returns {ml_metadata.MetadataStoreServerConfig.SSLConfig} SSLConfig instance
             */
            SSLConfig.create = function create(properties) {
                return new SSLConfig(properties);
            };

            /**
             * Encodes the specified SSLConfig message. Does not implicitly {@link ml_metadata.MetadataStoreServerConfig.SSLConfig.verify|verify} messages.
             * @function encode
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @static
             * @param {ml_metadata.MetadataStoreServerConfig.ISSLConfig} message SSLConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SSLConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serverKey != null && Object.hasOwnProperty.call(message, "serverKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverKey);
                if (message.serverCert != null && Object.hasOwnProperty.call(message, "serverCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.serverCert);
                if (message.customCa != null && Object.hasOwnProperty.call(message, "customCa"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.customCa);
                if (message.clientVerify != null && Object.hasOwnProperty.call(message, "clientVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.clientVerify);
                return writer;
            };

            /**
             * Encodes the specified SSLConfig message, length delimited. Does not implicitly {@link ml_metadata.MetadataStoreServerConfig.SSLConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @static
             * @param {ml_metadata.MetadataStoreServerConfig.ISSLConfig} message SSLConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SSLConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SSLConfig message from the specified reader or buffer.
             * @function decode
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ml_metadata.MetadataStoreServerConfig.SSLConfig} SSLConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SSLConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.MetadataStoreServerConfig.SSLConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serverKey = reader.string();
                        break;
                    case 2:
                        message.serverCert = reader.string();
                        break;
                    case 3:
                        message.customCa = reader.string();
                        break;
                    case 4:
                        message.clientVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SSLConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ml_metadata.MetadataStoreServerConfig.SSLConfig} SSLConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SSLConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SSLConfig message.
             * @function verify
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SSLConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serverKey != null && message.hasOwnProperty("serverKey"))
                    if (!$util.isString(message.serverKey))
                        return "serverKey: string expected";
                if (message.serverCert != null && message.hasOwnProperty("serverCert"))
                    if (!$util.isString(message.serverCert))
                        return "serverCert: string expected";
                if (message.customCa != null && message.hasOwnProperty("customCa"))
                    if (!$util.isString(message.customCa))
                        return "customCa: string expected";
                if (message.clientVerify != null && message.hasOwnProperty("clientVerify"))
                    if (typeof message.clientVerify !== "boolean")
                        return "clientVerify: boolean expected";
                return null;
            };

            /**
             * Creates a SSLConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ml_metadata.MetadataStoreServerConfig.SSLConfig} SSLConfig
             */
            SSLConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.ml_metadata.MetadataStoreServerConfig.SSLConfig)
                    return object;
                var message = new $root.ml_metadata.MetadataStoreServerConfig.SSLConfig();
                if (object.serverKey != null)
                    message.serverKey = String(object.serverKey);
                if (object.serverCert != null)
                    message.serverCert = String(object.serverCert);
                if (object.customCa != null)
                    message.customCa = String(object.customCa);
                if (object.clientVerify != null)
                    message.clientVerify = Boolean(object.clientVerify);
                return message;
            };

            /**
             * Creates a plain object from a SSLConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @static
             * @param {ml_metadata.MetadataStoreServerConfig.SSLConfig} message SSLConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SSLConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.serverKey = "";
                    object.serverCert = "";
                    object.customCa = "";
                    object.clientVerify = false;
                }
                if (message.serverKey != null && message.hasOwnProperty("serverKey"))
                    object.serverKey = message.serverKey;
                if (message.serverCert != null && message.hasOwnProperty("serverCert"))
                    object.serverCert = message.serverCert;
                if (message.customCa != null && message.hasOwnProperty("customCa"))
                    object.customCa = message.customCa;
                if (message.clientVerify != null && message.hasOwnProperty("clientVerify"))
                    object.clientVerify = message.clientVerify;
                return object;
            };

            /**
             * Converts this SSLConfig to JSON.
             * @function toJSON
             * @memberof ml_metadata.MetadataStoreServerConfig.SSLConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SSLConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SSLConfig;
        })();

        return MetadataStoreServerConfig;
    })();

    ml_metadata.ListOperationOptions = (function() {

        /**
         * Properties of a ListOperationOptions.
         * @memberof ml_metadata
         * @interface IListOperationOptions
         * @property {number|null} [maxResultSize] ListOperationOptions maxResultSize
         * @property {ml_metadata.ListOperationOptions.IOrderByField|null} [orderByField] ListOperationOptions orderByField
         * @property {string|null} [nextPageToken] ListOperationOptions nextPageToken
         * @property {string|null} [filterQuery] ListOperationOptions filterQuery
         */

        /**
         * Constructs a new ListOperationOptions.
         * @memberof ml_metadata
         * @classdesc Represents a ListOperationOptions.
         * @implements IListOperationOptions
         * @constructor
         * @param {ml_metadata.IListOperationOptions=} [properties] Properties to set
         */
        function ListOperationOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListOperationOptions maxResultSize.
         * @member {number} maxResultSize
         * @memberof ml_metadata.ListOperationOptions
         * @instance
         */
        ListOperationOptions.prototype.maxResultSize = 20;

        /**
         * ListOperationOptions orderByField.
         * @member {ml_metadata.ListOperationOptions.IOrderByField|null|undefined} orderByField
         * @memberof ml_metadata.ListOperationOptions
         * @instance
         */
        ListOperationOptions.prototype.orderByField = null;

        /**
         * ListOperationOptions nextPageToken.
         * @member {string} nextPageToken
         * @memberof ml_metadata.ListOperationOptions
         * @instance
         */
        ListOperationOptions.prototype.nextPageToken = "";

        /**
         * ListOperationOptions filterQuery.
         * @member {string} filterQuery
         * @memberof ml_metadata.ListOperationOptions
         * @instance
         */
        ListOperationOptions.prototype.filterQuery = "";

        /**
         * Creates a new ListOperationOptions instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ListOperationOptions
         * @static
         * @param {ml_metadata.IListOperationOptions=} [properties] Properties to set
         * @returns {ml_metadata.ListOperationOptions} ListOperationOptions instance
         */
        ListOperationOptions.create = function create(properties) {
            return new ListOperationOptions(properties);
        };

        /**
         * Encodes the specified ListOperationOptions message. Does not implicitly {@link ml_metadata.ListOperationOptions.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ListOperationOptions
         * @static
         * @param {ml_metadata.IListOperationOptions} message ListOperationOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListOperationOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.maxResultSize != null && Object.hasOwnProperty.call(message, "maxResultSize"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.maxResultSize);
            if (message.orderByField != null && Object.hasOwnProperty.call(message, "orderByField"))
                $root.ml_metadata.ListOperationOptions.OrderByField.encode(message.orderByField, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.nextPageToken);
            if (message.filterQuery != null && Object.hasOwnProperty.call(message, "filterQuery"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.filterQuery);
            return writer;
        };

        /**
         * Encodes the specified ListOperationOptions message, length delimited. Does not implicitly {@link ml_metadata.ListOperationOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ListOperationOptions
         * @static
         * @param {ml_metadata.IListOperationOptions} message ListOperationOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListOperationOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListOperationOptions message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ListOperationOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ListOperationOptions} ListOperationOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListOperationOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ListOperationOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.maxResultSize = reader.int32();
                    break;
                case 2:
                    message.orderByField = $root.ml_metadata.ListOperationOptions.OrderByField.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.nextPageToken = reader.string();
                    break;
                case 4:
                    message.filterQuery = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListOperationOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ListOperationOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ListOperationOptions} ListOperationOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListOperationOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListOperationOptions message.
         * @function verify
         * @memberof ml_metadata.ListOperationOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListOperationOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.maxResultSize != null && message.hasOwnProperty("maxResultSize"))
                if (!$util.isInteger(message.maxResultSize))
                    return "maxResultSize: integer expected";
            if (message.orderByField != null && message.hasOwnProperty("orderByField")) {
                var error = $root.ml_metadata.ListOperationOptions.OrderByField.verify(message.orderByField);
                if (error)
                    return "orderByField." + error;
            }
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                if (!$util.isString(message.nextPageToken))
                    return "nextPageToken: string expected";
            if (message.filterQuery != null && message.hasOwnProperty("filterQuery"))
                if (!$util.isString(message.filterQuery))
                    return "filterQuery: string expected";
            return null;
        };

        /**
         * Creates a ListOperationOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ListOperationOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ListOperationOptions} ListOperationOptions
         */
        ListOperationOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ListOperationOptions)
                return object;
            var message = new $root.ml_metadata.ListOperationOptions();
            if (object.maxResultSize != null)
                message.maxResultSize = object.maxResultSize | 0;
            if (object.orderByField != null) {
                if (typeof object.orderByField !== "object")
                    throw TypeError(".ml_metadata.ListOperationOptions.orderByField: object expected");
                message.orderByField = $root.ml_metadata.ListOperationOptions.OrderByField.fromObject(object.orderByField);
            }
            if (object.nextPageToken != null)
                message.nextPageToken = String(object.nextPageToken);
            if (object.filterQuery != null)
                message.filterQuery = String(object.filterQuery);
            return message;
        };

        /**
         * Creates a plain object from a ListOperationOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ListOperationOptions
         * @static
         * @param {ml_metadata.ListOperationOptions} message ListOperationOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListOperationOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.maxResultSize = 20;
                object.orderByField = null;
                object.nextPageToken = "";
                object.filterQuery = "";
            }
            if (message.maxResultSize != null && message.hasOwnProperty("maxResultSize"))
                object.maxResultSize = message.maxResultSize;
            if (message.orderByField != null && message.hasOwnProperty("orderByField"))
                object.orderByField = $root.ml_metadata.ListOperationOptions.OrderByField.toObject(message.orderByField, options);
            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                object.nextPageToken = message.nextPageToken;
            if (message.filterQuery != null && message.hasOwnProperty("filterQuery"))
                object.filterQuery = message.filterQuery;
            return object;
        };

        /**
         * Converts this ListOperationOptions to JSON.
         * @function toJSON
         * @memberof ml_metadata.ListOperationOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListOperationOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ListOperationOptions.OrderByField = (function() {

            /**
             * Properties of an OrderByField.
             * @memberof ml_metadata.ListOperationOptions
             * @interface IOrderByField
             * @property {ml_metadata.ListOperationOptions.OrderByField.Field|null} [field] OrderByField field
             * @property {boolean|null} [isAsc] OrderByField isAsc
             */

            /**
             * Constructs a new OrderByField.
             * @memberof ml_metadata.ListOperationOptions
             * @classdesc Represents an OrderByField.
             * @implements IOrderByField
             * @constructor
             * @param {ml_metadata.ListOperationOptions.IOrderByField=} [properties] Properties to set
             */
            function OrderByField(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OrderByField field.
             * @member {ml_metadata.ListOperationOptions.OrderByField.Field} field
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @instance
             */
            OrderByField.prototype.field = 3;

            /**
             * OrderByField isAsc.
             * @member {boolean} isAsc
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @instance
             */
            OrderByField.prototype.isAsc = true;

            /**
             * Creates a new OrderByField instance using the specified properties.
             * @function create
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @static
             * @param {ml_metadata.ListOperationOptions.IOrderByField=} [properties] Properties to set
             * @returns {ml_metadata.ListOperationOptions.OrderByField} OrderByField instance
             */
            OrderByField.create = function create(properties) {
                return new OrderByField(properties);
            };

            /**
             * Encodes the specified OrderByField message. Does not implicitly {@link ml_metadata.ListOperationOptions.OrderByField.verify|verify} messages.
             * @function encode
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @static
             * @param {ml_metadata.ListOperationOptions.IOrderByField} message OrderByField message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderByField.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.field != null && Object.hasOwnProperty.call(message, "field"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.field);
                if (message.isAsc != null && Object.hasOwnProperty.call(message, "isAsc"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isAsc);
                return writer;
            };

            /**
             * Encodes the specified OrderByField message, length delimited. Does not implicitly {@link ml_metadata.ListOperationOptions.OrderByField.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @static
             * @param {ml_metadata.ListOperationOptions.IOrderByField} message OrderByField message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderByField.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OrderByField message from the specified reader or buffer.
             * @function decode
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ml_metadata.ListOperationOptions.OrderByField} OrderByField
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderByField.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ListOperationOptions.OrderByField();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.field = reader.int32();
                        break;
                    case 2:
                        message.isAsc = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OrderByField message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ml_metadata.ListOperationOptions.OrderByField} OrderByField
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderByField.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OrderByField message.
             * @function verify
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrderByField.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.field != null && message.hasOwnProperty("field"))
                    switch (message.field) {
                    default:
                        return "field: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.isAsc != null && message.hasOwnProperty("isAsc"))
                    if (typeof message.isAsc !== "boolean")
                        return "isAsc: boolean expected";
                return null;
            };

            /**
             * Creates an OrderByField message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ml_metadata.ListOperationOptions.OrderByField} OrderByField
             */
            OrderByField.fromObject = function fromObject(object) {
                if (object instanceof $root.ml_metadata.ListOperationOptions.OrderByField)
                    return object;
                var message = new $root.ml_metadata.ListOperationOptions.OrderByField();
                switch (object.field) {
                case "FIELD_UNSPECIFIED":
                case 0:
                    message.field = 0;
                    break;
                case "CREATE_TIME":
                case 1:
                    message.field = 1;
                    break;
                case "LAST_UPDATE_TIME":
                case 2:
                    message.field = 2;
                    break;
                case "ID":
                case 3:
                    message.field = 3;
                    break;
                }
                if (object.isAsc != null)
                    message.isAsc = Boolean(object.isAsc);
                return message;
            };

            /**
             * Creates a plain object from an OrderByField message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @static
             * @param {ml_metadata.ListOperationOptions.OrderByField} message OrderByField
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrderByField.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.field = options.enums === String ? "ID" : 3;
                    object.isAsc = true;
                }
                if (message.field != null && message.hasOwnProperty("field"))
                    object.field = options.enums === String ? $root.ml_metadata.ListOperationOptions.OrderByField.Field[message.field] : message.field;
                if (message.isAsc != null && message.hasOwnProperty("isAsc"))
                    object.isAsc = message.isAsc;
                return object;
            };

            /**
             * Converts this OrderByField to JSON.
             * @function toJSON
             * @memberof ml_metadata.ListOperationOptions.OrderByField
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrderByField.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Field enum.
             * @name ml_metadata.ListOperationOptions.OrderByField.Field
             * @enum {number}
             * @property {number} FIELD_UNSPECIFIED=0 FIELD_UNSPECIFIED value
             * @property {number} CREATE_TIME=1 CREATE_TIME value
             * @property {number} LAST_UPDATE_TIME=2 LAST_UPDATE_TIME value
             * @property {number} ID=3 ID value
             */
            OrderByField.Field = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "FIELD_UNSPECIFIED"] = 0;
                values[valuesById[1] = "CREATE_TIME"] = 1;
                values[valuesById[2] = "LAST_UPDATE_TIME"] = 2;
                values[valuesById[3] = "ID"] = 3;
                return values;
            })();

            return OrderByField;
        })();

        return ListOperationOptions;
    })();

    ml_metadata.ListOperationNextPageToken = (function() {

        /**
         * Properties of a ListOperationNextPageToken.
         * @memberof ml_metadata
         * @interface IListOperationNextPageToken
         * @property {number|Long|null} [idOffset] ListOperationNextPageToken idOffset
         * @property {number|Long|null} [fieldOffset] ListOperationNextPageToken fieldOffset
         * @property {ml_metadata.IListOperationOptions|null} [setOptions] ListOperationNextPageToken setOptions
         * @property {Array.<number|Long>|null} [listedIds] ListOperationNextPageToken listedIds
         */

        /**
         * Constructs a new ListOperationNextPageToken.
         * @memberof ml_metadata
         * @classdesc Represents a ListOperationNextPageToken.
         * @implements IListOperationNextPageToken
         * @constructor
         * @param {ml_metadata.IListOperationNextPageToken=} [properties] Properties to set
         */
        function ListOperationNextPageToken(properties) {
            this.listedIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListOperationNextPageToken idOffset.
         * @member {number|Long} idOffset
         * @memberof ml_metadata.ListOperationNextPageToken
         * @instance
         */
        ListOperationNextPageToken.prototype.idOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ListOperationNextPageToken fieldOffset.
         * @member {number|Long} fieldOffset
         * @memberof ml_metadata.ListOperationNextPageToken
         * @instance
         */
        ListOperationNextPageToken.prototype.fieldOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ListOperationNextPageToken setOptions.
         * @member {ml_metadata.IListOperationOptions|null|undefined} setOptions
         * @memberof ml_metadata.ListOperationNextPageToken
         * @instance
         */
        ListOperationNextPageToken.prototype.setOptions = null;

        /**
         * ListOperationNextPageToken listedIds.
         * @member {Array.<number|Long>} listedIds
         * @memberof ml_metadata.ListOperationNextPageToken
         * @instance
         */
        ListOperationNextPageToken.prototype.listedIds = $util.emptyArray;

        /**
         * Creates a new ListOperationNextPageToken instance using the specified properties.
         * @function create
         * @memberof ml_metadata.ListOperationNextPageToken
         * @static
         * @param {ml_metadata.IListOperationNextPageToken=} [properties] Properties to set
         * @returns {ml_metadata.ListOperationNextPageToken} ListOperationNextPageToken instance
         */
        ListOperationNextPageToken.create = function create(properties) {
            return new ListOperationNextPageToken(properties);
        };

        /**
         * Encodes the specified ListOperationNextPageToken message. Does not implicitly {@link ml_metadata.ListOperationNextPageToken.verify|verify} messages.
         * @function encode
         * @memberof ml_metadata.ListOperationNextPageToken
         * @static
         * @param {ml_metadata.IListOperationNextPageToken} message ListOperationNextPageToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListOperationNextPageToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idOffset != null && Object.hasOwnProperty.call(message, "idOffset"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.idOffset);
            if (message.fieldOffset != null && Object.hasOwnProperty.call(message, "fieldOffset"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fieldOffset);
            if (message.setOptions != null && Object.hasOwnProperty.call(message, "setOptions"))
                $root.ml_metadata.ListOperationOptions.encode(message.setOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.listedIds != null && message.listedIds.length)
                for (var i = 0; i < message.listedIds.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.listedIds[i]);
            return writer;
        };

        /**
         * Encodes the specified ListOperationNextPageToken message, length delimited. Does not implicitly {@link ml_metadata.ListOperationNextPageToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ml_metadata.ListOperationNextPageToken
         * @static
         * @param {ml_metadata.IListOperationNextPageToken} message ListOperationNextPageToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListOperationNextPageToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListOperationNextPageToken message from the specified reader or buffer.
         * @function decode
         * @memberof ml_metadata.ListOperationNextPageToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ml_metadata.ListOperationNextPageToken} ListOperationNextPageToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListOperationNextPageToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ml_metadata.ListOperationNextPageToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.idOffset = reader.int64();
                    break;
                case 2:
                    message.fieldOffset = reader.int64();
                    break;
                case 3:
                    message.setOptions = $root.ml_metadata.ListOperationOptions.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.listedIds && message.listedIds.length))
                        message.listedIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.listedIds.push(reader.int64());
                    } else
                        message.listedIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListOperationNextPageToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ml_metadata.ListOperationNextPageToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ml_metadata.ListOperationNextPageToken} ListOperationNextPageToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListOperationNextPageToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListOperationNextPageToken message.
         * @function verify
         * @memberof ml_metadata.ListOperationNextPageToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListOperationNextPageToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.idOffset != null && message.hasOwnProperty("idOffset"))
                if (!$util.isInteger(message.idOffset) && !(message.idOffset && $util.isInteger(message.idOffset.low) && $util.isInteger(message.idOffset.high)))
                    return "idOffset: integer|Long expected";
            if (message.fieldOffset != null && message.hasOwnProperty("fieldOffset"))
                if (!$util.isInteger(message.fieldOffset) && !(message.fieldOffset && $util.isInteger(message.fieldOffset.low) && $util.isInteger(message.fieldOffset.high)))
                    return "fieldOffset: integer|Long expected";
            if (message.setOptions != null && message.hasOwnProperty("setOptions")) {
                var error = $root.ml_metadata.ListOperationOptions.verify(message.setOptions);
                if (error)
                    return "setOptions." + error;
            }
            if (message.listedIds != null && message.hasOwnProperty("listedIds")) {
                if (!Array.isArray(message.listedIds))
                    return "listedIds: array expected";
                for (var i = 0; i < message.listedIds.length; ++i)
                    if (!$util.isInteger(message.listedIds[i]) && !(message.listedIds[i] && $util.isInteger(message.listedIds[i].low) && $util.isInteger(message.listedIds[i].high)))
                        return "listedIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a ListOperationNextPageToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ml_metadata.ListOperationNextPageToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ml_metadata.ListOperationNextPageToken} ListOperationNextPageToken
         */
        ListOperationNextPageToken.fromObject = function fromObject(object) {
            if (object instanceof $root.ml_metadata.ListOperationNextPageToken)
                return object;
            var message = new $root.ml_metadata.ListOperationNextPageToken();
            if (object.idOffset != null)
                if ($util.Long)
                    (message.idOffset = $util.Long.fromValue(object.idOffset)).unsigned = false;
                else if (typeof object.idOffset === "string")
                    message.idOffset = parseInt(object.idOffset, 10);
                else if (typeof object.idOffset === "number")
                    message.idOffset = object.idOffset;
                else if (typeof object.idOffset === "object")
                    message.idOffset = new $util.LongBits(object.idOffset.low >>> 0, object.idOffset.high >>> 0).toNumber();
            if (object.fieldOffset != null)
                if ($util.Long)
                    (message.fieldOffset = $util.Long.fromValue(object.fieldOffset)).unsigned = false;
                else if (typeof object.fieldOffset === "string")
                    message.fieldOffset = parseInt(object.fieldOffset, 10);
                else if (typeof object.fieldOffset === "number")
                    message.fieldOffset = object.fieldOffset;
                else if (typeof object.fieldOffset === "object")
                    message.fieldOffset = new $util.LongBits(object.fieldOffset.low >>> 0, object.fieldOffset.high >>> 0).toNumber();
            if (object.setOptions != null) {
                if (typeof object.setOptions !== "object")
                    throw TypeError(".ml_metadata.ListOperationNextPageToken.setOptions: object expected");
                message.setOptions = $root.ml_metadata.ListOperationOptions.fromObject(object.setOptions);
            }
            if (object.listedIds) {
                if (!Array.isArray(object.listedIds))
                    throw TypeError(".ml_metadata.ListOperationNextPageToken.listedIds: array expected");
                message.listedIds = [];
                for (var i = 0; i < object.listedIds.length; ++i)
                    if ($util.Long)
                        (message.listedIds[i] = $util.Long.fromValue(object.listedIds[i])).unsigned = false;
                    else if (typeof object.listedIds[i] === "string")
                        message.listedIds[i] = parseInt(object.listedIds[i], 10);
                    else if (typeof object.listedIds[i] === "number")
                        message.listedIds[i] = object.listedIds[i];
                    else if (typeof object.listedIds[i] === "object")
                        message.listedIds[i] = new $util.LongBits(object.listedIds[i].low >>> 0, object.listedIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a ListOperationNextPageToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ml_metadata.ListOperationNextPageToken
         * @static
         * @param {ml_metadata.ListOperationNextPageToken} message ListOperationNextPageToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListOperationNextPageToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.listedIds = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.idOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.idOffset = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fieldOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fieldOffset = options.longs === String ? "0" : 0;
                object.setOptions = null;
            }
            if (message.idOffset != null && message.hasOwnProperty("idOffset"))
                if (typeof message.idOffset === "number")
                    object.idOffset = options.longs === String ? String(message.idOffset) : message.idOffset;
                else
                    object.idOffset = options.longs === String ? $util.Long.prototype.toString.call(message.idOffset) : options.longs === Number ? new $util.LongBits(message.idOffset.low >>> 0, message.idOffset.high >>> 0).toNumber() : message.idOffset;
            if (message.fieldOffset != null && message.hasOwnProperty("fieldOffset"))
                if (typeof message.fieldOffset === "number")
                    object.fieldOffset = options.longs === String ? String(message.fieldOffset) : message.fieldOffset;
                else
                    object.fieldOffset = options.longs === String ? $util.Long.prototype.toString.call(message.fieldOffset) : options.longs === Number ? new $util.LongBits(message.fieldOffset.low >>> 0, message.fieldOffset.high >>> 0).toNumber() : message.fieldOffset;
            if (message.setOptions != null && message.hasOwnProperty("setOptions"))
                object.setOptions = $root.ml_metadata.ListOperationOptions.toObject(message.setOptions, options);
            if (message.listedIds && message.listedIds.length) {
                object.listedIds = [];
                for (var j = 0; j < message.listedIds.length; ++j)
                    if (typeof message.listedIds[j] === "number")
                        object.listedIds[j] = options.longs === String ? String(message.listedIds[j]) : message.listedIds[j];
                    else
                        object.listedIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.listedIds[j]) : options.longs === Number ? new $util.LongBits(message.listedIds[j].low >>> 0, message.listedIds[j].high >>> 0).toNumber() : message.listedIds[j];
            }
            return object;
        };

        /**
         * Converts this ListOperationNextPageToken to JSON.
         * @function toJSON
         * @memberof ml_metadata.ListOperationNextPageToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListOperationNextPageToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListOperationNextPageToken;
    })();

    return ml_metadata;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Struct = (function() {

            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */

            /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */
            function Struct(properties) {
                this.fields = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */
            Struct.prototype.fields = $util.emptyObject;

            /**
             * Creates a new Struct instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             * @returns {google.protobuf.Struct} Struct instance
             */
            Struct.create = function create(properties) {
                return new Struct(properties);
            };

            /**
             * Encodes the specified Struct message. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fields != null && Object.hasOwnProperty.call(message, "fields"))
                    for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Struct message, length delimited. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Struct message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.fields === $util.emptyObject)
                            message.fields = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.google.protobuf.Value.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.fields[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Struct message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields))
                        return "fields: object expected";
                    var key = Object.keys(message.fields);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Struct message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Struct} Struct
             */
            Struct.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Struct)
                    return object;
                var message = new $root.google.protobuf.Struct();
                if (object.fields) {
                    if (typeof object.fields !== "object")
                        throw TypeError(".google.protobuf.Struct.fields: object expected");
                    message.fields = {};
                    for (var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {
                        if (typeof object.fields[keys[i]] !== "object")
                            throw TypeError(".google.protobuf.Struct.fields: object expected");
                        message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Struct message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.Struct} message Struct
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Struct.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.fields = {};
                var keys2;
                if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                    object.fields = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Struct to JSON.
             * @function toJSON
             * @memberof google.protobuf.Struct
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Struct.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Struct;
        })();

        protobuf.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */

            /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue|null|undefined} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.nullValue = null;

            /**
             * Value numberValue.
             * @member {number|null|undefined} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.numberValue = null;

            /**
             * Value stringValue.
             * @member {string|null|undefined} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.stringValue = null;

            /**
             * Value boolValue.
             * @member {boolean|null|undefined} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.boolValue = null;

            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.structValue = null;

            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.listValue = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue=} [properties] Properties to set
             * @returns {google.protobuf.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nullValue != null && Object.hasOwnProperty.call(message, "nullValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nullValue);
                if (message.numberValue != null && Object.hasOwnProperty.call(message, "numberValue"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.numberValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolValue);
                if (message.structValue != null && Object.hasOwnProperty.call(message, "structValue"))
                    $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.listValue != null && Object.hasOwnProperty.call(message, "listValue"))
                    $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nullValue = reader.int32();
                        break;
                    case 2:
                        message.numberValue = reader.double();
                        break;
                    case 3:
                        message.stringValue = reader.string();
                        break;
                    case 4:
                        message.boolValue = reader.bool();
                        break;
                    case 5:
                        message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch (message.nullValue) {
                    default:
                        return "nullValue: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number")
                        return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error)
                            return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error)
                            return "listValue." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Value)
                    return object;
                var message = new $root.google.protobuf.Value();
                switch (object.nullValue) {
                case "NULL_VALUE":
                case 0:
                    message.nullValue = 0;
                    break;
                }
                if (object.numberValue != null)
                    message.numberValue = Number(object.numberValue);
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.boolValue != null)
                    message.boolValue = Boolean(object.boolValue);
                if (object.structValue != null) {
                    if (typeof object.structValue !== "object")
                        throw TypeError(".google.protobuf.Value.structValue: object expected");
                    message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
                }
                if (object.listValue != null) {
                    if (typeof object.listValue !== "object")
                        throw TypeError(".google.protobuf.Value.listValue: object expected");
                    message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                    if (options.oneofs)
                        object.kind = "nullValue";
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
                    if (options.oneofs)
                        object.kind = "numberValue";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs)
                        object.kind = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs)
                        object.kind = "boolValue";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                    if (options.oneofs)
                        object.kind = "structValue";
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);
                    if (options.oneofs)
                        object.kind = "listValue";
                }
                return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Value;
        })();

        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {number}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */
        protobuf.NullValue = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        })();

        protobuf.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */

            /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */
            ListValue.prototype.values = $util.emptyArray;

            /**
             * Creates a new ListValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             * @returns {google.protobuf.ListValue} ListValue instance
             */
            ListValue.create = function create(properties) {
                return new ListValue(properties);
            };

            /**
             * Encodes the specified ListValue message. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        $root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListValue message, length delimited. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ListValue} ListValue
             */
            ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ListValue)
                    return object;
                var message = new $root.google.protobuf.ListValue();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".google.protobuf.ListValue.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".google.protobuf.ListValue.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListValue;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
